{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"themes/hexo-theme-even/source/favicon.ico","path":"favicon.ico","modified":1,"renderable":1},{"_id":"themes/hexo-theme-even/source/css/style.scss","path":"css/style.scss","modified":1,"renderable":1},{"_id":"themes/hexo-theme-even/source/fonts/chancery/apple-chancery-webfont.eot","path":"fonts/chancery/apple-chancery-webfont.eot","modified":1,"renderable":1},{"_id":"themes/hexo-theme-even/source/fonts/chancery/apple-chancery-webfont.ttf","path":"fonts/chancery/apple-chancery-webfont.ttf","modified":1,"renderable":1},{"_id":"themes/hexo-theme-even/source/js/src/bootstrap.js","path":"js/src/bootstrap.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-even/source/fonts/chancery/apple-chancery-webfont.woff","path":"fonts/chancery/apple-chancery-webfont.woff","modified":1,"renderable":1},{"_id":"themes/hexo-theme-even/source/js/src/even.js","path":"js/src/even.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-even/source/fonts/chancery/apple-chancery-webfont.woff2","path":"fonts/chancery/apple-chancery-webfont.woff2","modified":1,"renderable":1},{"_id":"themes/hexo-theme-even/source/lib/fancybox/blank.gif","path":"lib/fancybox/blank.gif","modified":1,"renderable":1},{"_id":"themes/hexo-theme-even/source/lib/fancybox/fancybox_loading.gif","path":"lib/fancybox/fancybox_loading.gif","modified":1,"renderable":1},{"_id":"themes/hexo-theme-even/source/lib/fancybox/fancybox_loading@2x.gif","path":"lib/fancybox/fancybox_loading@2x.gif","modified":1,"renderable":1},{"_id":"themes/hexo-theme-even/source/lib/fancybox/fancybox_overlay.png","path":"lib/fancybox/fancybox_overlay.png","modified":1,"renderable":1},{"_id":"themes/hexo-theme-even/source/lib/fancybox/fancybox_sprite.png","path":"lib/fancybox/fancybox_sprite.png","modified":1,"renderable":1},{"_id":"themes/hexo-theme-even/source/lib/fancybox/fancybox_sprite@2x.png","path":"lib/fancybox/fancybox_sprite@2x.png","modified":1,"renderable":1},{"_id":"themes/hexo-theme-even/source/lib/fancybox/jquery.fancybox.css","path":"lib/fancybox/jquery.fancybox.css","modified":1,"renderable":1},{"_id":"themes/hexo-theme-even/source/lib/fancybox/jquery.fancybox.pack.js","path":"lib/fancybox/jquery.fancybox.pack.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-even/source/lib/fancybox/jquery.fancybox.js","path":"lib/fancybox/jquery.fancybox.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-even/source/fonts/chancery/apple-chancery-webfont.svg","path":"fonts/chancery/apple-chancery-webfont.svg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-even/source/image/reward/alipay.png","path":"image/reward/alipay.png","modified":1,"renderable":1},{"_id":"themes/hexo-theme-even/source/lib/jquery/jquery-3.1.1.min.js","path":"lib/jquery/jquery-3.1.1.min.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-even/source/lib/fancybox/helpers/fancybox_buttons.png","path":"lib/fancybox/helpers/fancybox_buttons.png","modified":1,"renderable":1},{"_id":"themes/hexo-theme-even/source/lib/fancybox/helpers/jquery.fancybox-buttons.css","path":"lib/fancybox/helpers/jquery.fancybox-buttons.css","modified":1,"renderable":1},{"_id":"themes/hexo-theme-even/source/lib/fancybox/helpers/jquery.fancybox-buttons.js","path":"lib/fancybox/helpers/jquery.fancybox-buttons.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-even/source/lib/fancybox/helpers/jquery.fancybox-media.js","path":"lib/fancybox/helpers/jquery.fancybox-media.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-even/source/lib/fancybox/helpers/jquery.fancybox-thumbs.css","path":"lib/fancybox/helpers/jquery.fancybox-thumbs.css","modified":1,"renderable":1},{"_id":"themes/hexo-theme-even/source/lib/fancybox/helpers/jquery.fancybox-thumbs.js","path":"lib/fancybox/helpers/jquery.fancybox-thumbs.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-even/source/image/reward/wechat.png","path":"image/reward/wechat.png","modified":1,"renderable":1}],"Cache":[{"_id":"themes/hexo-theme-even/.eslintrc","hash":"e1d55211a5a880b97893b3c5b0882dd6ba0822b6","modified":1487037813000},{"_id":"themes/hexo-theme-even/_config.yml","hash":"8dce8d2ce49a5910470d98d63ff77fcb6b8ac592","modified":1487158762000},{"_id":"themes/hexo-theme-even/LICENSE","hash":"6fd796a4c624297885ceed920ac7130a96f29a85","modified":1487037813000},{"_id":"themes/hexo-theme-even/README.md","hash":"0ef730792d55e82b331ac99bcc18eb9a90a4c195","modified":1487158794000},{"_id":"themes/hexo-theme-even/package.json","hash":"809803d40b21f6afcd3c344ddd6dc325b820c700","modified":1487037813000},{"_id":"source/_drafts/Design-Pattern-1.md","hash":"2664de093064d6fe1f0ef72df371b461ec318531","modified":1496335998000},{"_id":"source/_drafts/WebServer-Architecture.md","hash":"b7cad1095558db6921e77144757ca66192003661","modified":1504022610000},{"_id":"source/_drafts/logs.md","hash":"4416829fddc1fc9f0d504f5cb913ddc15ca9ac8b","modified":1495300723000},{"_id":"source/_drafts/ideas.md","hash":"bfd59230828b4d0a4a8565247e4fc0686c67bf92","modified":1493052446000},{"_id":"source/_drafts/webbackend.md","hash":"b1a1acf89ff3fd019215687dfe7593b844f0620f","modified":1492517970000},{"_id":"source/_drafts/webvr.md","hash":"7bb397a2667fb65e540cf10e8275801547bf2fcb","modified":1490968554000},{"_id":"source/_posts/CSS-Tricks-Record.md","hash":"d5d5658d78f32b3d4954ac576f0f8b7d7051c371","modified":1513707922376},{"_id":"source/_posts/CSS-Animation.md","hash":"99f2de1561708c10acffb068ab543ce5474968ff","modified":1501402002000},{"_id":"source/_posts/Design-Rules.md","hash":"08116ced43ba4b6deeecfbc0f1ad6d3311217130","modified":1497542148000},{"_id":"source/_posts/ES6-异步编程.md","hash":"b2381b42d8fef0ddeb7d9c608677a54f5f08515a","modified":1494432782000},{"_id":"source/_posts/JSON-Encoding.md","hash":"d4fe7ce34e1de275236532c51b23840536fd0a67","modified":1513707460798},{"_id":"source/_posts/Hexo-With-GitHub.md","hash":"b4ae6e7b5a262dc532ff022d973a235d6ec80bfa","modified":1501402016000},{"_id":"source/_posts/Git-实践.md","hash":"c03a7cefec4003ed00cb4ceebb436530d08e47c0","modified":1495300712000},{"_id":"source/_posts/React-Redux-入门坑总结.md","hash":"3c8a9199e4581db2c1ca56624f5564a8102aae73","modified":1500169509000},{"_id":"source/_posts/JavaScript-ES5-总结.md","hash":"1bb04501e5f49ba445b4d2defba8689f2e4487ed","modified":1495374890000},{"_id":"source/_posts/React-源码阅读-Component-Mount.md","hash":"8ced65d78f9ce50cde1190c11f8537b54717032a","modified":1501400738000},{"_id":"source/_posts/可读性好的代码.md","hash":"5d59154ec916388119ba3a80f4be1ebf05f34937","modified":1495339582000},{"_id":"source/_posts/值得记录的一些小问题.md","hash":"17762564330b5ddafe7d3799de46de20afb81277","modified":1495373474000},{"_id":"source/_posts/前端面试方法.md","hash":"4a715b5c1b221d2a3693840471ed642501027c06","modified":1499644175000},{"_id":"source/_posts/React-源码阅读-Component-Update.md","hash":"ce56c3d37d11a1bb1f4e5f67111fa83e83d08723","modified":1501400751000},{"_id":"source/_posts/痛苦的反思.md","hash":"41bd566eb2b8f0e5b368c5080830653ebd3277e6","modified":1494514656000},{"_id":"themes/hexo-theme-even/languages/default.yml","hash":"eeaa1cf150c669c08f4b70336c819b8a8eac1d0b","modified":1487037813000},{"_id":"themes/hexo-theme-even/languages/en.yml","hash":"e5eebf05f48a53020ee798cac58b0c3e7f0a95f2","modified":1487037813000},{"_id":"themes/hexo-theme-even/languages/zh-cn.yml","hash":"9fca22d97f9381afc187e9b14d9f8de5c0f5d9c5","modified":1487037813000},{"_id":"themes/hexo-theme-even/layout/_layout.swig","hash":"6cc0eeedb6b871c2e044bb01604408b168ff9ba6","modified":1487037813000},{"_id":"themes/hexo-theme-even/layout/archive.swig","hash":"30971263c38e67bffb6fdd90d458f6c82a75c05d","modified":1487037813000},{"_id":"themes/hexo-theme-even/layout/index.swig","hash":"f3341b5f4af1eab0930a1d078b3022bbe0a59232","modified":1487037813000},{"_id":"themes/hexo-theme-even/layout/tags.swig","hash":"ae9500008d0b445d1962a34cdb59fde3106ed33a","modified":1487037813000},{"_id":"themes/hexo-theme-even/layout/page.swig","hash":"3a767206198efb3eb487d7061107212c2171106c","modified":1487037813000},{"_id":"themes/hexo-theme-even/layout/post.swig","hash":"a0ed82a3aa04d3554dd654a3cf6194644ae1574c","modified":1487037813000},{"_id":"themes/hexo-theme-even/source/favicon.ico","hash":"0505cec3b99707df7a681de37177b3cf7950cc5d","modified":1487037813000},{"_id":"themes/hexo-theme-even/layout/categories.swig","hash":"dc244e0ee1fc34f43d5b195b9c1f6ef6d3ad2d0d","modified":1487037813000},{"_id":"themes/hexo-theme-even/layout/_macro/post.swig","hash":"dab8bd87ef1a61e2d6966179faf0653efa1c1f02","modified":1487037813000},{"_id":"themes/hexo-theme-even/layout/_macro/archive.swig","hash":"09cde870c8392d93d4bde0862f2f53a87b196ad4","modified":1487037813000},{"_id":"themes/hexo-theme-even/layout/_partial/comments.swig","hash":"4bdae8e9d7031b927b3af9596d05f7a4fb4a866a","modified":1487037813000},{"_id":"themes/hexo-theme-even/layout/_partial/footer.swig","hash":"248a60fe0122daf3706a291e4313f629de29384f","modified":1487037813000},{"_id":"themes/hexo-theme-even/layout/_partial/header.swig","hash":"3d49a67a21cffc8e1d14feb4f7e12ee581938419","modified":1487037813000},{"_id":"themes/hexo-theme-even/layout/_partial/head.swig","hash":"5497cb03439d90b4ba7148bbc1e9d303539bb388","modified":1487037813000},{"_id":"themes/hexo-theme-even/layout/_partial/pagination.swig","hash":"3843e523b9a7a1c5973d0c2de05cc88467733e09","modified":1487037813000},{"_id":"themes/hexo-theme-even/layout/_script/comments.swig","hash":"256713e117d67e2caad21db52bc0d51460e4ff7e","modified":1487037813000},{"_id":"themes/hexo-theme-even/layout/_script/config.swig","hash":"b08bc15581466e0890abb9c60153e0281db6a2b8","modified":1487037813000},{"_id":"themes/hexo-theme-even/layout/_script/libs.swig","hash":"615f82ddd2f89e87a604b51773fd719c78f90580","modified":1487037813000},{"_id":"themes/hexo-theme-even/layout/_script/analytics.swig","hash":"24ba4a8adcaf09c9ede76405ee732385595d8e39","modified":1487037813000},{"_id":"themes/hexo-theme-even/layout/_script/theme.swig","hash":"cb81a0a6a6d5264cc6451dda3dd3a96101f89b1d","modified":1487037813000},{"_id":"themes/hexo-theme-even/source/css/_base.scss","hash":"f7e5619fc6c995d9ca77fd25b0b522c28eee1759","modified":1487037813000},{"_id":"themes/hexo-theme-even/source/css/_variables.scss","hash":"672f22bb8f1af4c86fb4721f939c0b035dd84ebd","modified":1487037813000},{"_id":"themes/hexo-theme-even/source/css/style.scss","hash":"0a405eb8f315a9ec1e32d550a456dc7651e9b261","modified":1487037813000},{"_id":"themes/hexo-theme-even/layout/_partial/_footer/social.swig","hash":"65368d0a5108fecc072eaea3b1fb04c597941729","modified":1487037813000},{"_id":"themes/hexo-theme-even/layout/_partial/_head/meta.swig","hash":"4692e4aa4675e069f886b7ee49bd610c00f3e3bd","modified":1487037813000},{"_id":"themes/hexo-theme-even/layout/_partial/_post/copyright.swig","hash":"dbd57ececb200ee220189f51cc748023b96592d8","modified":1487037813000},{"_id":"themes/hexo-theme-even/layout/_partial/_post/reward.swig","hash":"faf64b5461970fda72863e9779f3f024cb493658","modified":1487037813000},{"_id":"themes/hexo-theme-even/layout/_partial/_post/toc.swig","hash":"fc21e5b9ebaca219678d85b8c5e4b3ee013fca25","modified":1487037813000},{"_id":"themes/hexo-theme-even/layout/_script/_analytics/baidu-analytics.swig","hash":"5d62309b16071f1b6952891ec8e1f1d42e38a088","modified":1487037813000},{"_id":"themes/hexo-theme-even/layout/_script/_analytics/google-analytics.swig","hash":"f44684799386fbd4af6e5994b0c14c85eeff060c","modified":1487037813000},{"_id":"themes/hexo-theme-even/layout/_script/_comments/disqus.swig","hash":"0502145777d65515249680d3e4611f249e3d9ff8","modified":1487037813000},{"_id":"themes/hexo-theme-even/layout/_script/_comments/duoshou.swig","hash":"582cf94bc12b56c6a16b5f3aa0067b51f74b0d40","modified":1487037813000},{"_id":"themes/hexo-theme-even/source/css/_common/_animation.scss","hash":"f32d2444f0ab4dcb8b811ae1bccae6073f21a988","modified":1487037813000},{"_id":"themes/hexo-theme-even/source/css/_common/_normalize.scss","hash":"ece571f38180febaf02ace8187ead8318a300ea7","modified":1487037813000},{"_id":"themes/hexo-theme-even/source/css/_common/_utils.scss","hash":"21dfd8cfdb574504b97896a282044d93d972e338","modified":1487037813000},{"_id":"themes/hexo-theme-even/source/css/_custom/_custom.scss","hash":"d0873cd8554d515282a6792fcc3f5bd4a256b7a6","modified":1487037813000},{"_id":"themes/hexo-theme-even/source/css/_partial/_archive.scss","hash":"019ee950e5da4395c867b950c8da06d03310b3db","modified":1487037813000},{"_id":"themes/hexo-theme-even/source/css/_partial/_back-to-top.scss","hash":"c6f586ac04a9a0f3633dadf5c66be9e0c4027f1d","modified":1487037813000},{"_id":"themes/hexo-theme-even/source/css/_partial/_categories.scss","hash":"96f47000d25ef4e0e948f8f43fa4e2983ff0d746","modified":1487037813000},{"_id":"themes/hexo-theme-even/source/css/_partial/_footer.scss","hash":"76f3a72440be8aa1e93d8ddc5ea958777d1545ab","modified":1487037813000},{"_id":"themes/hexo-theme-even/source/css/_partial/_header.scss","hash":"f5853dbb2002dd74a0fa631122b48586d7ddbd3b","modified":1487037813000},{"_id":"themes/hexo-theme-even/source/css/_partial/_iconfont.scss","hash":"040de76b41583ff53049e4c2d195ccc9f3542a77","modified":1487037813000},{"_id":"themes/hexo-theme-even/source/css/_partial/_pagination.scss","hash":"b24db39534e180ebcebba2e81d91d9f1d534eea1","modified":1487037813000},{"_id":"themes/hexo-theme-even/source/css/_partial/_post.scss","hash":"7d03216b1fb5007ecc33412cacab74432c4e02d2","modified":1487037813000},{"_id":"themes/hexo-theme-even/source/css/_partial/_tags.scss","hash":"fb4bf54b34291d5b72598a7ba4d3e370c8ad9383","modified":1487037813000},{"_id":"themes/hexo-theme-even/source/fonts/chancery/apple-chancery-webfont.eot","hash":"fef78bd502f74fdbf0316123e176454cb3eb4e50","modified":1487037813000},{"_id":"themes/hexo-theme-even/source/fonts/chancery/apple-chancery-webfont.ttf","hash":"5e25c531901d8a9e37ab45a7f4acdbe5324b51b6","modified":1487037813000},{"_id":"themes/hexo-theme-even/source/js/src/bootstrap.js","hash":"5c792bac92ed4b0a452fe764ab387b03666ecb3c","modified":1487037813000},{"_id":"themes/hexo-theme-even/source/fonts/chancery/apple-chancery-webfont.woff","hash":"95beafe485d4bdbddfecbcf3b2bc9b2d9cf5f5c5","modified":1487037813000},{"_id":"themes/hexo-theme-even/source/js/src/even.js","hash":"298957bef548acbbba00750331f5e853184db328","modified":1487037813000},{"_id":"themes/hexo-theme-even/source/fonts/chancery/apple-chancery-webfont.woff2","hash":"afd0f74128f1c21c5a542b2e100870e74da663b6","modified":1487037813000},{"_id":"themes/hexo-theme-even/source/lib/fancybox/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1487037813000},{"_id":"themes/hexo-theme-even/source/lib/fancybox/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1487037813000},{"_id":"themes/hexo-theme-even/source/lib/fancybox/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1487037813000},{"_id":"themes/hexo-theme-even/source/lib/fancybox/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1487037813000},{"_id":"themes/hexo-theme-even/source/lib/fancybox/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1487037813000},{"_id":"themes/hexo-theme-even/source/lib/fancybox/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1487037813000},{"_id":"themes/hexo-theme-even/source/lib/fancybox/jquery.fancybox.css","hash":"5f163444617b6cf267342f06ac166a237bb62df9","modified":1487037813000},{"_id":"themes/hexo-theme-even/source/lib/fancybox/jquery.fancybox.pack.js","hash":"53360764b429c212f424399384417ccc233bb3be","modified":1487037813000},{"_id":"themes/hexo-theme-even/source/lib/fancybox/jquery.fancybox.js","hash":"1cf3d47b5ccb7cb6e9019c64f2a88d03a64853e4","modified":1487037813000},{"_id":"themes/hexo-theme-even/source/fonts/chancery/apple-chancery-webfont.svg","hash":"a94e508f306a742637653f98c6e8827b11d3c142","modified":1487037813000},{"_id":"themes/hexo-theme-even/source/image/reward/alipay.png","hash":"75e0f7d3f804f5ed5f6978ffdc6522224df1b701","modified":1487037813000},{"_id":"themes/hexo-theme-even/source/lib/jquery/jquery-3.1.1.min.js","hash":"f647a6d37dc4ca055ced3cf64bbc1f490070acba","modified":1487037813000},{"_id":"themes/hexo-theme-even/source/css/_partial/_footer/_copyright.scss","hash":"afbc0f90c674e5cd5fd7509eb1296d60b999d4e1","modified":1487037813000},{"_id":"themes/hexo-theme-even/source/css/_partial/_footer/_social.scss","hash":"bca6a1036951c2475278bfbd3a5ce51ff861e9a3","modified":1487037813000},{"_id":"themes/hexo-theme-even/source/css/_partial/_header/_logo.scss","hash":"f3fda6322fcc38d29cf439a422c57e09292adf68","modified":1487037813000},{"_id":"themes/hexo-theme-even/source/css/_partial/_header/_menu.scss","hash":"c4eeed0abe9a83ff0699b649f2ffd3e6f6530556","modified":1487037813000},{"_id":"themes/hexo-theme-even/source/css/_partial/_header/_search.scss","hash":"3e9655aecde9a09bf015c97c7b10434a807a1ac4","modified":1487037813000},{"_id":"themes/hexo-theme-even/source/css/_partial/_header/_mobile-navbar.scss","hash":"1633f9cb54a3b2d09be086e27e5e5d33c718ca69","modified":1487037813000},{"_id":"themes/hexo-theme-even/source/css/_partial/_post/_code.scss","hash":"0527e60cf1a152b02092f29e8c99e72594309d85","modified":1487037813000},{"_id":"themes/hexo-theme-even/source/css/_partial/_post/_content.scss","hash":"a00cd224d832aff0c4a6deefc0b2b91fe4548172","modified":1487037813000},{"_id":"themes/hexo-theme-even/source/css/_partial/_post/_header.scss","hash":"794b85495d917e24bbe2f2782f3c7e69b6845eee","modified":1487037813000},{"_id":"themes/hexo-theme-even/source/css/_partial/_post/_copyright.scss","hash":"9e33c5935885552d6abdf43e2b1e5a278211f052","modified":1487037813000},{"_id":"themes/hexo-theme-even/source/css/_partial/_post/_footer.scss","hash":"9f2ab0ac20b2a8bfd315febd387c399f72f43d10","modified":1487037813000},{"_id":"themes/hexo-theme-even/source/css/_partial/_post/_reward.scss","hash":"66ec9faa27ed879dc9a2ca59c73ed6bfd5e61dcd","modified":1487037813000},{"_id":"themes/hexo-theme-even/source/css/_partial/_post/_toc.scss","hash":"24ca97cb8845871b9fd8dcd2314d59248d90c682","modified":1487037813000},{"_id":"themes/hexo-theme-even/source/lib/fancybox/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1487037813000},{"_id":"themes/hexo-theme-even/source/lib/fancybox/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1487037813000},{"_id":"themes/hexo-theme-even/source/lib/fancybox/helpers/jquery.fancybox-buttons.js","hash":"91e41741c2e93f732c82aaacec4cfc6e3f3ec876","modified":1487037813000},{"_id":"themes/hexo-theme-even/source/lib/fancybox/helpers/jquery.fancybox-media.js","hash":"3bdf69ed2469e4fb57f5a95f17300eef891ff90d","modified":1487037813000},{"_id":"themes/hexo-theme-even/source/lib/fancybox/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1487037813000},{"_id":"themes/hexo-theme-even/source/lib/fancybox/helpers/jquery.fancybox-thumbs.js","hash":"53e194f4a72e649c04fb586dd57762b8c022800b","modified":1487037813000},{"_id":"themes/hexo-theme-even/source/image/reward/wechat.png","hash":"f9904f25b35fa9d38e221ef7089787d24ee8b02b","modified":1487037813000},{"_id":"public/2017/12/17/JSON-Encoding/index.html","hash":"8711c41266ec7cfa434dbb6f94d519ac8ec31ec7","modified":1513708016312},{"_id":"public/2017/07/30/CSS-Tricks-Record/index.html","hash":"421cc4e2bded02ec05dd4cc75dabef906733c154","modified":1513708016312},{"_id":"public/2017/07/25/CSS-Animation/index.html","hash":"3b7a2e2ad6b046370787f839debebd9f225a8827","modified":1513708016313},{"_id":"public/2017/07/10/前端面试方法/index.html","hash":"d20256b71a8c1fbddf3073a3c549efe3b452fb2d","modified":1513708016313},{"_id":"public/2017/05/21/值得记录的一些小问题/index.html","hash":"2f8f615368750ebf69bf7f1a4952405011482ee2","modified":1513708016313},{"_id":"public/2017/05/21/可读性好的代码/index.html","hash":"2a2cb87c8370a9ded1c9faa105471193a32b9350","modified":1513708016313},{"_id":"public/2017/04/23/痛苦的反思/index.html","hash":"d6b653c3c7db1a9ff70e7ed0b439c41e542efd39","modified":1513708016313},{"_id":"public/2017/03/05/Git-实践/index.html","hash":"1d93e1ed87bdb41ab97d2ac351ce05b34552516e","modified":1513708016313},{"_id":"public/2017/02/14/Hexo-With-GitHub/index.html","hash":"0e5cc2ff78a40a87ee76e89ca6b02371b754cf78","modified":1513708016313},{"_id":"public/archives/index.html","hash":"2db5ae24e6d444a263069ffa2c1e565eabfeff57","modified":1513708016313},{"_id":"public/archives/page/2/index.html","hash":"d2e132e7f3561ef2943093d47bdb7b3589895bc7","modified":1513708016313},{"_id":"public/archives/2017/index.html","hash":"acd85aec96e4c8c5c4f18a831521ee02f66f955f","modified":1513708016313},{"_id":"public/archives/2017/page/2/index.html","hash":"a4b022e8a4b51cb9a7834d00a191fbad8cb47b09","modified":1513708016313},{"_id":"public/archives/2017/02/index.html","hash":"eb33f5480db2b1f0c5069148c301f9aae738556f","modified":1513708016315},{"_id":"public/archives/2017/03/index.html","hash":"9dbf211381b6a0811f88a439a03da319e7278494","modified":1513708016315},{"_id":"public/archives/2017/04/index.html","hash":"e75bdf9fe5cf5f8c7a27a16b91034f0daf1bbbe7","modified":1513708016315},{"_id":"public/archives/2017/05/index.html","hash":"e13065f31a27b91c00bb307a33fec00db81f4675","modified":1513708016315},{"_id":"public/archives/2017/06/index.html","hash":"2df7751dd29d20957f3514ecb4c0fc9cbbb5f68b","modified":1513708016315},{"_id":"public/archives/2017/07/index.html","hash":"ee0f3bb16e9c7692470be4a980ba93ddfaf4757e","modified":1513708016315},{"_id":"public/archives/2017/12/index.html","hash":"27a710d3957f48e702bfde4d05c11b05e58dffae","modified":1513708016315},{"_id":"public/tags/css/index.html","hash":"7e67fa60c29151738cabc3ec2c0479056119614f","modified":1513708016315},{"_id":"public/tags/Javascript-异步编程/index.html","hash":"918e6503ff07c8bf3e7a14e3399c80bd2f17df2f","modified":1513708016315},{"_id":"public/tags/Encoding/index.html","hash":"c8cd150cf8aaca110e9bcc5d8bdfdf967bcfea13","modified":1513708016315},{"_id":"public/tags/git/index.html","hash":"119bb468de0a9daf5b1723133b3116f34b56026f","modified":1513708016316},{"_id":"public/tags/Web/index.html","hash":"8d77f2247c4605fb093d9989962f2ea2ca7b162b","modified":1513708016316},{"_id":"public/tags/JavaScript-ECMA/index.html","hash":"0d0802fabeebe2cdd8e4ab88549ede79a9e7b837","modified":1513708016316},{"_id":"public/tags/react/index.html","hash":"6bae9f17f6b97d8eb5aba5adb2ee43f66c724ace","modified":1513708016316},{"_id":"public/tags/code-techniques/index.html","hash":"95b4712ac8e1d5c3eeac92e93a556e549f624f9f","modified":1513708016316},{"_id":"public/tags/javascript/index.html","hash":"1dbc81ce322a97c995b393d8265d3e85b5933e52","modified":1513708016316},{"_id":"public/tags/面试/index.html","hash":"ef3020033334653a0463e734849856a4fea479a9","modified":1513708016316},{"_id":"public/tags/随笔/index.html","hash":"36f0a4f6272ba202ff4984ebffe7c903469ae215","modified":1513708016316},{"_id":"public/tags/react-源码-Component-setState/index.html","hash":"73db6c16288f38bcbcd18553f69effaa51a4b199","modified":1513708016316},{"_id":"public/2017/07/07/React-源码阅读-Component-Update/index.html","hash":"759000ea931eadcc3a21e8a1ed0a5273afb3e447","modified":1513708016316},{"_id":"public/2017/07/01/React-源码阅读-Component-Mount/index.html","hash":"b9fab9e223375e3c2d8bdf17efa1373705edec7f","modified":1513708016316},{"_id":"public/2017/06/15/Design-Rules/index.html","hash":"88d45cfea91ee335480dedc9b16dc2e0bda7c1da","modified":1513708016316},{"_id":"public/2017/04/03/ES6-异步编程/index.html","hash":"92f93359de919909664fb968f9fdac6b6cb7fbaa","modified":1513708016317},{"_id":"public/2017/02/27/React-Redux-入门坑总结/index.html","hash":"09d0a32a52a74ccb1ef1683498402ea7f291f6cd","modified":1513708016317},{"_id":"public/2017/02/17/JavaScript-ES5-总结/index.html","hash":"fc5144b2b4a70df585ea439a74f64bcd69411235","modified":1513708016317},{"_id":"public/index.html","hash":"7e08f1dbdfb62bfd56b492946ff2bd76afa17873","modified":1513708016317},{"_id":"public/page/2/index.html","hash":"efcfee863e62ca69071cba86f605b89e058a4469","modified":1513708016317},{"_id":"public/favicon.ico","hash":"0505cec3b99707df7a681de37177b3cf7950cc5d","modified":1513708016334},{"_id":"public/fonts/chancery/apple-chancery-webfont.eot","hash":"fef78bd502f74fdbf0316123e176454cb3eb4e50","modified":1513708016334},{"_id":"public/fonts/chancery/apple-chancery-webfont.ttf","hash":"5e25c531901d8a9e37ab45a7f4acdbe5324b51b6","modified":1513708016334},{"_id":"public/fonts/chancery/apple-chancery-webfont.woff","hash":"95beafe485d4bdbddfecbcf3b2bc9b2d9cf5f5c5","modified":1513708016334},{"_id":"public/fonts/chancery/apple-chancery-webfont.woff2","hash":"afd0f74128f1c21c5a542b2e100870e74da663b6","modified":1513708016334},{"_id":"public/lib/fancybox/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1513708016334},{"_id":"public/lib/fancybox/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1513708016334},{"_id":"public/lib/fancybox/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1513708016334},{"_id":"public/lib/fancybox/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1513708016334},{"_id":"public/lib/fancybox/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1513708016334},{"_id":"public/lib/fancybox/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1513708016334},{"_id":"public/lib/fancybox/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1513708016334},{"_id":"public/fonts/chancery/apple-chancery-webfont.svg","hash":"a94e508f306a742637653f98c6e8827b11d3c142","modified":1513708016366},{"_id":"public/image/reward/alipay.png","hash":"75e0f7d3f804f5ed5f6978ffdc6522224df1b701","modified":1513708016368},{"_id":"public/js/src/bootstrap.js","hash":"5c792bac92ed4b0a452fe764ab387b03666ecb3c","modified":1513708016388},{"_id":"public/js/src/even.js","hash":"298957bef548acbbba00750331f5e853184db328","modified":1513708016389},{"_id":"public/lib/fancybox/jquery.fancybox.css","hash":"5f163444617b6cf267342f06ac166a237bb62df9","modified":1513708016389},{"_id":"public/lib/fancybox/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1513708016389},{"_id":"public/lib/fancybox/helpers/jquery.fancybox-buttons.js","hash":"91e41741c2e93f732c82aaacec4cfc6e3f3ec876","modified":1513708016389},{"_id":"public/lib/fancybox/helpers/jquery.fancybox-media.js","hash":"3bdf69ed2469e4fb57f5a95f17300eef891ff90d","modified":1513708016394},{"_id":"public/lib/fancybox/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1513708016395},{"_id":"public/lib/fancybox/helpers/jquery.fancybox-thumbs.js","hash":"53e194f4a72e649c04fb586dd57762b8c022800b","modified":1513708016395},{"_id":"public/lib/fancybox/jquery.fancybox.pack.js","hash":"53360764b429c212f424399384417ccc233bb3be","modified":1513708016395},{"_id":"public/lib/fancybox/jquery.fancybox.js","hash":"1cf3d47b5ccb7cb6e9019c64f2a88d03a64853e4","modified":1513708016398},{"_id":"public/lib/jquery/jquery-3.1.1.min.js","hash":"f647a6d37dc4ca055ced3cf64bbc1f490070acba","modified":1513708016399},{"_id":"public/image/reward/wechat.png","hash":"f9904f25b35fa9d38e221ef7089787d24ee8b02b","modified":1513708016401},{"_id":"public/css/style.css","hash":"6271e40206489e77ae6884794348ea0d0785c32a","modified":1513708016429}],"Category":[],"Data":[],"Page":[],"Post":[{"title":"Design-Pattern-1","_content":"\n## some functions\n模拟耗时操作\n```javascript\nfunction sleep(ms) {\n  return new Promise(resolve => setTimeout(resolve, ms));\n}\n\nasync function work(ms) {\n  console.log('Taking a break...');\n  await sleep(ms);\n  console.log('Two second later');\n}\n```\n\ndemo();\n## Decorator\n```javascript\nfunction decorator(func) {\n    function tfunc(){\n        console.log(\"##decorator##\");\n        func.apply(undefined, tfunc.arguments);\n    }\n    return tfunc;\n}\n\nfunction func(s1, s2) {\n    console.log(s1, s2);\n}\n\ndecorator(func)(\"Hello, World\");\n```\n\nMemorizer\n\n```javascript\nfunction memorizer(func, hashFunc) {\n    let memorizer = {};\n    function run() {\n        let inputs = run.arguments;\n        let keyString = '';\n        for(let index in inputs) {\n            if (inputs.hasOwnProperty(index)){\n                keyString += inputs[index];\n            }\n        }\n        let key = hashFunc ? hashFunc.apply(undefined, inputs) : keyString;\n        return memorizer[key] || func.apply(undefined, inputs);\n    }\n    return run;\n}\n\nfunction addTwoNum(a,b) {\n    return a + b;\n}\n```\n\n## Proxy\n### What\nRequests =-=-=-=-=-=-=-=-=-=> Instance\n    \\=========> Proxy ==========/\n也就是说 Proxy 可以被外界当作 Instance 来使用，从而达到在外界不知道 Instance 的情况下，完成了需要 Intance 的任务。\n\n### Why\n那么究竟为什么需要使用 Proxy 来代替 Instance 来做到这一点呢？\n结合具体场景大概有这么几种情况下，Proxy 的值得使用：\n1. Remote Proxy: 这种情况下实际上是对远程通信的一种封装，当然远程通信的服务端使用的也是 oop 思想，在约定好通信规则后，便可以通过 remote proxy 在本地完全无需感知 remote instance 的情况下，直接完成相应的任务\n2. Virtual Proxy: 这种情况一般是指 Instance 的创建过程比较耗时，因此通过 Proxy 来做到 create on demand\n3. Protection Proxy: 当 Instance 存在访问权限的时候，可以通过 Proxy 来做，也就是把访问的控制逻辑放在 proxy 中S\n4. Smart Reference： 当需要在访问 Instance 的时候进行某些功能增强，可以通过 Proxy 来做，个人觉得，这点包含了第三点\n\n# Behavior Pattern\n## Command\n类似于 callback，用于处理事件响应，比如一个 app 的 button 的 onClick 事件被触发了，那么如何处理 onClick 这个事件呢？\n使用 Command 模式的话，就会使用 Command 这个类来封装这个事件的处理，这个 Command 类包含方法 execute，其中会绑定一个 receiver，也就是这个命令的接受者，并且定义了 receiver 的响应逻辑。\n举个 OpenCommand 的例子，用户点击了 open button，那么 OpenCommand 的 execute 方法就会被调用，那么怎么实现这个 execute 方法呢？\n```javascript\nclass OpenCommand extends Command {\n    constructor(app) {\n        this._app = app;\n    }\n\n    execute() {\n        const file = askUserForDocName();\n        if (file) {\n            this._app.openDoc(file);\n        }\n    }\n}\n```\n\n","source":"_drafts/Design-Pattern-1.md","raw":"---\ntitle: Design-Pattern-1\ntags: Design-Pattern ES6\n---\n\n## some functions\n模拟耗时操作\n```javascript\nfunction sleep(ms) {\n  return new Promise(resolve => setTimeout(resolve, ms));\n}\n\nasync function work(ms) {\n  console.log('Taking a break...');\n  await sleep(ms);\n  console.log('Two second later');\n}\n```\n\ndemo();\n## Decorator\n```javascript\nfunction decorator(func) {\n    function tfunc(){\n        console.log(\"##decorator##\");\n        func.apply(undefined, tfunc.arguments);\n    }\n    return tfunc;\n}\n\nfunction func(s1, s2) {\n    console.log(s1, s2);\n}\n\ndecorator(func)(\"Hello, World\");\n```\n\nMemorizer\n\n```javascript\nfunction memorizer(func, hashFunc) {\n    let memorizer = {};\n    function run() {\n        let inputs = run.arguments;\n        let keyString = '';\n        for(let index in inputs) {\n            if (inputs.hasOwnProperty(index)){\n                keyString += inputs[index];\n            }\n        }\n        let key = hashFunc ? hashFunc.apply(undefined, inputs) : keyString;\n        return memorizer[key] || func.apply(undefined, inputs);\n    }\n    return run;\n}\n\nfunction addTwoNum(a,b) {\n    return a + b;\n}\n```\n\n## Proxy\n### What\nRequests =-=-=-=-=-=-=-=-=-=> Instance\n    \\=========> Proxy ==========/\n也就是说 Proxy 可以被外界当作 Instance 来使用，从而达到在外界不知道 Instance 的情况下，完成了需要 Intance 的任务。\n\n### Why\n那么究竟为什么需要使用 Proxy 来代替 Instance 来做到这一点呢？\n结合具体场景大概有这么几种情况下，Proxy 的值得使用：\n1. Remote Proxy: 这种情况下实际上是对远程通信的一种封装，当然远程通信的服务端使用的也是 oop 思想，在约定好通信规则后，便可以通过 remote proxy 在本地完全无需感知 remote instance 的情况下，直接完成相应的任务\n2. Virtual Proxy: 这种情况一般是指 Instance 的创建过程比较耗时，因此通过 Proxy 来做到 create on demand\n3. Protection Proxy: 当 Instance 存在访问权限的时候，可以通过 Proxy 来做，也就是把访问的控制逻辑放在 proxy 中S\n4. Smart Reference： 当需要在访问 Instance 的时候进行某些功能增强，可以通过 Proxy 来做，个人觉得，这点包含了第三点\n\n# Behavior Pattern\n## Command\n类似于 callback，用于处理事件响应，比如一个 app 的 button 的 onClick 事件被触发了，那么如何处理 onClick 这个事件呢？\n使用 Command 模式的话，就会使用 Command 这个类来封装这个事件的处理，这个 Command 类包含方法 execute，其中会绑定一个 receiver，也就是这个命令的接受者，并且定义了 receiver 的响应逻辑。\n举个 OpenCommand 的例子，用户点击了 open button，那么 OpenCommand 的 execute 方法就会被调用，那么怎么实现这个 execute 方法呢？\n```javascript\nclass OpenCommand extends Command {\n    constructor(app) {\n        this._app = app;\n    }\n\n    execute() {\n        const file = askUserForDocName();\n        if (file) {\n            this._app.openDoc(file);\n        }\n    }\n}\n```\n\n","slug":"Design-Pattern-1","published":0,"date":"2017-05-10T16:19:03.000Z","updated":"2017-06-01T16:53:18.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjbdyo30l0000nf8jlzfunu8x","content":"<h2 id=\"some-functions\"><a href=\"#some-functions\" class=\"headerlink\" title=\"some functions\"></a>some functions</h2><p>模拟耗时操作<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">sleep</span>(<span class=\"params\">ms</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"params\">resolve</span> =&gt;</span> setTimeout(resolve, ms));</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">work</span>(<span class=\"params\">ms</span>) </span>&#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'Taking a break...'</span>);</div><div class=\"line\">  <span class=\"keyword\">await</span> sleep(ms);</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'Two second later'</span>);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>demo();</p>\n<h2 id=\"Decorator\"><a href=\"#Decorator\" class=\"headerlink\" title=\"Decorator\"></a>Decorator</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">decorator</span>(<span class=\"params\">func</span>) </span>&#123;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">tfunc</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">\"##decorator##\"</span>);</div><div class=\"line\">        func.apply(<span class=\"literal\">undefined</span>, tfunc.arguments);</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> tfunc;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">func</span>(<span class=\"params\">s1, s2</span>) </span>&#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(s1, s2);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">decorator(func)(<span class=\"string\">\"Hello, World\"</span>);</div></pre></td></tr></table></figure>\n<p>Memorizer</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">memorizer</span>(<span class=\"params\">func, hashFunc</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">let</span> memorizer = &#123;&#125;;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">run</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">let</span> inputs = run.arguments;</div><div class=\"line\">        <span class=\"keyword\">let</span> keyString = <span class=\"string\">''</span>;</div><div class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> index <span class=\"keyword\">in</span> inputs) &#123;</div><div class=\"line\">            <span class=\"keyword\">if</span> (inputs.hasOwnProperty(index))&#123;</div><div class=\"line\">                keyString += inputs[index];</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">let</span> key = hashFunc ? hashFunc.apply(<span class=\"literal\">undefined</span>, inputs) : keyString;</div><div class=\"line\">        <span class=\"keyword\">return</span> memorizer[key] || func.apply(<span class=\"literal\">undefined</span>, inputs);</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> run;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">addTwoNum</span>(<span class=\"params\">a,b</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> a + b;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"Proxy\"><a href=\"#Proxy\" class=\"headerlink\" title=\"Proxy\"></a>Proxy</h2><h3 id=\"What\"><a href=\"#What\" class=\"headerlink\" title=\"What\"></a>What</h3><p>Requests =-=-=-=-=-=-=-=-=-=&gt; Instance<br>    \\=========&gt; Proxy ==========/<br>也就是说 Proxy 可以被外界当作 Instance 来使用，从而达到在外界不知道 Instance 的情况下，完成了需要 Intance 的任务。</p>\n<h3 id=\"Why\"><a href=\"#Why\" class=\"headerlink\" title=\"Why\"></a>Why</h3><p>那么究竟为什么需要使用 Proxy 来代替 Instance 来做到这一点呢？<br>结合具体场景大概有这么几种情况下，Proxy 的值得使用：</p>\n<ol>\n<li>Remote Proxy: 这种情况下实际上是对远程通信的一种封装，当然远程通信的服务端使用的也是 oop 思想，在约定好通信规则后，便可以通过 remote proxy 在本地完全无需感知 remote instance 的情况下，直接完成相应的任务</li>\n<li>Virtual Proxy: 这种情况一般是指 Instance 的创建过程比较耗时，因此通过 Proxy 来做到 create on demand</li>\n<li>Protection Proxy: 当 Instance 存在访问权限的时候，可以通过 Proxy 来做，也就是把访问的控制逻辑放在 proxy 中S</li>\n<li>Smart Reference： 当需要在访问 Instance 的时候进行某些功能增强，可以通过 Proxy 来做，个人觉得，这点包含了第三点</li>\n</ol>\n<h1 id=\"Behavior-Pattern\"><a href=\"#Behavior-Pattern\" class=\"headerlink\" title=\"Behavior Pattern\"></a>Behavior Pattern</h1><h2 id=\"Command\"><a href=\"#Command\" class=\"headerlink\" title=\"Command\"></a>Command</h2><p>类似于 callback，用于处理事件响应，比如一个 app 的 button 的 onClick 事件被触发了，那么如何处理 onClick 这个事件呢？<br>使用 Command 模式的话，就会使用 Command 这个类来封装这个事件的处理，这个 Command 类包含方法 execute，其中会绑定一个 receiver，也就是这个命令的接受者，并且定义了 receiver 的响应逻辑。<br>举个 OpenCommand 的例子，用户点击了 open button，那么 OpenCommand 的 execute 方法就会被调用，那么怎么实现这个 execute 方法呢？<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">OpenCommand</span> <span class=\"keyword\">extends</span> <span class=\"title\">Command</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">constructor</span>(app) &#123;</div><div class=\"line\">        <span class=\"keyword\">this</span>._app = app;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    execute() &#123;</div><div class=\"line\">        <span class=\"keyword\">const</span> file = askUserForDocName();</div><div class=\"line\">        <span class=\"keyword\">if</span> (file) &#123;</div><div class=\"line\">            <span class=\"keyword\">this</span>._app.openDoc(file);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n","excerpt":"","more":"<h2 id=\"some-functions\"><a href=\"#some-functions\" class=\"headerlink\" title=\"some functions\"></a>some functions</h2><p>模拟耗时操作<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">sleep</span>(<span class=\"params\">ms</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"params\">resolve</span> =&gt;</span> setTimeout(resolve, ms));</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">work</span>(<span class=\"params\">ms</span>) </span>&#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'Taking a break...'</span>);</div><div class=\"line\">  <span class=\"keyword\">await</span> sleep(ms);</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'Two second later'</span>);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>demo();</p>\n<h2 id=\"Decorator\"><a href=\"#Decorator\" class=\"headerlink\" title=\"Decorator\"></a>Decorator</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">decorator</span>(<span class=\"params\">func</span>) </span>&#123;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">tfunc</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">\"##decorator##\"</span>);</div><div class=\"line\">        func.apply(<span class=\"literal\">undefined</span>, tfunc.arguments);</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> tfunc;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">func</span>(<span class=\"params\">s1, s2</span>) </span>&#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(s1, s2);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">decorator(func)(<span class=\"string\">\"Hello, World\"</span>);</div></pre></td></tr></table></figure>\n<p>Memorizer</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">memorizer</span>(<span class=\"params\">func, hashFunc</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">let</span> memorizer = &#123;&#125;;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">run</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">let</span> inputs = run.arguments;</div><div class=\"line\">        <span class=\"keyword\">let</span> keyString = <span class=\"string\">''</span>;</div><div class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> index <span class=\"keyword\">in</span> inputs) &#123;</div><div class=\"line\">            <span class=\"keyword\">if</span> (inputs.hasOwnProperty(index))&#123;</div><div class=\"line\">                keyString += inputs[index];</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">let</span> key = hashFunc ? hashFunc.apply(<span class=\"literal\">undefined</span>, inputs) : keyString;</div><div class=\"line\">        <span class=\"keyword\">return</span> memorizer[key] || func.apply(<span class=\"literal\">undefined</span>, inputs);</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> run;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">addTwoNum</span>(<span class=\"params\">a,b</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> a + b;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"Proxy\"><a href=\"#Proxy\" class=\"headerlink\" title=\"Proxy\"></a>Proxy</h2><h3 id=\"What\"><a href=\"#What\" class=\"headerlink\" title=\"What\"></a>What</h3><p>Requests =-=-=-=-=-=-=-=-=-=&gt; Instance<br>    \\=========&gt; Proxy ==========/<br>也就是说 Proxy 可以被外界当作 Instance 来使用，从而达到在外界不知道 Instance 的情况下，完成了需要 Intance 的任务。</p>\n<h3 id=\"Why\"><a href=\"#Why\" class=\"headerlink\" title=\"Why\"></a>Why</h3><p>那么究竟为什么需要使用 Proxy 来代替 Instance 来做到这一点呢？<br>结合具体场景大概有这么几种情况下，Proxy 的值得使用：</p>\n<ol>\n<li>Remote Proxy: 这种情况下实际上是对远程通信的一种封装，当然远程通信的服务端使用的也是 oop 思想，在约定好通信规则后，便可以通过 remote proxy 在本地完全无需感知 remote instance 的情况下，直接完成相应的任务</li>\n<li>Virtual Proxy: 这种情况一般是指 Instance 的创建过程比较耗时，因此通过 Proxy 来做到 create on demand</li>\n<li>Protection Proxy: 当 Instance 存在访问权限的时候，可以通过 Proxy 来做，也就是把访问的控制逻辑放在 proxy 中S</li>\n<li>Smart Reference： 当需要在访问 Instance 的时候进行某些功能增强，可以通过 Proxy 来做，个人觉得，这点包含了第三点</li>\n</ol>\n<h1 id=\"Behavior-Pattern\"><a href=\"#Behavior-Pattern\" class=\"headerlink\" title=\"Behavior Pattern\"></a>Behavior Pattern</h1><h2 id=\"Command\"><a href=\"#Command\" class=\"headerlink\" title=\"Command\"></a>Command</h2><p>类似于 callback，用于处理事件响应，比如一个 app 的 button 的 onClick 事件被触发了，那么如何处理 onClick 这个事件呢？<br>使用 Command 模式的话，就会使用 Command 这个类来封装这个事件的处理，这个 Command 类包含方法 execute，其中会绑定一个 receiver，也就是这个命令的接受者，并且定义了 receiver 的响应逻辑。<br>举个 OpenCommand 的例子，用户点击了 open button，那么 OpenCommand 的 execute 方法就会被调用，那么怎么实现这个 execute 方法呢？<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">OpenCommand</span> <span class=\"keyword\">extends</span> <span class=\"title\">Command</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">constructor</span>(app) &#123;</div><div class=\"line\">        <span class=\"keyword\">this</span>._app = app;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    execute() &#123;</div><div class=\"line\">        <span class=\"keyword\">const</span> file = askUserForDocName();</div><div class=\"line\">        <span class=\"keyword\">if</span> (file) &#123;</div><div class=\"line\">            <span class=\"keyword\">this</span>._app.openDoc(file);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n"},{"title":"WebServer-Architecture","_content":"\n## Web Server Software\nWeb Server Software is different from Web Server Program whose number is much greater.\n\n## Accepting Client Connections\nIdentification is main work in this proceduer:\n+ Use `reverse DNS` to find out the hostname for some particular IP but this feature is always disabled because of its monster waste of time.\n+ `ident` protocool makes server send a request to the client who is always running identd Identification Protocol daemon software. However, this is not common in public internet because its dangerous and unsecurity.\n\n## \n ","source":"_drafts/WebServer-Architecture.md","raw":"---\ntitle: WebServer-Architecture\ntags: http webserver\n---\n\n## Web Server Software\nWeb Server Software is different from Web Server Program whose number is much greater.\n\n## Accepting Client Connections\nIdentification is main work in this proceduer:\n+ Use `reverse DNS` to find out the hostname for some particular IP but this feature is always disabled because of its monster waste of time.\n+ `ident` protocool makes server send a request to the client who is always running identd Identification Protocol daemon software. However, this is not common in public internet because its dangerous and unsecurity.\n\n## \n ","slug":"WebServer-Architecture","published":0,"date":"2017-08-28T23:47:30.000Z","updated":"2017-08-29T16:03:30.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjbdyo30p0001nf8jgkq3ixce","content":"<h2 id=\"Web-Server-Software\"><a href=\"#Web-Server-Software\" class=\"headerlink\" title=\"Web Server Software\"></a>Web Server Software</h2><p>Web Server Software is different from Web Server Program whose number is much greater.</p>\n<h2 id=\"Accepting-Client-Connections\"><a href=\"#Accepting-Client-Connections\" class=\"headerlink\" title=\"Accepting Client Connections\"></a>Accepting Client Connections</h2><p>Identification is main work in this proceduer:</p>\n<ul>\n<li>Use <code>reverse DNS</code> to find out the hostname for some particular IP but this feature is always disabled because of its monster waste of time.</li>\n<li><code>ident</code> protocool makes server send a request to the client who is always running identd Identification Protocol daemon software. However, this is not common in public internet because its dangerous and unsecurity.</li>\n</ul>\n<p>## </p>\n","excerpt":"","more":"<h2 id=\"Web-Server-Software\"><a href=\"#Web-Server-Software\" class=\"headerlink\" title=\"Web Server Software\"></a>Web Server Software</h2><p>Web Server Software is different from Web Server Program whose number is much greater.</p>\n<h2 id=\"Accepting-Client-Connections\"><a href=\"#Accepting-Client-Connections\" class=\"headerlink\" title=\"Accepting Client Connections\"></a>Accepting Client Connections</h2><p>Identification is main work in this proceduer:</p>\n<ul>\n<li>Use <code>reverse DNS</code> to find out the hostname for some particular IP but this feature is always disabled because of its monster waste of time.</li>\n<li><code>ident</code> protocool makes server send a request to the client who is always running identd Identification Protocol daemon software. However, this is not common in public internet because its dangerous and unsecurity.</li>\n</ul>\n<p>## </p>\n"},{"title":"logs","_content":"## 26/04\n1. 居中文字\n## \n1. 知道了 eslint 可以在 vscode 里面使用，与 pylint 的区别在于它是实时控制的\n2. ？看到了 状态机 的一种实现方式，但是实际上却是不好的，有时间可以写一个抽象的状态机，可以模仿 redux。","source":"_drafts/logs.md","raw":"---\ntitle: logs\ntags:\n---\n## 26/04\n1. 居中文字\n## \n1. 知道了 eslint 可以在 vscode 里面使用，与 pylint 的区别在于它是实时控制的\n2. ？看到了 状态机 的一种实现方式，但是实际上却是不好的，有时间可以写一个抽象的状态机，可以模仿 redux。","slug":"logs","published":0,"date":"2017-04-24T16:48:35.000Z","updated":"2017-05-20T17:18:43.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjbdyo30s0003nf8jb98e15bw","content":"<h2 id=\"26-04\"><a href=\"#26-04\" class=\"headerlink\" title=\"26/04\"></a>26/04</h2><ol>\n<li>居中文字<br>## </li>\n<li>知道了 eslint 可以在 vscode 里面使用，与 pylint 的区别在于它是实时控制的</li>\n<li>？看到了 状态机 的一种实现方式，但是实际上却是不好的，有时间可以写一个抽象的状态机，可以模仿 redux。</li>\n</ol>\n","excerpt":"","more":"<h2 id=\"26-04\"><a href=\"#26-04\" class=\"headerlink\" title=\"26/04\"></a>26/04</h2><ol>\n<li>居中文字<br>## </li>\n<li>知道了 eslint 可以在 vscode 里面使用，与 pylint 的区别在于它是实时控制的</li>\n<li>？看到了 状态机 的一种实现方式，但是实际上却是不好的，有时间可以写一个抽象的状态机，可以模仿 redux。</li>\n</ol>\n"},{"layout":"ideas","title":"ideas","date":"2017-03-12T04:42:08.000Z","_content":"## Accumulations\n1. React 对 props 的某个属性进行 {} 分解取值，若该属性为 undefined 的话，会报出 \"React component returning cannot read property '__reactInternalInstance$' of null\"。\n2. less+css modular 使用：如果直接使用 npm start 来编译得到的报错信息会有点奇观（不准确），理应使用 webpack 亲自打包\n3. 使用 bootstrap3 的 modal\n4. let i in array 中的 i 是字符串\n5. 使用 function(){} 定义匿名函数会导致无法识别 this，可以使用 arrow function 来代替\n6. sass 的 loader 和 less 的使用有区别\n7. react 中的 input 标签 value 不要用 要用 defaultValue\n8. this.props read only\n9. 无法使用普通结点来进行 getElementById\n10. vs code 的 jsconfig.json 中最后一个属性不要带逗号\n11. jsconfig.json 和 eslint 的简单用法\n12. 我遇到这样的一个问题，就是当使用 redux 的 connect 函数时，webpack 在打包的时候发现 setState 这个函数并没有被加入，最终我只是发现了这一原因，但是没有发现为什么会这样，只知道最终只是通过重新 `npm install react redux react-redux --save` 来解决了问题。\n13. jquery 似乎会对结点元素进行某种处理，我在使用 jquery 操纵 x3dom 标签的时候发现并不能如期运行。\n14. ES6 的语法过了一遍，但是还需要一个星期的时间来重新巩固一下\n15. css 的模块化使用方法 less 的基本使用\n16. webpack-server 结合 express 来得到一个实时保存更新的 server\n17. eslint 的简单使用\n18. vscode 的 jsconfig.json 的简单使用\n19. redux 的 middleware，用来处理异步流\n20. 笃行慎言\n\n## Questions\n1. 最顶层的元素设置 margin-top 不会影响父容器的高度？\n2. 在 script 标签中，放入 static/xxx.js 和 /static/xxx.js 的区别？\n3. dispatch 多个 action？\n4. react 中组件有些状态与 view 无关，如何处理这样的状态？\n5. react 组件构造时机以及过载出错的影响？\n6. 在 ajax 请求中 setState 会立即更新组件但是若是此刻出错，那么就会无法得到出错信息！\n7. 优雅地用数组给对象赋值\n8. 正则匹配 匹配策略\n\n# 02/26~03/03\n## Accumulations\n1. node 对象的 onclick 方法设置，两种，直接用 node.onclick 设置可以带参数，需要注意的是如果想要带参数，需要使用匿名函数\n2. onclick 可以接收参数，该参数是触发的 node\n3. V8 javascript engine 三个优势：hidden class, dynamic cached object's member, effient garbage collector\n4. 动态加载 js 文件执行并放入 callback\n5. onmousedown -> onmousemove -> onmouseup -> onclick onwheelmove (x3dom 可以优化的地方)\n\n## Questions\n### 1. 闭包的好处（函数名减少）\n### 2. html 的 DOM 详解\n### 3. html 的 事件触发流程\n### 4. script 位置对执行的影响，以及执行的流程\n### 5. git merge 时发生了什么?\n发生 conflict 的情况有两种：一种是不同 branch 之间的 merge 时发生，还有一种是同一 branch 上由于同步开发，出现相同父节点上出现了两次不同的 commit（实际上只有本人和远程的差异，再具体点说就是合作者与自己拥有同一个父节点，并且在我提交下一个 commit 之前已经提交了一个 commit，这时候我发现无论我 pull 还是 push 都会出现 conflicts ）。\n对于这种情况，首先我想强调的是，不必紧张，git 是会保存所有的东西的，你们所有的更改都会保存下来。\n\n```\nA -----> B1(sb else's commit) ---> C\n|                                  | \n\\                                  /\n ------> B2(your commit)----------\n```\n\n首先，你得了解你的 repo 处在什么状态——实际上是处于一个 merge 状态，这种状态你需要处理所有 unmerged file。\n然后，你有两个选择，手动消除 unmerged 的地方，然后使用 `git add <file>` 来表示 merge 完毕，之后就可以提交新的 commit（需要注意的是这时的 commit 是一个 merge 类型的结点，它有两个父节点，这点下面会因此而出现意外情况）。在提交新的 commit 之前，你还可以使用 `git merge --abort` 来取消这次 merge。\n\n但是如果出现这样的情况，merge 完毕后发现自己的 merge 做的有问题，不必担心，由上面的图可以知道，之前的冲突结点都保存着，那么该如何恢复呢？\n很简单，通过 revert 恢复是最安全的方式（注意，revert 和 reset 不一样，reset 是恢复到参数指定的 commit 的状态，而 revert 是回滚指定 commit 的状态到上一次 commit）\n但是如果你使用 `git revert <B2's SHA>` 会出 conflicts，这是因为你理解错了 revert 的含义（通过 git revert --abort 可以回滚）,而出现 conflicts 的原因是一般 revert 只会用作 `revert HEAD`，因此 git 知道回滚到当前 commit 的上一次 commit的方法，没有其他选择，若是回滚到指定版本的话，git 并不知道如何跨 commit 回滚，因此必须要人来手动 merge 一下。\n在这里的情况我们得使用 `git revert HEAD`，但是即使如此，仍然不对，而且是出错，这是因为，回滚 C 的时候，发现 C 有两个父节点，因此必须指定回滚到哪一个结点才行，那么如何知道相应父节点的编号呢？通过 `git log` 即可查看父节点的顺序，有了顺序使用 `git revert HEAD -m <number>` 来回滚到指定的父节点（注意编号从 1 开始）。\n\n# 03-05~03-11\n## Accumulations\n1. 看了 es5 的[博客](http://dmitrysoshnikov.com/ecmascript/chapter-7-2-oop-ecmascript-implementation/)，需要写一篇总结性的博客。\n2. webpack file-loader 的使用在于可以打包文件到指定位置，此外利用好 webpack 的 publicPath 可以指定生成的文件（所有的文件，因此如果 file-loader 加入的目录，那么这个目录也会出现在 publicPath 下面）的位置，下面是一个简单的例子：\n    ```javscript\n    module.exports = {\n        module: {\n        loaders: [\n                { test: /\\.(png|jpe?g|gif|svg|woff|woff2|ttf|eot|ico)\\??/,\n                    loader: 'file?name=static/[name].[hash].[ext]'},\n\n            ]\n        },\n    }\n    ```\n3. 写了两次 dropdown 的样式，总结一下思路：\n\n    a. 基本结构是\n\n    ```html\n    <div class='dropdown'>\n        <div class='dropdown-title'/>\n        <ul class='dropdown-menu'>\n            <li>...</li>\n            ...\n        </ul>\n    </div>\n    ```\n    b. 唯一需要注意的是，可以通过 `background: url(...) no-repeat` 再加上相应的绝对定位来实现各种相应功能，此外用 js 动态改 style 可以使用 node.style.BackgroundImage = 'url(...)';\n4. 学习了 display: flex 的布局方式，这种布局特别方便同一个 div 下的多个同级元素排列，推荐学习地址 [froggy flex](http://flexboxfroggy.com/)\n5. 了解了 progressive web app 这个概念\n6. React 的 setState 的工作原理是通过 merge 来达到新的状态的\n7. 充分理解了 view 和 state 分离的好处\n    \n    所谓分离 view 和 state 的基本思想我个人感觉来自于 MVC，state 实际上意味着 Model，view 也就是 View，然后分离了 view 和 state，自然需要有单独的控制模块，也就是 Control，在 React 的设计模式中，view 负责根据 state（包括 props）来 render 出对应的 view instance，而 state 的设计属于 Model，而如何响应相应的事件来触发 state 的变化是需要自己来设计的（其实将 state 转换成 view 也是 control 的一部分，这部分 react 帮我们做好了），而这部分便是 control 的部分。\n\n    react 做好了分离，但是比起 redux 这类状态管理器来说，缺少了**全局状态**这个概念，所谓全局状态实际上就是为了 web app 各个组件之间的交互而需要的，除此之外 redux 还将 control 部分抽离出来，让开发者集中管理。\n8. react 的 diff 算法：基于了这样一个假设若是某个结点的类型不一致，那么以此为根的树基本上和之前不一致，此外通过强制让开发者提供同一级别的相同类型结点提供 local 的 key，来达到不必多次比较以发现前后乱序但一致的结点的效果\n\n## Questions\n### 1. 代理模式是什么？\n### 2. js call 的用法？\n### 3. js 如何在大型项目中，如何处理交流接口的难题？\n尝试使用 typescript\n### 4. react 多次 rendering？\n### 5. react virtual dom 结点对 onclick 的影响？\n### 6. react 属性 key 能否使用？\n### 7. 如何高效地使用 css？\n### 10. html css 的绘制流程？\n\n## Plan\n### 1: 看阮一峰的 es6 博客\n### 2：学习 [virtual dom](https://github.com/Matt-Esch/virtual-dom)\n### 3: bootstrap 的使用\n### 4: less 的使用\n### 5: eslint","source":"_drafts/ideas.md","raw":"layout: ideas\ntitle: ideas\ntags: Log\ndate: 2017-03-12 12:42:08\n---\n## Accumulations\n1. React 对 props 的某个属性进行 {} 分解取值，若该属性为 undefined 的话，会报出 \"React component returning cannot read property '__reactInternalInstance$' of null\"。\n2. less+css modular 使用：如果直接使用 npm start 来编译得到的报错信息会有点奇观（不准确），理应使用 webpack 亲自打包\n3. 使用 bootstrap3 的 modal\n4. let i in array 中的 i 是字符串\n5. 使用 function(){} 定义匿名函数会导致无法识别 this，可以使用 arrow function 来代替\n6. sass 的 loader 和 less 的使用有区别\n7. react 中的 input 标签 value 不要用 要用 defaultValue\n8. this.props read only\n9. 无法使用普通结点来进行 getElementById\n10. vs code 的 jsconfig.json 中最后一个属性不要带逗号\n11. jsconfig.json 和 eslint 的简单用法\n12. 我遇到这样的一个问题，就是当使用 redux 的 connect 函数时，webpack 在打包的时候发现 setState 这个函数并没有被加入，最终我只是发现了这一原因，但是没有发现为什么会这样，只知道最终只是通过重新 `npm install react redux react-redux --save` 来解决了问题。\n13. jquery 似乎会对结点元素进行某种处理，我在使用 jquery 操纵 x3dom 标签的时候发现并不能如期运行。\n14. ES6 的语法过了一遍，但是还需要一个星期的时间来重新巩固一下\n15. css 的模块化使用方法 less 的基本使用\n16. webpack-server 结合 express 来得到一个实时保存更新的 server\n17. eslint 的简单使用\n18. vscode 的 jsconfig.json 的简单使用\n19. redux 的 middleware，用来处理异步流\n20. 笃行慎言\n\n## Questions\n1. 最顶层的元素设置 margin-top 不会影响父容器的高度？\n2. 在 script 标签中，放入 static/xxx.js 和 /static/xxx.js 的区别？\n3. dispatch 多个 action？\n4. react 中组件有些状态与 view 无关，如何处理这样的状态？\n5. react 组件构造时机以及过载出错的影响？\n6. 在 ajax 请求中 setState 会立即更新组件但是若是此刻出错，那么就会无法得到出错信息！\n7. 优雅地用数组给对象赋值\n8. 正则匹配 匹配策略\n\n# 02/26~03/03\n## Accumulations\n1. node 对象的 onclick 方法设置，两种，直接用 node.onclick 设置可以带参数，需要注意的是如果想要带参数，需要使用匿名函数\n2. onclick 可以接收参数，该参数是触发的 node\n3. V8 javascript engine 三个优势：hidden class, dynamic cached object's member, effient garbage collector\n4. 动态加载 js 文件执行并放入 callback\n5. onmousedown -> onmousemove -> onmouseup -> onclick onwheelmove (x3dom 可以优化的地方)\n\n## Questions\n### 1. 闭包的好处（函数名减少）\n### 2. html 的 DOM 详解\n### 3. html 的 事件触发流程\n### 4. script 位置对执行的影响，以及执行的流程\n### 5. git merge 时发生了什么?\n发生 conflict 的情况有两种：一种是不同 branch 之间的 merge 时发生，还有一种是同一 branch 上由于同步开发，出现相同父节点上出现了两次不同的 commit（实际上只有本人和远程的差异，再具体点说就是合作者与自己拥有同一个父节点，并且在我提交下一个 commit 之前已经提交了一个 commit，这时候我发现无论我 pull 还是 push 都会出现 conflicts ）。\n对于这种情况，首先我想强调的是，不必紧张，git 是会保存所有的东西的，你们所有的更改都会保存下来。\n\n```\nA -----> B1(sb else's commit) ---> C\n|                                  | \n\\                                  /\n ------> B2(your commit)----------\n```\n\n首先，你得了解你的 repo 处在什么状态——实际上是处于一个 merge 状态，这种状态你需要处理所有 unmerged file。\n然后，你有两个选择，手动消除 unmerged 的地方，然后使用 `git add <file>` 来表示 merge 完毕，之后就可以提交新的 commit（需要注意的是这时的 commit 是一个 merge 类型的结点，它有两个父节点，这点下面会因此而出现意外情况）。在提交新的 commit 之前，你还可以使用 `git merge --abort` 来取消这次 merge。\n\n但是如果出现这样的情况，merge 完毕后发现自己的 merge 做的有问题，不必担心，由上面的图可以知道，之前的冲突结点都保存着，那么该如何恢复呢？\n很简单，通过 revert 恢复是最安全的方式（注意，revert 和 reset 不一样，reset 是恢复到参数指定的 commit 的状态，而 revert 是回滚指定 commit 的状态到上一次 commit）\n但是如果你使用 `git revert <B2's SHA>` 会出 conflicts，这是因为你理解错了 revert 的含义（通过 git revert --abort 可以回滚）,而出现 conflicts 的原因是一般 revert 只会用作 `revert HEAD`，因此 git 知道回滚到当前 commit 的上一次 commit的方法，没有其他选择，若是回滚到指定版本的话，git 并不知道如何跨 commit 回滚，因此必须要人来手动 merge 一下。\n在这里的情况我们得使用 `git revert HEAD`，但是即使如此，仍然不对，而且是出错，这是因为，回滚 C 的时候，发现 C 有两个父节点，因此必须指定回滚到哪一个结点才行，那么如何知道相应父节点的编号呢？通过 `git log` 即可查看父节点的顺序，有了顺序使用 `git revert HEAD -m <number>` 来回滚到指定的父节点（注意编号从 1 开始）。\n\n# 03-05~03-11\n## Accumulations\n1. 看了 es5 的[博客](http://dmitrysoshnikov.com/ecmascript/chapter-7-2-oop-ecmascript-implementation/)，需要写一篇总结性的博客。\n2. webpack file-loader 的使用在于可以打包文件到指定位置，此外利用好 webpack 的 publicPath 可以指定生成的文件（所有的文件，因此如果 file-loader 加入的目录，那么这个目录也会出现在 publicPath 下面）的位置，下面是一个简单的例子：\n    ```javscript\n    module.exports = {\n        module: {\n        loaders: [\n                { test: /\\.(png|jpe?g|gif|svg|woff|woff2|ttf|eot|ico)\\??/,\n                    loader: 'file?name=static/[name].[hash].[ext]'},\n\n            ]\n        },\n    }\n    ```\n3. 写了两次 dropdown 的样式，总结一下思路：\n\n    a. 基本结构是\n\n    ```html\n    <div class='dropdown'>\n        <div class='dropdown-title'/>\n        <ul class='dropdown-menu'>\n            <li>...</li>\n            ...\n        </ul>\n    </div>\n    ```\n    b. 唯一需要注意的是，可以通过 `background: url(...) no-repeat` 再加上相应的绝对定位来实现各种相应功能，此外用 js 动态改 style 可以使用 node.style.BackgroundImage = 'url(...)';\n4. 学习了 display: flex 的布局方式，这种布局特别方便同一个 div 下的多个同级元素排列，推荐学习地址 [froggy flex](http://flexboxfroggy.com/)\n5. 了解了 progressive web app 这个概念\n6. React 的 setState 的工作原理是通过 merge 来达到新的状态的\n7. 充分理解了 view 和 state 分离的好处\n    \n    所谓分离 view 和 state 的基本思想我个人感觉来自于 MVC，state 实际上意味着 Model，view 也就是 View，然后分离了 view 和 state，自然需要有单独的控制模块，也就是 Control，在 React 的设计模式中，view 负责根据 state（包括 props）来 render 出对应的 view instance，而 state 的设计属于 Model，而如何响应相应的事件来触发 state 的变化是需要自己来设计的（其实将 state 转换成 view 也是 control 的一部分，这部分 react 帮我们做好了），而这部分便是 control 的部分。\n\n    react 做好了分离，但是比起 redux 这类状态管理器来说，缺少了**全局状态**这个概念，所谓全局状态实际上就是为了 web app 各个组件之间的交互而需要的，除此之外 redux 还将 control 部分抽离出来，让开发者集中管理。\n8. react 的 diff 算法：基于了这样一个假设若是某个结点的类型不一致，那么以此为根的树基本上和之前不一致，此外通过强制让开发者提供同一级别的相同类型结点提供 local 的 key，来达到不必多次比较以发现前后乱序但一致的结点的效果\n\n## Questions\n### 1. 代理模式是什么？\n### 2. js call 的用法？\n### 3. js 如何在大型项目中，如何处理交流接口的难题？\n尝试使用 typescript\n### 4. react 多次 rendering？\n### 5. react virtual dom 结点对 onclick 的影响？\n### 6. react 属性 key 能否使用？\n### 7. 如何高效地使用 css？\n### 10. html css 的绘制流程？\n\n## Plan\n### 1: 看阮一峰的 es6 博客\n### 2：学习 [virtual dom](https://github.com/Matt-Esch/virtual-dom)\n### 3: bootstrap 的使用\n### 4: less 的使用\n### 5: eslint","slug":"ideas","published":0,"updated":"2017-04-24T16:47:26.000Z","comments":1,"photos":[],"link":"","_id":"cjbdyo30u0004nf8j5zcii1q6","content":"<h2 id=\"Accumulations\"><a href=\"#Accumulations\" class=\"headerlink\" title=\"Accumulations\"></a>Accumulations</h2><ol>\n<li>React 对 props 的某个属性进行 {} 分解取值，若该属性为 undefined 的话，会报出 “React component returning cannot read property ‘__reactInternalInstance$’ of null”。</li>\n<li>less+css modular 使用：如果直接使用 npm start 来编译得到的报错信息会有点奇观（不准确），理应使用 webpack 亲自打包</li>\n<li>使用 bootstrap3 的 modal</li>\n<li>let i in array 中的 i 是字符串</li>\n<li>使用 function(){} 定义匿名函数会导致无法识别 this，可以使用 arrow function 来代替</li>\n<li>sass 的 loader 和 less 的使用有区别</li>\n<li>react 中的 input 标签 value 不要用 要用 defaultValue</li>\n<li>this.props read only</li>\n<li>无法使用普通结点来进行 getElementById</li>\n<li>vs code 的 jsconfig.json 中最后一个属性不要带逗号</li>\n<li>jsconfig.json 和 eslint 的简单用法</li>\n<li>我遇到这样的一个问题，就是当使用 redux 的 connect 函数时，webpack 在打包的时候发现 setState 这个函数并没有被加入，最终我只是发现了这一原因，但是没有发现为什么会这样，只知道最终只是通过重新 <code>npm install react redux react-redux --save</code> 来解决了问题。</li>\n<li>jquery 似乎会对结点元素进行某种处理，我在使用 jquery 操纵 x3dom 标签的时候发现并不能如期运行。</li>\n<li>ES6 的语法过了一遍，但是还需要一个星期的时间来重新巩固一下</li>\n<li>css 的模块化使用方法 less 的基本使用</li>\n<li>webpack-server 结合 express 来得到一个实时保存更新的 server</li>\n<li>eslint 的简单使用</li>\n<li>vscode 的 jsconfig.json 的简单使用</li>\n<li>redux 的 middleware，用来处理异步流</li>\n<li>笃行慎言</li>\n</ol>\n<h2 id=\"Questions\"><a href=\"#Questions\" class=\"headerlink\" title=\"Questions\"></a>Questions</h2><ol>\n<li>最顶层的元素设置 margin-top 不会影响父容器的高度？</li>\n<li>在 script 标签中，放入 static/xxx.js 和 /static/xxx.js 的区别？</li>\n<li>dispatch 多个 action？</li>\n<li>react 中组件有些状态与 view 无关，如何处理这样的状态？</li>\n<li>react 组件构造时机以及过载出错的影响？</li>\n<li>在 ajax 请求中 setState 会立即更新组件但是若是此刻出错，那么就会无法得到出错信息！</li>\n<li>优雅地用数组给对象赋值</li>\n<li>正则匹配 匹配策略</li>\n</ol>\n<h1 id=\"02-26-03-03\"><a href=\"#02-26-03-03\" class=\"headerlink\" title=\"02/26~03/03\"></a>02/26~03/03</h1><h2 id=\"Accumulations-1\"><a href=\"#Accumulations-1\" class=\"headerlink\" title=\"Accumulations\"></a>Accumulations</h2><ol>\n<li>node 对象的 onclick 方法设置，两种，直接用 node.onclick 设置可以带参数，需要注意的是如果想要带参数，需要使用匿名函数</li>\n<li>onclick 可以接收参数，该参数是触发的 node</li>\n<li>V8 javascript engine 三个优势：hidden class, dynamic cached object’s member, effient garbage collector</li>\n<li>动态加载 js 文件执行并放入 callback</li>\n<li>onmousedown -&gt; onmousemove -&gt; onmouseup -&gt; onclick onwheelmove (x3dom 可以优化的地方)</li>\n</ol>\n<h2 id=\"Questions-1\"><a href=\"#Questions-1\" class=\"headerlink\" title=\"Questions\"></a>Questions</h2><h3 id=\"1-闭包的好处（函数名减少）\"><a href=\"#1-闭包的好处（函数名减少）\" class=\"headerlink\" title=\"1. 闭包的好处（函数名减少）\"></a>1. 闭包的好处（函数名减少）</h3><h3 id=\"2-html-的-DOM-详解\"><a href=\"#2-html-的-DOM-详解\" class=\"headerlink\" title=\"2. html 的 DOM 详解\"></a>2. html 的 DOM 详解</h3><h3 id=\"3-html-的-事件触发流程\"><a href=\"#3-html-的-事件触发流程\" class=\"headerlink\" title=\"3. html 的 事件触发流程\"></a>3. html 的 事件触发流程</h3><h3 id=\"4-script-位置对执行的影响，以及执行的流程\"><a href=\"#4-script-位置对执行的影响，以及执行的流程\" class=\"headerlink\" title=\"4. script 位置对执行的影响，以及执行的流程\"></a>4. script 位置对执行的影响，以及执行的流程</h3><h3 id=\"5-git-merge-时发生了什么\"><a href=\"#5-git-merge-时发生了什么\" class=\"headerlink\" title=\"5. git merge 时发生了什么?\"></a>5. git merge 时发生了什么?</h3><p>发生 conflict 的情况有两种：一种是不同 branch 之间的 merge 时发生，还有一种是同一 branch 上由于同步开发，出现相同父节点上出现了两次不同的 commit（实际上只有本人和远程的差异，再具体点说就是合作者与自己拥有同一个父节点，并且在我提交下一个 commit 之前已经提交了一个 commit，这时候我发现无论我 pull 还是 push 都会出现 conflicts ）。<br>对于这种情况，首先我想强调的是，不必紧张，git 是会保存所有的东西的，你们所有的更改都会保存下来。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">A -----&gt; B1(sb else&apos;s commit) ---&gt; C</div><div class=\"line\">|                                  | </div><div class=\"line\">\\                                  /</div><div class=\"line\"> ------&gt; B2(your commit)----------</div></pre></td></tr></table></figure>\n<p>首先，你得了解你的 repo 处在什么状态——实际上是处于一个 merge 状态，这种状态你需要处理所有 unmerged file。<br>然后，你有两个选择，手动消除 unmerged 的地方，然后使用 <code>git add &lt;file&gt;</code> 来表示 merge 完毕，之后就可以提交新的 commit（需要注意的是这时的 commit 是一个 merge 类型的结点，它有两个父节点，这点下面会因此而出现意外情况）。在提交新的 commit 之前，你还可以使用 <code>git merge --abort</code> 来取消这次 merge。</p>\n<p>但是如果出现这样的情况，merge 完毕后发现自己的 merge 做的有问题，不必担心，由上面的图可以知道，之前的冲突结点都保存着，那么该如何恢复呢？<br>很简单，通过 revert 恢复是最安全的方式（注意，revert 和 reset 不一样，reset 是恢复到参数指定的 commit 的状态，而 revert 是回滚指定 commit 的状态到上一次 commit）<br>但是如果你使用 <code>git revert &lt;B2&#39;s SHA&gt;</code> 会出 conflicts，这是因为你理解错了 revert 的含义（通过 git revert –abort 可以回滚）,而出现 conflicts 的原因是一般 revert 只会用作 <code>revert HEAD</code>，因此 git 知道回滚到当前 commit 的上一次 commit的方法，没有其他选择，若是回滚到指定版本的话，git 并不知道如何跨 commit 回滚，因此必须要人来手动 merge 一下。<br>在这里的情况我们得使用 <code>git revert HEAD</code>，但是即使如此，仍然不对，而且是出错，这是因为，回滚 C 的时候，发现 C 有两个父节点，因此必须指定回滚到哪一个结点才行，那么如何知道相应父节点的编号呢？通过 <code>git log</code> 即可查看父节点的顺序，有了顺序使用 <code>git revert HEAD -m &lt;number&gt;</code> 来回滚到指定的父节点（注意编号从 1 开始）。</p>\n<h1 id=\"03-05-03-11\"><a href=\"#03-05-03-11\" class=\"headerlink\" title=\"03-05~03-11\"></a>03-05~03-11</h1><h2 id=\"Accumulations-2\"><a href=\"#Accumulations-2\" class=\"headerlink\" title=\"Accumulations\"></a>Accumulations</h2><ol>\n<li>看了 es5 的<a href=\"http://dmitrysoshnikov.com/ecmascript/chapter-7-2-oop-ecmascript-implementation/\" target=\"_blank\" rel=\"external\">博客</a>，需要写一篇总结性的博客。</li>\n<li><p>webpack file-loader 的使用在于可以打包文件到指定位置，此外利用好 webpack 的 publicPath 可以指定生成的文件（所有的文件，因此如果 file-loader 加入的目录，那么这个目录也会出现在 publicPath 下面）的位置，下面是一个简单的例子：</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">module.exports = &#123;</div><div class=\"line\">    module: &#123;</div><div class=\"line\">    loaders: [</div><div class=\"line\">            &#123; test: /\\.(png|jpe?g|gif|svg|woff|woff2|ttf|eot|ico)\\??/,</div><div class=\"line\">                loader: &apos;file?name=static/[name].[hash].[ext]&apos;&#125;,</div><div class=\"line\"></div><div class=\"line\">        ]</div><div class=\"line\">    &#125;,</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n<li><p>写了两次 dropdown 的样式，总结一下思路：</p>\n<p> a. 基本结构是</p>\n <figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">'dropdown'</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">'dropdown-title'</span>/&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">ul</span> <span class=\"attr\">class</span>=<span class=\"string\">'dropdown-menu'</span>&gt;</span></div><div class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">li</span>&gt;</span>...<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></div><div class=\"line\">        ...</div><div class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">ul</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div></pre></td></tr></table></figure>\n<p> b. 唯一需要注意的是，可以通过 <code>background: url(...) no-repeat</code> 再加上相应的绝对定位来实现各种相应功能，此外用 js 动态改 style 可以使用 node.style.BackgroundImage = ‘url(…)’;</p>\n</li>\n<li>学习了 display: flex 的布局方式，这种布局特别方便同一个 div 下的多个同级元素排列，推荐学习地址 <a href=\"http://flexboxfroggy.com/\" target=\"_blank\" rel=\"external\">froggy flex</a></li>\n<li>了解了 progressive web app 这个概念</li>\n<li>React 的 setState 的工作原理是通过 merge 来达到新的状态的</li>\n<li><p>充分理解了 view 和 state 分离的好处</p>\n<p> 所谓分离 view 和 state 的基本思想我个人感觉来自于 MVC，state 实际上意味着 Model，view 也就是 View，然后分离了 view 和 state，自然需要有单独的控制模块，也就是 Control，在 React 的设计模式中，view 负责根据 state（包括 props）来 render 出对应的 view instance，而 state 的设计属于 Model，而如何响应相应的事件来触发 state 的变化是需要自己来设计的（其实将 state 转换成 view 也是 control 的一部分，这部分 react 帮我们做好了），而这部分便是 control 的部分。</p>\n<p> react 做好了分离，但是比起 redux 这类状态管理器来说，缺少了<strong>全局状态</strong>这个概念，所谓全局状态实际上就是为了 web app 各个组件之间的交互而需要的，除此之外 redux 还将 control 部分抽离出来，让开发者集中管理。</p>\n</li>\n<li>react 的 diff 算法：基于了这样一个假设若是某个结点的类型不一致，那么以此为根的树基本上和之前不一致，此外通过强制让开发者提供同一级别的相同类型结点提供 local 的 key，来达到不必多次比较以发现前后乱序但一致的结点的效果</li>\n</ol>\n<h2 id=\"Questions-2\"><a href=\"#Questions-2\" class=\"headerlink\" title=\"Questions\"></a>Questions</h2><h3 id=\"1-代理模式是什么？\"><a href=\"#1-代理模式是什么？\" class=\"headerlink\" title=\"1. 代理模式是什么？\"></a>1. 代理模式是什么？</h3><h3 id=\"2-js-call-的用法？\"><a href=\"#2-js-call-的用法？\" class=\"headerlink\" title=\"2. js call 的用法？\"></a>2. js call 的用法？</h3><h3 id=\"3-js-如何在大型项目中，如何处理交流接口的难题？\"><a href=\"#3-js-如何在大型项目中，如何处理交流接口的难题？\" class=\"headerlink\" title=\"3. js 如何在大型项目中，如何处理交流接口的难题？\"></a>3. js 如何在大型项目中，如何处理交流接口的难题？</h3><p>尝试使用 typescript</p>\n<h3 id=\"4-react-多次-rendering？\"><a href=\"#4-react-多次-rendering？\" class=\"headerlink\" title=\"4. react 多次 rendering？\"></a>4. react 多次 rendering？</h3><h3 id=\"5-react-virtual-dom-结点对-onclick-的影响？\"><a href=\"#5-react-virtual-dom-结点对-onclick-的影响？\" class=\"headerlink\" title=\"5. react virtual dom 结点对 onclick 的影响？\"></a>5. react virtual dom 结点对 onclick 的影响？</h3><h3 id=\"6-react-属性-key-能否使用？\"><a href=\"#6-react-属性-key-能否使用？\" class=\"headerlink\" title=\"6. react 属性 key 能否使用？\"></a>6. react 属性 key 能否使用？</h3><h3 id=\"7-如何高效地使用-css？\"><a href=\"#7-如何高效地使用-css？\" class=\"headerlink\" title=\"7. 如何高效地使用 css？\"></a>7. 如何高效地使用 css？</h3><h3 id=\"10-html-css-的绘制流程？\"><a href=\"#10-html-css-的绘制流程？\" class=\"headerlink\" title=\"10. html css 的绘制流程？\"></a>10. html css 的绘制流程？</h3><h2 id=\"Plan\"><a href=\"#Plan\" class=\"headerlink\" title=\"Plan\"></a>Plan</h2><h3 id=\"1-看阮一峰的-es6-博客\"><a href=\"#1-看阮一峰的-es6-博客\" class=\"headerlink\" title=\"1: 看阮一峰的 es6 博客\"></a>1: 看阮一峰的 es6 博客</h3><h3 id=\"2：学习-virtual-dom\"><a href=\"#2：学习-virtual-dom\" class=\"headerlink\" title=\"2：学习 virtual dom\"></a>2：学习 <a href=\"https://github.com/Matt-Esch/virtual-dom\" target=\"_blank\" rel=\"external\">virtual dom</a></h3><h3 id=\"3-bootstrap-的使用\"><a href=\"#3-bootstrap-的使用\" class=\"headerlink\" title=\"3: bootstrap 的使用\"></a>3: bootstrap 的使用</h3><h3 id=\"4-less-的使用\"><a href=\"#4-less-的使用\" class=\"headerlink\" title=\"4: less 的使用\"></a>4: less 的使用</h3><h3 id=\"5-eslint\"><a href=\"#5-eslint\" class=\"headerlink\" title=\"5: eslint\"></a>5: eslint</h3>","excerpt":"","more":"<h2 id=\"Accumulations\"><a href=\"#Accumulations\" class=\"headerlink\" title=\"Accumulations\"></a>Accumulations</h2><ol>\n<li>React 对 props 的某个属性进行 {} 分解取值，若该属性为 undefined 的话，会报出 “React component returning cannot read property ‘__reactInternalInstance$’ of null”。</li>\n<li>less+css modular 使用：如果直接使用 npm start 来编译得到的报错信息会有点奇观（不准确），理应使用 webpack 亲自打包</li>\n<li>使用 bootstrap3 的 modal</li>\n<li>let i in array 中的 i 是字符串</li>\n<li>使用 function(){} 定义匿名函数会导致无法识别 this，可以使用 arrow function 来代替</li>\n<li>sass 的 loader 和 less 的使用有区别</li>\n<li>react 中的 input 标签 value 不要用 要用 defaultValue</li>\n<li>this.props read only</li>\n<li>无法使用普通结点来进行 getElementById</li>\n<li>vs code 的 jsconfig.json 中最后一个属性不要带逗号</li>\n<li>jsconfig.json 和 eslint 的简单用法</li>\n<li>我遇到这样的一个问题，就是当使用 redux 的 connect 函数时，webpack 在打包的时候发现 setState 这个函数并没有被加入，最终我只是发现了这一原因，但是没有发现为什么会这样，只知道最终只是通过重新 <code>npm install react redux react-redux --save</code> 来解决了问题。</li>\n<li>jquery 似乎会对结点元素进行某种处理，我在使用 jquery 操纵 x3dom 标签的时候发现并不能如期运行。</li>\n<li>ES6 的语法过了一遍，但是还需要一个星期的时间来重新巩固一下</li>\n<li>css 的模块化使用方法 less 的基本使用</li>\n<li>webpack-server 结合 express 来得到一个实时保存更新的 server</li>\n<li>eslint 的简单使用</li>\n<li>vscode 的 jsconfig.json 的简单使用</li>\n<li>redux 的 middleware，用来处理异步流</li>\n<li>笃行慎言</li>\n</ol>\n<h2 id=\"Questions\"><a href=\"#Questions\" class=\"headerlink\" title=\"Questions\"></a>Questions</h2><ol>\n<li>最顶层的元素设置 margin-top 不会影响父容器的高度？</li>\n<li>在 script 标签中，放入 static/xxx.js 和 /static/xxx.js 的区别？</li>\n<li>dispatch 多个 action？</li>\n<li>react 中组件有些状态与 view 无关，如何处理这样的状态？</li>\n<li>react 组件构造时机以及过载出错的影响？</li>\n<li>在 ajax 请求中 setState 会立即更新组件但是若是此刻出错，那么就会无法得到出错信息！</li>\n<li>优雅地用数组给对象赋值</li>\n<li>正则匹配 匹配策略</li>\n</ol>\n<h1 id=\"02-26-03-03\"><a href=\"#02-26-03-03\" class=\"headerlink\" title=\"02/26~03/03\"></a>02/26~03/03</h1><h2 id=\"Accumulations-1\"><a href=\"#Accumulations-1\" class=\"headerlink\" title=\"Accumulations\"></a>Accumulations</h2><ol>\n<li>node 对象的 onclick 方法设置，两种，直接用 node.onclick 设置可以带参数，需要注意的是如果想要带参数，需要使用匿名函数</li>\n<li>onclick 可以接收参数，该参数是触发的 node</li>\n<li>V8 javascript engine 三个优势：hidden class, dynamic cached object’s member, effient garbage collector</li>\n<li>动态加载 js 文件执行并放入 callback</li>\n<li>onmousedown -&gt; onmousemove -&gt; onmouseup -&gt; onclick onwheelmove (x3dom 可以优化的地方)</li>\n</ol>\n<h2 id=\"Questions-1\"><a href=\"#Questions-1\" class=\"headerlink\" title=\"Questions\"></a>Questions</h2><h3 id=\"1-闭包的好处（函数名减少）\"><a href=\"#1-闭包的好处（函数名减少）\" class=\"headerlink\" title=\"1. 闭包的好处（函数名减少）\"></a>1. 闭包的好处（函数名减少）</h3><h3 id=\"2-html-的-DOM-详解\"><a href=\"#2-html-的-DOM-详解\" class=\"headerlink\" title=\"2. html 的 DOM 详解\"></a>2. html 的 DOM 详解</h3><h3 id=\"3-html-的-事件触发流程\"><a href=\"#3-html-的-事件触发流程\" class=\"headerlink\" title=\"3. html 的 事件触发流程\"></a>3. html 的 事件触发流程</h3><h3 id=\"4-script-位置对执行的影响，以及执行的流程\"><a href=\"#4-script-位置对执行的影响，以及执行的流程\" class=\"headerlink\" title=\"4. script 位置对执行的影响，以及执行的流程\"></a>4. script 位置对执行的影响，以及执行的流程</h3><h3 id=\"5-git-merge-时发生了什么\"><a href=\"#5-git-merge-时发生了什么\" class=\"headerlink\" title=\"5. git merge 时发生了什么?\"></a>5. git merge 时发生了什么?</h3><p>发生 conflict 的情况有两种：一种是不同 branch 之间的 merge 时发生，还有一种是同一 branch 上由于同步开发，出现相同父节点上出现了两次不同的 commit（实际上只有本人和远程的差异，再具体点说就是合作者与自己拥有同一个父节点，并且在我提交下一个 commit 之前已经提交了一个 commit，这时候我发现无论我 pull 还是 push 都会出现 conflicts ）。<br>对于这种情况，首先我想强调的是，不必紧张，git 是会保存所有的东西的，你们所有的更改都会保存下来。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">A -----&gt; B1(sb else&apos;s commit) ---&gt; C</div><div class=\"line\">|                                  | </div><div class=\"line\">\\                                  /</div><div class=\"line\"> ------&gt; B2(your commit)----------</div></pre></td></tr></table></figure>\n<p>首先，你得了解你的 repo 处在什么状态——实际上是处于一个 merge 状态，这种状态你需要处理所有 unmerged file。<br>然后，你有两个选择，手动消除 unmerged 的地方，然后使用 <code>git add &lt;file&gt;</code> 来表示 merge 完毕，之后就可以提交新的 commit（需要注意的是这时的 commit 是一个 merge 类型的结点，它有两个父节点，这点下面会因此而出现意外情况）。在提交新的 commit 之前，你还可以使用 <code>git merge --abort</code> 来取消这次 merge。</p>\n<p>但是如果出现这样的情况，merge 完毕后发现自己的 merge 做的有问题，不必担心，由上面的图可以知道，之前的冲突结点都保存着，那么该如何恢复呢？<br>很简单，通过 revert 恢复是最安全的方式（注意，revert 和 reset 不一样，reset 是恢复到参数指定的 commit 的状态，而 revert 是回滚指定 commit 的状态到上一次 commit）<br>但是如果你使用 <code>git revert &lt;B2&#39;s SHA&gt;</code> 会出 conflicts，这是因为你理解错了 revert 的含义（通过 git revert –abort 可以回滚）,而出现 conflicts 的原因是一般 revert 只会用作 <code>revert HEAD</code>，因此 git 知道回滚到当前 commit 的上一次 commit的方法，没有其他选择，若是回滚到指定版本的话，git 并不知道如何跨 commit 回滚，因此必须要人来手动 merge 一下。<br>在这里的情况我们得使用 <code>git revert HEAD</code>，但是即使如此，仍然不对，而且是出错，这是因为，回滚 C 的时候，发现 C 有两个父节点，因此必须指定回滚到哪一个结点才行，那么如何知道相应父节点的编号呢？通过 <code>git log</code> 即可查看父节点的顺序，有了顺序使用 <code>git revert HEAD -m &lt;number&gt;</code> 来回滚到指定的父节点（注意编号从 1 开始）。</p>\n<h1 id=\"03-05-03-11\"><a href=\"#03-05-03-11\" class=\"headerlink\" title=\"03-05~03-11\"></a>03-05~03-11</h1><h2 id=\"Accumulations-2\"><a href=\"#Accumulations-2\" class=\"headerlink\" title=\"Accumulations\"></a>Accumulations</h2><ol>\n<li>看了 es5 的<a href=\"http://dmitrysoshnikov.com/ecmascript/chapter-7-2-oop-ecmascript-implementation/\">博客</a>，需要写一篇总结性的博客。</li>\n<li><p>webpack file-loader 的使用在于可以打包文件到指定位置，此外利用好 webpack 的 publicPath 可以指定生成的文件（所有的文件，因此如果 file-loader 加入的目录，那么这个目录也会出现在 publicPath 下面）的位置，下面是一个简单的例子：</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">module.exports = &#123;</div><div class=\"line\">    module: &#123;</div><div class=\"line\">    loaders: [</div><div class=\"line\">            &#123; test: /\\.(png|jpe?g|gif|svg|woff|woff2|ttf|eot|ico)\\??/,</div><div class=\"line\">                loader: &apos;file?name=static/[name].[hash].[ext]&apos;&#125;,</div><div class=\"line\"></div><div class=\"line\">        ]</div><div class=\"line\">    &#125;,</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n<li><p>写了两次 dropdown 的样式，总结一下思路：</p>\n<p> a. 基本结构是</p>\n <figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">'dropdown'</span>&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">'dropdown-title'</span>/&gt;</span></div><div class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">ul</span> <span class=\"attr\">class</span>=<span class=\"string\">'dropdown-menu'</span>&gt;</span></div><div class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">li</span>&gt;</span>...<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></div><div class=\"line\">        ...</div><div class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">ul</span>&gt;</span></div><div class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></div></pre></td></tr></table></figure>\n<p> b. 唯一需要注意的是，可以通过 <code>background: url(...) no-repeat</code> 再加上相应的绝对定位来实现各种相应功能，此外用 js 动态改 style 可以使用 node.style.BackgroundImage = ‘url(…)’;</p>\n</li>\n<li>学习了 display: flex 的布局方式，这种布局特别方便同一个 div 下的多个同级元素排列，推荐学习地址 <a href=\"http://flexboxfroggy.com/\">froggy flex</a></li>\n<li>了解了 progressive web app 这个概念</li>\n<li>React 的 setState 的工作原理是通过 merge 来达到新的状态的</li>\n<li><p>充分理解了 view 和 state 分离的好处</p>\n<p> 所谓分离 view 和 state 的基本思想我个人感觉来自于 MVC，state 实际上意味着 Model，view 也就是 View，然后分离了 view 和 state，自然需要有单独的控制模块，也就是 Control，在 React 的设计模式中，view 负责根据 state（包括 props）来 render 出对应的 view instance，而 state 的设计属于 Model，而如何响应相应的事件来触发 state 的变化是需要自己来设计的（其实将 state 转换成 view 也是 control 的一部分，这部分 react 帮我们做好了），而这部分便是 control 的部分。</p>\n<p> react 做好了分离，但是比起 redux 这类状态管理器来说，缺少了<strong>全局状态</strong>这个概念，所谓全局状态实际上就是为了 web app 各个组件之间的交互而需要的，除此之外 redux 还将 control 部分抽离出来，让开发者集中管理。</p>\n</li>\n<li>react 的 diff 算法：基于了这样一个假设若是某个结点的类型不一致，那么以此为根的树基本上和之前不一致，此外通过强制让开发者提供同一级别的相同类型结点提供 local 的 key，来达到不必多次比较以发现前后乱序但一致的结点的效果</li>\n</ol>\n<h2 id=\"Questions-2\"><a href=\"#Questions-2\" class=\"headerlink\" title=\"Questions\"></a>Questions</h2><h3 id=\"1-代理模式是什么？\"><a href=\"#1-代理模式是什么？\" class=\"headerlink\" title=\"1. 代理模式是什么？\"></a>1. 代理模式是什么？</h3><h3 id=\"2-js-call-的用法？\"><a href=\"#2-js-call-的用法？\" class=\"headerlink\" title=\"2. js call 的用法？\"></a>2. js call 的用法？</h3><h3 id=\"3-js-如何在大型项目中，如何处理交流接口的难题？\"><a href=\"#3-js-如何在大型项目中，如何处理交流接口的难题？\" class=\"headerlink\" title=\"3. js 如何在大型项目中，如何处理交流接口的难题？\"></a>3. js 如何在大型项目中，如何处理交流接口的难题？</h3><p>尝试使用 typescript</p>\n<h3 id=\"4-react-多次-rendering？\"><a href=\"#4-react-多次-rendering？\" class=\"headerlink\" title=\"4. react 多次 rendering？\"></a>4. react 多次 rendering？</h3><h3 id=\"5-react-virtual-dom-结点对-onclick-的影响？\"><a href=\"#5-react-virtual-dom-结点对-onclick-的影响？\" class=\"headerlink\" title=\"5. react virtual dom 结点对 onclick 的影响？\"></a>5. react virtual dom 结点对 onclick 的影响？</h3><h3 id=\"6-react-属性-key-能否使用？\"><a href=\"#6-react-属性-key-能否使用？\" class=\"headerlink\" title=\"6. react 属性 key 能否使用？\"></a>6. react 属性 key 能否使用？</h3><h3 id=\"7-如何高效地使用-css？\"><a href=\"#7-如何高效地使用-css？\" class=\"headerlink\" title=\"7. 如何高效地使用 css？\"></a>7. 如何高效地使用 css？</h3><h3 id=\"10-html-css-的绘制流程？\"><a href=\"#10-html-css-的绘制流程？\" class=\"headerlink\" title=\"10. html css 的绘制流程？\"></a>10. html css 的绘制流程？</h3><h2 id=\"Plan\"><a href=\"#Plan\" class=\"headerlink\" title=\"Plan\"></a>Plan</h2><h3 id=\"1-看阮一峰的-es6-博客\"><a href=\"#1-看阮一峰的-es6-博客\" class=\"headerlink\" title=\"1: 看阮一峰的 es6 博客\"></a>1: 看阮一峰的 es6 博客</h3><h3 id=\"2：学习-virtual-dom\"><a href=\"#2：学习-virtual-dom\" class=\"headerlink\" title=\"2：学习 virtual dom\"></a>2：学习 <a href=\"https://github.com/Matt-Esch/virtual-dom\">virtual dom</a></h3><h3 id=\"3-bootstrap-的使用\"><a href=\"#3-bootstrap-的使用\" class=\"headerlink\" title=\"3: bootstrap 的使用\"></a>3: bootstrap 的使用</h3><h3 id=\"4-less-的使用\"><a href=\"#4-less-的使用\" class=\"headerlink\" title=\"4: less 的使用\"></a>4: less 的使用</h3><h3 id=\"5-eslint\"><a href=\"#5-eslint\" class=\"headerlink\" title=\"5: eslint\"></a>5: eslint</h3>"},{"title":"webbackend","_content":"## ACC\n1. join query\njobs = db.session.query(Job).filter(Job.user_id == User.id).\\\n                        filter(company_id == User.company_id).\\\n                        order_by(Job.created_at.desc()\n2. requests\nsend a post request with json data, use this way:\nrequests.post(url, headers={'x-user': '2', 'x-corp': '0', 'content-type':'application/json', 'charset':'utf-8'}, json=input)\n\n3. Mysql 是有 Json 类型的\n4. difference between put and post and get\n5. datetime timestamp unix—timestamp 的区别\n6. json 解析返回数据 json.loads\n7. sqlalchemy: \n    >On CentOS:\n    >sudo yum install mysql-devel\n    >sudo pip install MySQL-Python\n8. python encode\n9. os.path.basename(\"\").startswith(\"\")\n## Question\n1. python 的子类需要显式调用父类的 构造方法 吗？\n2. python 的测试\n3. 究竟在哪里比较适合做异常、错误检查？\n4. python sys.path.append()","source":"_drafts/webbackend.md","raw":"---\ntitle: webbackend\ntags:\n---\n## ACC\n1. join query\njobs = db.session.query(Job).filter(Job.user_id == User.id).\\\n                        filter(company_id == User.company_id).\\\n                        order_by(Job.created_at.desc()\n2. requests\nsend a post request with json data, use this way:\nrequests.post(url, headers={'x-user': '2', 'x-corp': '0', 'content-type':'application/json', 'charset':'utf-8'}, json=input)\n\n3. Mysql 是有 Json 类型的\n4. difference between put and post and get\n5. datetime timestamp unix—timestamp 的区别\n6. json 解析返回数据 json.loads\n7. sqlalchemy: \n    >On CentOS:\n    >sudo yum install mysql-devel\n    >sudo pip install MySQL-Python\n8. python encode\n9. os.path.basename(\"\").startswith(\"\")\n## Question\n1. python 的子类需要显式调用父类的 构造方法 吗？\n2. python 的测试\n3. 究竟在哪里比较适合做异常、错误检查？\n4. python sys.path.append()","slug":"webbackend","published":0,"date":"2017-04-01T07:19:21.000Z","updated":"2017-04-18T12:19:30.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjbdyo30v0005nf8j6zwvr2oe","content":"<h2 id=\"ACC\"><a href=\"#ACC\" class=\"headerlink\" title=\"ACC\"></a>ACC</h2><ol>\n<li>join query<br>jobs = db.session.query(Job).filter(Job.user_id == User.id).\\<pre><code>filter(company_id == User.company_id).\\\norder_by(Job.created_at.desc()\n</code></pre></li>\n<li><p>requests<br>send a post request with json data, use this way:<br>requests.post(url, headers={‘x-user’: ‘2’, ‘x-corp’: ‘0’, ‘content-type’:’application/json’, ‘charset’:’utf-8’}, json=input)</p>\n</li>\n<li><p>Mysql 是有 Json 类型的</p>\n</li>\n<li>difference between put and post and get</li>\n<li>datetime timestamp unix—timestamp 的区别</li>\n<li>json 解析返回数据 json.loads</li>\n<li>sqlalchemy: <blockquote>\n<p>On CentOS:<br>sudo yum install mysql-devel<br>sudo pip install MySQL-Python</p>\n</blockquote>\n</li>\n<li>python encode</li>\n<li>os.path.basename(“”).startswith(“”)<h2 id=\"Question\"><a href=\"#Question\" class=\"headerlink\" title=\"Question\"></a>Question</h2></li>\n<li>python 的子类需要显式调用父类的 构造方法 吗？</li>\n<li>python 的测试</li>\n<li>究竟在哪里比较适合做异常、错误检查？</li>\n<li>python sys.path.append()</li>\n</ol>\n","excerpt":"","more":"<h2 id=\"ACC\"><a href=\"#ACC\" class=\"headerlink\" title=\"ACC\"></a>ACC</h2><ol>\n<li>join query<br>jobs = db.session.query(Job).filter(Job.user_id == User.id).\\<pre><code>filter(company_id == User.company_id).\\\norder_by(Job.created_at.desc()\n</code></pre></li>\n<li><p>requests<br>send a post request with json data, use this way:<br>requests.post(url, headers={‘x-user’: ‘2’, ‘x-corp’: ‘0’, ‘content-type’:’application/json’, ‘charset’:’utf-8’}, json=input)</p>\n</li>\n<li><p>Mysql 是有 Json 类型的</p>\n</li>\n<li>difference between put and post and get</li>\n<li>datetime timestamp unix—timestamp 的区别</li>\n<li>json 解析返回数据 json.loads</li>\n<li>sqlalchemy: <blockquote>\n<p>On CentOS:<br>sudo yum install mysql-devel<br>sudo pip install MySQL-Python</p>\n</blockquote>\n</li>\n<li>python encode</li>\n<li>os.path.basename(“”).startswith(“”)<h2 id=\"Question\"><a href=\"#Question\" class=\"headerlink\" title=\"Question\"></a>Question</h2></li>\n<li>python 的子类需要显式调用父类的 构造方法 吗？</li>\n<li>python 的测试</li>\n<li>究竟在哪里比较适合做异常、错误检查？</li>\n<li>python sys.path.append()</li>\n</ol>\n"},{"title":"webvr","_content":"## resources\n1. [firefox nightly](http://gsf-cf.softonic.com/b2c/0c3/4c1d311e0cdd301d55a6c6ac597fbcc14c/file?SD_used=0&channel=WEB&fdh=no&id_file=6649728&instance=softonic_en&type=PROGRAM&Expires=1490839525&Signature=Ggc0sQ~wKQcuxzGprxbj7hdhO-~-IG-FfxT6t3kesFLa75JjaGNzVvSrsH3zdZMS9D6rGnkSw07LoaNHyJ46fvT9pPHmq0S0DfUPvfiuEsi-B2fTrW5qKhevXxAEw9mcvXfvN2j0bJYx0BbYANRcvVOroV0YfPwq7ctm4KwSyQ4_&Key-Pair-Id=APKAJUA62FNWTI37JTGQ&filename=Firefox-Setup-28-0b1.exe)\n\n2. [webvr.info](https://webvr.info/)\n\n3. ","source":"_drafts/webvr.md","raw":"---\ntitle: webvr\ntags:\n---\n## resources\n1. [firefox nightly](http://gsf-cf.softonic.com/b2c/0c3/4c1d311e0cdd301d55a6c6ac597fbcc14c/file?SD_used=0&channel=WEB&fdh=no&id_file=6649728&instance=softonic_en&type=PROGRAM&Expires=1490839525&Signature=Ggc0sQ~wKQcuxzGprxbj7hdhO-~-IG-FfxT6t3kesFLa75JjaGNzVvSrsH3zdZMS9D6rGnkSw07LoaNHyJ46fvT9pPHmq0S0DfUPvfiuEsi-B2fTrW5qKhevXxAEw9mcvXfvN2j0bJYx0BbYANRcvVOroV0YfPwq7ctm4KwSyQ4_&Key-Pair-Id=APKAJUA62FNWTI37JTGQ&filename=Firefox-Setup-28-0b1.exe)\n\n2. [webvr.info](https://webvr.info/)\n\n3. ","slug":"webvr","published":0,"date":"2017-03-29T15:34:48.000Z","updated":"2017-03-31T13:55:54.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjbdyo30z0008nf8jiyz0q9eq","content":"<h2 id=\"resources\"><a href=\"#resources\" class=\"headerlink\" title=\"resources\"></a>resources</h2><ol>\n<li><p><a href=\"http://gsf-cf.softonic.com/b2c/0c3/4c1d311e0cdd301d55a6c6ac597fbcc14c/file?SD_used=0&amp;channel=WEB&amp;fdh=no&amp;id_file=6649728&amp;instance=softonic_en&amp;type=PROGRAM&amp;Expires=1490839525&amp;Signature=Ggc0sQ~wKQcuxzGprxbj7hdhO-~-IG-FfxT6t3kesFLa75JjaGNzVvSrsH3zdZMS9D6rGnkSw07LoaNHyJ46fvT9pPHmq0S0DfUPvfiuEsi-B2fTrW5qKhevXxAEw9mcvXfvN2j0bJYx0BbYANRcvVOroV0YfPwq7ctm4KwSyQ4_&amp;Key-Pair-Id=APKAJUA62FNWTI37JTGQ&amp;filename=Firefox-Setup-28-0b1.exe\" target=\"_blank\" rel=\"external\">firefox nightly</a></p>\n</li>\n<li><p><a href=\"https://webvr.info/\" target=\"_blank\" rel=\"external\">webvr.info</a></p>\n</li>\n<li></li>\n</ol>\n","excerpt":"","more":"<h2 id=\"resources\"><a href=\"#resources\" class=\"headerlink\" title=\"resources\"></a>resources</h2><ol>\n<li><p><a href=\"http://gsf-cf.softonic.com/b2c/0c3/4c1d311e0cdd301d55a6c6ac597fbcc14c/file?SD_used=0&amp;channel=WEB&amp;fdh=no&amp;id_file=6649728&amp;instance=softonic_en&amp;type=PROGRAM&amp;Expires=1490839525&amp;Signature=Ggc0sQ~wKQcuxzGprxbj7hdhO-~-IG-FfxT6t3kesFLa75JjaGNzVvSrsH3zdZMS9D6rGnkSw07LoaNHyJ46fvT9pPHmq0S0DfUPvfiuEsi-B2fTrW5qKhevXxAEw9mcvXfvN2j0bJYx0BbYANRcvVOroV0YfPwq7ctm4KwSyQ4_&amp;Key-Pair-Id=APKAJUA62FNWTI37JTGQ&amp;filename=Firefox-Setup-28-0b1.exe\">firefox nightly</a></p>\n</li>\n<li><p><a href=\"https://webvr.info/\">webvr.info</a></p>\n</li>\n<li></li>\n</ol>\n"},{"title":"CSS-Tricks-Record","date":"2017-07-30T07:34:47.000Z","_content":"\n## 画尖角\n```css\n#test-div {\t\n\tposition: absolute;\n\twidth: 14em;\n\tpadding: .6em .8em;\n\tborder-radius: .3em;\n\tmargin: .3em 0 0 -.2em;\n\tbackground: #fed;\n\tborder: 1px solid rgba(0,0,0,.3);\n\tbox-shadow: .05em .2em .6em rgba(0,0,0,.2);\n\tfont-size: 75%;\n}\n```\n\n```css\n#test-div:before {\n\tcontent: \"\";\n\tposition: absolute;\n\ttop: calc(50%);\n\tleft: 100%;\n\tpadding: .35em;\n\tbackground: inherit;\n\tborder: inherit;\n\tborder-right: 0;\n\tborder-bottom: 0;\n\ttransform: translateY(-50%) translateX(-50%) rotate(135deg) ;\n}\n```","source":"_posts/CSS-Tricks-Record.md","raw":"---\ntitle: CSS-Tricks-Record\ndate: 2017-07-30 15:34:47\ntags:\n---\n\n## 画尖角\n```css\n#test-div {\t\n\tposition: absolute;\n\twidth: 14em;\n\tpadding: .6em .8em;\n\tborder-radius: .3em;\n\tmargin: .3em 0 0 -.2em;\n\tbackground: #fed;\n\tborder: 1px solid rgba(0,0,0,.3);\n\tbox-shadow: .05em .2em .6em rgba(0,0,0,.2);\n\tfont-size: 75%;\n}\n```\n\n```css\n#test-div:before {\n\tcontent: \"\";\n\tposition: absolute;\n\ttop: calc(50%);\n\tleft: 100%;\n\tpadding: .35em;\n\tbackground: inherit;\n\tborder: inherit;\n\tborder-right: 0;\n\tborder-bottom: 0;\n\ttransform: translateY(-50%) translateX(-50%) rotate(135deg) ;\n}\n```","slug":"CSS-Tricks-Record","published":1,"updated":"2017-12-19T18:25:22.376Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjbdyo3120009nf8jh4035m90","content":"<h2 id=\"画尖角\"><a href=\"#画尖角\" class=\"headerlink\" title=\"画尖角\"></a>画尖角</h2><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-id\">#test-div</span> &#123;\t</div><div class=\"line\">\t<span class=\"attribute\">position</span>: absolute;</div><div class=\"line\">\t<span class=\"attribute\">width</span>: <span class=\"number\">14em</span>;</div><div class=\"line\">\t<span class=\"attribute\">padding</span>: .<span class=\"number\">6em</span> .<span class=\"number\">8em</span>;</div><div class=\"line\">\t<span class=\"attribute\">border-radius</span>: .<span class=\"number\">3em</span>;</div><div class=\"line\">\t<span class=\"attribute\">margin</span>: .<span class=\"number\">3em</span> <span class=\"number\">0</span> <span class=\"number\">0</span> -.<span class=\"number\">2em</span>;</div><div class=\"line\">\t<span class=\"attribute\">background</span>: <span class=\"number\">#fed</span>;</div><div class=\"line\">\t<span class=\"attribute\">border</span>: <span class=\"number\">1px</span> solid <span class=\"built_in\">rgba</span>(0,0,0,.3);</div><div class=\"line\">\t<span class=\"attribute\">box-shadow</span>: .<span class=\"number\">05em</span> .<span class=\"number\">2em</span> .<span class=\"number\">6em</span> <span class=\"built_in\">rgba</span>(0,0,0,.2);</div><div class=\"line\">\t<span class=\"attribute\">font-size</span>: <span class=\"number\">75%</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-id\">#test-div</span><span class=\"selector-pseudo\">:before</span> &#123;</div><div class=\"line\">\t<span class=\"attribute\">content</span>: <span class=\"string\">\"\"</span>;</div><div class=\"line\">\t<span class=\"attribute\">position</span>: absolute;</div><div class=\"line\">\t<span class=\"attribute\">top</span>: <span class=\"built_in\">calc</span>(50%);</div><div class=\"line\">\t<span class=\"attribute\">left</span>: <span class=\"number\">100%</span>;</div><div class=\"line\">\t<span class=\"attribute\">padding</span>: .<span class=\"number\">35em</span>;</div><div class=\"line\">\t<span class=\"attribute\">background</span>: inherit;</div><div class=\"line\">\t<span class=\"attribute\">border</span>: inherit;</div><div class=\"line\">\t<span class=\"attribute\">border-right</span>: <span class=\"number\">0</span>;</div><div class=\"line\">\t<span class=\"attribute\">border-bottom</span>: <span class=\"number\">0</span>;</div><div class=\"line\">\t<span class=\"attribute\">transform</span>: <span class=\"built_in\">translateY</span>(-50%) <span class=\"built_in\">translateX</span>(-50%) <span class=\"built_in\">rotate</span>(135deg) ;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>","excerpt":"","more":"<h2 id=\"画尖角\"><a href=\"#画尖角\" class=\"headerlink\" title=\"画尖角\"></a>画尖角</h2><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-id\">#test-div</span> &#123;\t</div><div class=\"line\">\t<span class=\"attribute\">position</span>: absolute;</div><div class=\"line\">\t<span class=\"attribute\">width</span>: <span class=\"number\">14em</span>;</div><div class=\"line\">\t<span class=\"attribute\">padding</span>: .<span class=\"number\">6em</span> .<span class=\"number\">8em</span>;</div><div class=\"line\">\t<span class=\"attribute\">border-radius</span>: .<span class=\"number\">3em</span>;</div><div class=\"line\">\t<span class=\"attribute\">margin</span>: .<span class=\"number\">3em</span> <span class=\"number\">0</span> <span class=\"number\">0</span> -.<span class=\"number\">2em</span>;</div><div class=\"line\">\t<span class=\"attribute\">background</span>: <span class=\"number\">#fed</span>;</div><div class=\"line\">\t<span class=\"attribute\">border</span>: <span class=\"number\">1px</span> solid <span class=\"built_in\">rgba</span>(0,0,0,.3);</div><div class=\"line\">\t<span class=\"attribute\">box-shadow</span>: .<span class=\"number\">05em</span> .<span class=\"number\">2em</span> .<span class=\"number\">6em</span> <span class=\"built_in\">rgba</span>(0,0,0,.2);</div><div class=\"line\">\t<span class=\"attribute\">font-size</span>: <span class=\"number\">75%</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-id\">#test-div</span><span class=\"selector-pseudo\">:before</span> &#123;</div><div class=\"line\">\t<span class=\"attribute\">content</span>: <span class=\"string\">\"\"</span>;</div><div class=\"line\">\t<span class=\"attribute\">position</span>: absolute;</div><div class=\"line\">\t<span class=\"attribute\">top</span>: <span class=\"built_in\">calc</span>(50%);</div><div class=\"line\">\t<span class=\"attribute\">left</span>: <span class=\"number\">100%</span>;</div><div class=\"line\">\t<span class=\"attribute\">padding</span>: .<span class=\"number\">35em</span>;</div><div class=\"line\">\t<span class=\"attribute\">background</span>: inherit;</div><div class=\"line\">\t<span class=\"attribute\">border</span>: inherit;</div><div class=\"line\">\t<span class=\"attribute\">border-right</span>: <span class=\"number\">0</span>;</div><div class=\"line\">\t<span class=\"attribute\">border-bottom</span>: <span class=\"number\">0</span>;</div><div class=\"line\">\t<span class=\"attribute\">transform</span>: <span class=\"built_in\">translateY</span>(-50%) <span class=\"built_in\">translateX</span>(-50%) <span class=\"built_in\">rotate</span>(135deg) ;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>"},{"title":"CSS-Animation","date":"2017-07-25T15:23:04.000Z","_content":"\n## transform\ntransform 是变换的基础，常用的操作主要有 scale，rotate，translate(translateX/Y)。\n在使用的时候会遇到以下几个注意点：\n1. scale 和 rotate 操作肯定是需要指定变换原点的，那么默认的原点是什么呢？答案是中心。\n2. 那么根据 1，如果我们不想使用中心作为变换原点怎么办？答案是使用 transform-origin。\n3. 还有一个 rotate，仅仅有一个转换原点还不够，还有旋转方向的设定，比如 rotate(45deg) 其实是指逆时针旋转 45 度。\n4. 此外，translateY(-50%) 的 50% 是指元素本身的一半高度。\n5. 其实要做二维变换可以是使用 matrix(a, b, c, d, tx, ty) 来做任意的转换\n\n\n## transition\ntransition 其实就是一种简单的动画，和 animation 的区别只是在于没法将动画过程进行细分，只能对开始和最后的设定值进行动画设定，并且可以使用 timing-function 来控制动画的播放。\nMDN 上的定义：transition: <property> <duration> <timing-function> <delay>;\n\n## animation\nanimation 必须配合 @keyframe 来使用，其实就是高级版的 transition。\n\n## bezier function\n由于 timing-function 比较容易使用的是 bezier function（贝塞尔函数），所以想要对它多了解一点。","source":"_posts/CSS-Animation.md","raw":"---\ntitle: CSS-Animation\ndate: 2017-07-25 23:23:04\ntags: css\n---\n\n## transform\ntransform 是变换的基础，常用的操作主要有 scale，rotate，translate(translateX/Y)。\n在使用的时候会遇到以下几个注意点：\n1. scale 和 rotate 操作肯定是需要指定变换原点的，那么默认的原点是什么呢？答案是中心。\n2. 那么根据 1，如果我们不想使用中心作为变换原点怎么办？答案是使用 transform-origin。\n3. 还有一个 rotate，仅仅有一个转换原点还不够，还有旋转方向的设定，比如 rotate(45deg) 其实是指逆时针旋转 45 度。\n4. 此外，translateY(-50%) 的 50% 是指元素本身的一半高度。\n5. 其实要做二维变换可以是使用 matrix(a, b, c, d, tx, ty) 来做任意的转换\n\n\n## transition\ntransition 其实就是一种简单的动画，和 animation 的区别只是在于没法将动画过程进行细分，只能对开始和最后的设定值进行动画设定，并且可以使用 timing-function 来控制动画的播放。\nMDN 上的定义：transition: <property> <duration> <timing-function> <delay>;\n\n## animation\nanimation 必须配合 @keyframe 来使用，其实就是高级版的 transition。\n\n## bezier function\n由于 timing-function 比较容易使用的是 bezier function（贝塞尔函数），所以想要对它多了解一点。","slug":"CSS-Animation","published":1,"updated":"2017-07-30T08:06:42.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjbdyo314000bnf8jozkvtxfk","content":"<h2 id=\"transform\"><a href=\"#transform\" class=\"headerlink\" title=\"transform\"></a>transform</h2><p>transform 是变换的基础，常用的操作主要有 scale，rotate，translate(translateX/Y)。<br>在使用的时候会遇到以下几个注意点：</p>\n<ol>\n<li>scale 和 rotate 操作肯定是需要指定变换原点的，那么默认的原点是什么呢？答案是中心。</li>\n<li>那么根据 1，如果我们不想使用中心作为变换原点怎么办？答案是使用 transform-origin。</li>\n<li>还有一个 rotate，仅仅有一个转换原点还不够，还有旋转方向的设定，比如 rotate(45deg) 其实是指逆时针旋转 45 度。</li>\n<li>此外，translateY(-50%) 的 50% 是指元素本身的一半高度。</li>\n<li>其实要做二维变换可以是使用 matrix(a, b, c, d, tx, ty) 来做任意的转换</li>\n</ol>\n<h2 id=\"transition\"><a href=\"#transition\" class=\"headerlink\" title=\"transition\"></a>transition</h2><p>transition 其实就是一种简单的动画，和 animation 的区别只是在于没法将动画过程进行细分，只能对开始和最后的设定值进行动画设定，并且可以使用 timing-function 来控制动画的播放。<br>MDN 上的定义：transition: <property> <duration> <timing-function> <delay>;</delay></timing-function></duration></property></p>\n<h2 id=\"animation\"><a href=\"#animation\" class=\"headerlink\" title=\"animation\"></a>animation</h2><p>animation 必须配合 @keyframe 来使用，其实就是高级版的 transition。</p>\n<h2 id=\"bezier-function\"><a href=\"#bezier-function\" class=\"headerlink\" title=\"bezier function\"></a>bezier function</h2><p>由于 timing-function 比较容易使用的是 bezier function（贝塞尔函数），所以想要对它多了解一点。</p>\n","excerpt":"","more":"<h2 id=\"transform\"><a href=\"#transform\" class=\"headerlink\" title=\"transform\"></a>transform</h2><p>transform 是变换的基础，常用的操作主要有 scale，rotate，translate(translateX/Y)。<br>在使用的时候会遇到以下几个注意点：</p>\n<ol>\n<li>scale 和 rotate 操作肯定是需要指定变换原点的，那么默认的原点是什么呢？答案是中心。</li>\n<li>那么根据 1，如果我们不想使用中心作为变换原点怎么办？答案是使用 transform-origin。</li>\n<li>还有一个 rotate，仅仅有一个转换原点还不够，还有旋转方向的设定，比如 rotate(45deg) 其实是指逆时针旋转 45 度。</li>\n<li>此外，translateY(-50%) 的 50% 是指元素本身的一半高度。</li>\n<li>其实要做二维变换可以是使用 matrix(a, b, c, d, tx, ty) 来做任意的转换</li>\n</ol>\n<h2 id=\"transition\"><a href=\"#transition\" class=\"headerlink\" title=\"transition\"></a>transition</h2><p>transition 其实就是一种简单的动画，和 animation 的区别只是在于没法将动画过程进行细分，只能对开始和最后的设定值进行动画设定，并且可以使用 timing-function 来控制动画的播放。<br>MDN 上的定义：transition: <property> <duration> <timing-function> <delay>;</p>\n<h2 id=\"animation\"><a href=\"#animation\" class=\"headerlink\" title=\"animation\"></a>animation</h2><p>animation 必须配合 @keyframe 来使用，其实就是高级版的 transition。</p>\n<h2 id=\"bezier-function\"><a href=\"#bezier-function\" class=\"headerlink\" title=\"bezier function\"></a>bezier function</h2><p>由于 timing-function 比较容易使用的是 bezier function（贝塞尔函数），所以想要对它多了解一点。</p>\n"},{"title":"Design-Rules","date":"2017-06-15T15:55:37.000Z","_content":"# Design Patterns\n我本来还是相当推崇设计模式的，但是在公司里一些前辈的建议下，让我淡化设计模式本身，记住软件设计的原则，通过多看多写，来自我领悟软件工程的精髓所在，以避免生搬硬套，而走向歧途。\n\n# Design Rules\n## 0.隔离变化代码(Encapsulate varying code)\n应该说这是设计模式的核心思想，所有的设计模式都是按照这个规则来提出的，因此这个规则也没有什么可以说的，只需要牢记在心。\n\n## 1.面向接口优于面向实现(Programming to Interface ranther Implements)\n这是很重要的一点，在举例子之前首先需要知道这里 Interface 和 Implement 的意思，尤其是对 Java 的使用者来说，很容易产生混乱。\n\n这里 Interface 更好的表述其实应该是 Supertype，所谓面向 Interface，其实应该说是面向 Supertype，而作为 Supertype，我们需要知道的是使用 Supertype 再配合 Polymophism，就可以使得代码的变化变少，因为 Supertype 类型的 variable 有着更强的代码兼容性（越抽象适用性更广泛）。\n\n而所谓的 Implement 其实是相对于 Supertype 来说的，面向 Implement 编程实际上就是在编程中经常使用具体的类或类型来定义变量，从而导致代码发生变化的时候，改动会非常多。\n\n下面举一个例子会更方便理解。\n### 问题描述：现在假设我们要设计一个游戏场景，场景中我们需要让一个狗发出声音，面对这个需求我们怎么实现会比较优雅？\n一种快速的方法其实就是面向 Implement 的实现，首先实现一个 class 叫做 Dog:\n```java\nclass Dog {\n    private name;\n    public Dog(name) {\n        name = name;\n    }\n    public String getName() {\n        return name;\n    }\n    public void bark() {\n        //...\n    }\n}\n```\n\n然后在需要的地方，加上这段代码：\n```java\nDog dog = new Dog(\"Spot\");\ndog.bark()\n```\n看上去挺不错的，然后你要知道代码工程中，最常见的就是需求改变，比如，将这只狗变为猫？在这样的时候你该怎么办？\n你会说很简单啊，实现一个 Cat 的 class，实现 meow 方法，然后改代码：\n```java\n<<<<<HEAD\nCat cat = new Cat(\"Mimi\");\ncat.meow()\n==========\nDog dog = new Dog(\"Spot\");\ndog.bark()\n>>>>>Old\n```\n\n现在看来改动也不是很多嘛，但是这里只是举一个例子，然而在实际工程中，很有可能这样的改动会牵扯到几十处，那么那样的改动就十分痛苦了。\n\n现在我们看看如何使用，面向 Interface 编程来解决这个问题。\n\n记住：面向 Interface == 面向 Supertype\n因此我们首先先设计一个抽象类：\n```java\nAbstract class Animal {\n    private name;\n\n    public Animal(name) {\n        name = name;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public void makeSound();\n}\n```\n\n然后我们继承这个类，先实现 Dog 类：\n```java\nclass Dog extends Animal {\n    @override\n    public void makeSound() {\n        //...\n    }\n}\n```\n\n那么调用这段代码的时候，我们要这么写:\n```java\nAnimal animal = new Dog(\"Spot\");\nanimal.makeSound()\n```\n\n如果再遇到要将 Dog 改成 Cat 的情况，那么我们就可以先实现 Cat 这个类（继承自 Animal），然后只需要改动一行：\n```java\n<<<<<HEAD\nAnimal animal = new Cat(\"Mimi\");\n=====\nAnimal animal = new Dog(\"Sopt\");\n>>>>>Old\nanimal.makeSound\n```\n这里也许有一点不好的事， animal 这个变量名太过抽象，代码的可读性不是很好，其实这里可以用具体的名字来代替，之后可以借助一些 Refactor 工具，可以瞬间改掉所有的名字，完全没有任何风险。\n\n## 2.组合优于继承(Favor Composition over Inheritance)\n组合优于继承的原因其实是很容易理解的，一旦使用了继承那么你的方法都必须被实现，被实现就意味着代码无法动态变化，无法动态变化也就意味着复用率变低。\n\n而如果使用组合的话，我们便可以使用 Supertype 来持有某个类的 Instance，然后在需要变化的时候，可以将这个变量动态换成另外的 Instance 并且同时不对代码造成影响。\n\n## 3.低耦合(Loose Coupling)\n不同对象之间的耦合度越低自然会带来越好的编程体验，不过在说它的好处之前有一点需要理清的是，什么样的耦合算低？\n\n我现在的看法是，两个对象之间对彼此的 Knowledge 知道的越少，耦合越低，那么什么是 Knowledge 呢？\n具体来说有两点：\n1. 使用对方的 public method 的次数，使用的越少，耦合度就越低。（**有待商榷**）\n2. 一个类知道的其他 type 越少，耦合度就越低。\n\n低耦合带来的好处是显而易见的：\n1. 修改各自的代码实现对另一方的影响会很低，或者说只要保证暴露给对方的 method 不变，就几乎不会对对方造成任何影响\n2. 代码复用率高，双方的使用场景将不限于彼此\n\n观察者模式就是这条规则的具体体现。\n\n## 4.拓展类而非修改(Classes should be open for extension, but closed for modification)\n好处不必多说，花了大力气写好的、工作正常的、可读性好的代码，如果随便修改那是多么可惜，因此拓展类而不是修改它。\n\n其实这条 rule 的关键在于怎么做到？这个问题又分为两个子问题：\n\n1. 怎么在设计的时候，就避免之后的出现必要的改动？\n\n    这个问题我觉得自己暂时还讲不清楚，可能更多的是需要经验，然后总结出规律。\n\n2. 怎么在使用拓展来代替修改？\n\n    这个可以借助一些设计模式，比如 Decorator。\n\n## 5.依赖逆转(Dependency Invertion)\n这是一个很重要的原则，在 Head 书中我个人觉得讲得不是很清楚。\n\n在用具体的例子解释之前，名词的定义必须要理解，即什么是 Dependency？什么是 Invertion？\n### Dependency\n从字面上理解，就知道肯定存在多个事物，不妨就认为是两个类，Class A & B，那么我们都知道，如果在 A 中使用 B 的同时，又在 B 中使用 A，肯定是一种一般意义上不好的用法，因此不妨认为只会在 A 中使用 B。\n\n如果我们需要在 A 中使用 B，那么实际上就是 A 需要让 B 来达到某种效果，而一般认为的做法实际上就是在实现 B 的时候，实现某些功能，然后我们在 A 中会根据 B 暴露的方法去使用，然后便可以通过这一系列的调用来解决问题，这个过程中 A 是 depend on B 的，得看 B 实现了什么功能，然后去调用它实现的功能。\n\n这就是 Dependncy Invertion 中 Dependency 的含义。\n\n### Invertion\n说到这里你也许就知道了，Invertion 含义就是将上面的例子中 A depend on B，转化为 B depend on A。\n\n至于怎么 invert，以及为什么要 invert。我们直接通过一个例子来看。\n\n试想这样一个例子，我们有两个类，PriceAverager 和 Commodity，基本的定义如下:\n```java\nclass PriceAverager {\n    private Commodity commodity1;\n    private Commodity commodity2;\n\n    public PriceAverager(Commodity c1, Commodity c2) {\n        commodity1 = c1;\n        commodity2 = c2;\n    }\n\n    float getAveragePrice() {\n        return (c1.getPrice() + c2.getPrice()) / 2;\n    }\n}\n\n\nclass Commodity {\n    private String name;\n    private float price;\n\n    constructor(String name, float price) {\n        this.name = name;\n        this.price = price;\n    }\n\n    float getPrice() {\n        return price;\n    }\n\n    String getName() {\n        return name;\n    }\n}\n```\n上面的代码很简单，就不作解释了，从代码结构看来，明显是 PriceAvereger 依赖于 Commodity 的实现，最明显的一个缺点是 PriceAverager 不能给除了 Commodity 以外的类使用（比如有一个 Food 类，并且这个类和 Commodity 没有任何关系，那么即使给 Food 类添加 getPrice 方法也没有用）。\n\n因此我们需要 Dependency Invertion，那么怎么做？\n提取一个接口：\n```java\nInterface Priceable {\n    float getPrice();\n}\n```\n\n然后将之前的两个类加以修改：\n```java\nclass PriceAverager {\n    private Priceable thing1;\n    private Priceable thing2;\n\n    public PriceAverager(Priceable t1, Priceable t2) {\n        thing1 = t1;\n        thing2 = t2;\n    }\n\n    float getAveragePrice() {\n        return (t1.getPrice() + t2.getPrice()) / 2;\n    }\n}\n\n\nclass Commodity implements Priceable{\n    private String name;\n    private float price;\n\n    constructor(String name, float price) {\n        this.name = name;\n        this.price = price;\n    }\n\n    @override\n    float getPrice() {\n        return price;\n    }\n\n    String getName() {\n        return name;\n    }\n}\n```\n\n那么如果再想添加新的、可以给 PriceAverager 使用的类，只需要实现 Priceable 就行了。\n\n观察第二种写法会发现在实现 Commodity 的时候，它不在是自己随便实现了，而是被限制了，它有了 dependency，它依赖于 Priceable 接口，而 Priceable 接口实际上是直接和 PriceAverager 绑定的，因此说是 Dependency Invertion， 这样做的好处也是显而易见的。\n\n其实这个例子和 **面向接口优于实现** 中的例子几乎是一样的，这是因为后者是更抽象的表达。\n\n## 6.知道的越少越好(Least Knowledge)\n这个和  **Loose Coupling** 其实很类似，但是却是更具体的实现，毕竟低耦合一句话还是太过笼统，设计一个低耦合的系统需要考虑的事情还是很多的。\n\n现在这个 rule 所说的就是在设计某个类的时候，需要做到让他知道的越少越好，那么究竟是什么不能让他多知道呢？\n答案就是其他 class。\n根据 HEAD 书所说，在某个具体的 method 中，使用的 Object 必须符合以下条件之一或多个：\n1. 是 this\n2. 是 method 的参数\n3. 是 在这个 method 中通过 new 创建的\n4. 是 this 的某个 member\n\n看一个例子就知道了：\n```java\n// Bad Code\npublic float getTemp() {\n    Thermometer thermometer = station.getThermometer(); \n    return thermometer.getTemperature();\n}\n\n// Good Code\npublic float getTemp() {\n    return station.getTemperature();\n}\n```\n\n## 7.好莱坞法则（Don’t call us, we’ll call you）\n这个是很常见的设计规则，会一下流行的框架，比如 Android SDK，iOS，React，生命周期回调函数，让 high-level component 控制流程， low-level component 控制具体实现。\n\n在设计模式里，基本上就是 Template Method Pattern \b直接对应了这条 rule。\n\n## 8.单一职责(Single Responsibility)\n这个看上 rule 看上去是比较简单，就不多说了，基本上就是一个类不应该实现它不应该具备的功能，否则就会变成 God Object 的了。\n\n遵守这个 rule 的理由是，如果一个类具备了多个 responsibility，一方面这个类本身就会比较复杂，另一方面改动它的可能性也会很大，改动一个设计复杂的类，实在是很麻烦的一件事情。\n\n如何遵守这个 rule 呢？\n\n其实本质上就是分类的能力，将不属于此类的方法分离到其他类去实现。\n","source":"_posts/Design-Rules.md","raw":"---\ntitle: Design-Rules\ndate: 2017-06-15 23:55:37\ntags:\n---\n# Design Patterns\n我本来还是相当推崇设计模式的，但是在公司里一些前辈的建议下，让我淡化设计模式本身，记住软件设计的原则，通过多看多写，来自我领悟软件工程的精髓所在，以避免生搬硬套，而走向歧途。\n\n# Design Rules\n## 0.隔离变化代码(Encapsulate varying code)\n应该说这是设计模式的核心思想，所有的设计模式都是按照这个规则来提出的，因此这个规则也没有什么可以说的，只需要牢记在心。\n\n## 1.面向接口优于面向实现(Programming to Interface ranther Implements)\n这是很重要的一点，在举例子之前首先需要知道这里 Interface 和 Implement 的意思，尤其是对 Java 的使用者来说，很容易产生混乱。\n\n这里 Interface 更好的表述其实应该是 Supertype，所谓面向 Interface，其实应该说是面向 Supertype，而作为 Supertype，我们需要知道的是使用 Supertype 再配合 Polymophism，就可以使得代码的变化变少，因为 Supertype 类型的 variable 有着更强的代码兼容性（越抽象适用性更广泛）。\n\n而所谓的 Implement 其实是相对于 Supertype 来说的，面向 Implement 编程实际上就是在编程中经常使用具体的类或类型来定义变量，从而导致代码发生变化的时候，改动会非常多。\n\n下面举一个例子会更方便理解。\n### 问题描述：现在假设我们要设计一个游戏场景，场景中我们需要让一个狗发出声音，面对这个需求我们怎么实现会比较优雅？\n一种快速的方法其实就是面向 Implement 的实现，首先实现一个 class 叫做 Dog:\n```java\nclass Dog {\n    private name;\n    public Dog(name) {\n        name = name;\n    }\n    public String getName() {\n        return name;\n    }\n    public void bark() {\n        //...\n    }\n}\n```\n\n然后在需要的地方，加上这段代码：\n```java\nDog dog = new Dog(\"Spot\");\ndog.bark()\n```\n看上去挺不错的，然后你要知道代码工程中，最常见的就是需求改变，比如，将这只狗变为猫？在这样的时候你该怎么办？\n你会说很简单啊，实现一个 Cat 的 class，实现 meow 方法，然后改代码：\n```java\n<<<<<HEAD\nCat cat = new Cat(\"Mimi\");\ncat.meow()\n==========\nDog dog = new Dog(\"Spot\");\ndog.bark()\n>>>>>Old\n```\n\n现在看来改动也不是很多嘛，但是这里只是举一个例子，然而在实际工程中，很有可能这样的改动会牵扯到几十处，那么那样的改动就十分痛苦了。\n\n现在我们看看如何使用，面向 Interface 编程来解决这个问题。\n\n记住：面向 Interface == 面向 Supertype\n因此我们首先先设计一个抽象类：\n```java\nAbstract class Animal {\n    private name;\n\n    public Animal(name) {\n        name = name;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public void makeSound();\n}\n```\n\n然后我们继承这个类，先实现 Dog 类：\n```java\nclass Dog extends Animal {\n    @override\n    public void makeSound() {\n        //...\n    }\n}\n```\n\n那么调用这段代码的时候，我们要这么写:\n```java\nAnimal animal = new Dog(\"Spot\");\nanimal.makeSound()\n```\n\n如果再遇到要将 Dog 改成 Cat 的情况，那么我们就可以先实现 Cat 这个类（继承自 Animal），然后只需要改动一行：\n```java\n<<<<<HEAD\nAnimal animal = new Cat(\"Mimi\");\n=====\nAnimal animal = new Dog(\"Sopt\");\n>>>>>Old\nanimal.makeSound\n```\n这里也许有一点不好的事， animal 这个变量名太过抽象，代码的可读性不是很好，其实这里可以用具体的名字来代替，之后可以借助一些 Refactor 工具，可以瞬间改掉所有的名字，完全没有任何风险。\n\n## 2.组合优于继承(Favor Composition over Inheritance)\n组合优于继承的原因其实是很容易理解的，一旦使用了继承那么你的方法都必须被实现，被实现就意味着代码无法动态变化，无法动态变化也就意味着复用率变低。\n\n而如果使用组合的话，我们便可以使用 Supertype 来持有某个类的 Instance，然后在需要变化的时候，可以将这个变量动态换成另外的 Instance 并且同时不对代码造成影响。\n\n## 3.低耦合(Loose Coupling)\n不同对象之间的耦合度越低自然会带来越好的编程体验，不过在说它的好处之前有一点需要理清的是，什么样的耦合算低？\n\n我现在的看法是，两个对象之间对彼此的 Knowledge 知道的越少，耦合越低，那么什么是 Knowledge 呢？\n具体来说有两点：\n1. 使用对方的 public method 的次数，使用的越少，耦合度就越低。（**有待商榷**）\n2. 一个类知道的其他 type 越少，耦合度就越低。\n\n低耦合带来的好处是显而易见的：\n1. 修改各自的代码实现对另一方的影响会很低，或者说只要保证暴露给对方的 method 不变，就几乎不会对对方造成任何影响\n2. 代码复用率高，双方的使用场景将不限于彼此\n\n观察者模式就是这条规则的具体体现。\n\n## 4.拓展类而非修改(Classes should be open for extension, but closed for modification)\n好处不必多说，花了大力气写好的、工作正常的、可读性好的代码，如果随便修改那是多么可惜，因此拓展类而不是修改它。\n\n其实这条 rule 的关键在于怎么做到？这个问题又分为两个子问题：\n\n1. 怎么在设计的时候，就避免之后的出现必要的改动？\n\n    这个问题我觉得自己暂时还讲不清楚，可能更多的是需要经验，然后总结出规律。\n\n2. 怎么在使用拓展来代替修改？\n\n    这个可以借助一些设计模式，比如 Decorator。\n\n## 5.依赖逆转(Dependency Invertion)\n这是一个很重要的原则，在 Head 书中我个人觉得讲得不是很清楚。\n\n在用具体的例子解释之前，名词的定义必须要理解，即什么是 Dependency？什么是 Invertion？\n### Dependency\n从字面上理解，就知道肯定存在多个事物，不妨就认为是两个类，Class A & B，那么我们都知道，如果在 A 中使用 B 的同时，又在 B 中使用 A，肯定是一种一般意义上不好的用法，因此不妨认为只会在 A 中使用 B。\n\n如果我们需要在 A 中使用 B，那么实际上就是 A 需要让 B 来达到某种效果，而一般认为的做法实际上就是在实现 B 的时候，实现某些功能，然后我们在 A 中会根据 B 暴露的方法去使用，然后便可以通过这一系列的调用来解决问题，这个过程中 A 是 depend on B 的，得看 B 实现了什么功能，然后去调用它实现的功能。\n\n这就是 Dependncy Invertion 中 Dependency 的含义。\n\n### Invertion\n说到这里你也许就知道了，Invertion 含义就是将上面的例子中 A depend on B，转化为 B depend on A。\n\n至于怎么 invert，以及为什么要 invert。我们直接通过一个例子来看。\n\n试想这样一个例子，我们有两个类，PriceAverager 和 Commodity，基本的定义如下:\n```java\nclass PriceAverager {\n    private Commodity commodity1;\n    private Commodity commodity2;\n\n    public PriceAverager(Commodity c1, Commodity c2) {\n        commodity1 = c1;\n        commodity2 = c2;\n    }\n\n    float getAveragePrice() {\n        return (c1.getPrice() + c2.getPrice()) / 2;\n    }\n}\n\n\nclass Commodity {\n    private String name;\n    private float price;\n\n    constructor(String name, float price) {\n        this.name = name;\n        this.price = price;\n    }\n\n    float getPrice() {\n        return price;\n    }\n\n    String getName() {\n        return name;\n    }\n}\n```\n上面的代码很简单，就不作解释了，从代码结构看来，明显是 PriceAvereger 依赖于 Commodity 的实现，最明显的一个缺点是 PriceAverager 不能给除了 Commodity 以外的类使用（比如有一个 Food 类，并且这个类和 Commodity 没有任何关系，那么即使给 Food 类添加 getPrice 方法也没有用）。\n\n因此我们需要 Dependency Invertion，那么怎么做？\n提取一个接口：\n```java\nInterface Priceable {\n    float getPrice();\n}\n```\n\n然后将之前的两个类加以修改：\n```java\nclass PriceAverager {\n    private Priceable thing1;\n    private Priceable thing2;\n\n    public PriceAverager(Priceable t1, Priceable t2) {\n        thing1 = t1;\n        thing2 = t2;\n    }\n\n    float getAveragePrice() {\n        return (t1.getPrice() + t2.getPrice()) / 2;\n    }\n}\n\n\nclass Commodity implements Priceable{\n    private String name;\n    private float price;\n\n    constructor(String name, float price) {\n        this.name = name;\n        this.price = price;\n    }\n\n    @override\n    float getPrice() {\n        return price;\n    }\n\n    String getName() {\n        return name;\n    }\n}\n```\n\n那么如果再想添加新的、可以给 PriceAverager 使用的类，只需要实现 Priceable 就行了。\n\n观察第二种写法会发现在实现 Commodity 的时候，它不在是自己随便实现了，而是被限制了，它有了 dependency，它依赖于 Priceable 接口，而 Priceable 接口实际上是直接和 PriceAverager 绑定的，因此说是 Dependency Invertion， 这样做的好处也是显而易见的。\n\n其实这个例子和 **面向接口优于实现** 中的例子几乎是一样的，这是因为后者是更抽象的表达。\n\n## 6.知道的越少越好(Least Knowledge)\n这个和  **Loose Coupling** 其实很类似，但是却是更具体的实现，毕竟低耦合一句话还是太过笼统，设计一个低耦合的系统需要考虑的事情还是很多的。\n\n现在这个 rule 所说的就是在设计某个类的时候，需要做到让他知道的越少越好，那么究竟是什么不能让他多知道呢？\n答案就是其他 class。\n根据 HEAD 书所说，在某个具体的 method 中，使用的 Object 必须符合以下条件之一或多个：\n1. 是 this\n2. 是 method 的参数\n3. 是 在这个 method 中通过 new 创建的\n4. 是 this 的某个 member\n\n看一个例子就知道了：\n```java\n// Bad Code\npublic float getTemp() {\n    Thermometer thermometer = station.getThermometer(); \n    return thermometer.getTemperature();\n}\n\n// Good Code\npublic float getTemp() {\n    return station.getTemperature();\n}\n```\n\n## 7.好莱坞法则（Don’t call us, we’ll call you）\n这个是很常见的设计规则，会一下流行的框架，比如 Android SDK，iOS，React，生命周期回调函数，让 high-level component 控制流程， low-level component 控制具体实现。\n\n在设计模式里，基本上就是 Template Method Pattern \b直接对应了这条 rule。\n\n## 8.单一职责(Single Responsibility)\n这个看上 rule 看上去是比较简单，就不多说了，基本上就是一个类不应该实现它不应该具备的功能，否则就会变成 God Object 的了。\n\n遵守这个 rule 的理由是，如果一个类具备了多个 responsibility，一方面这个类本身就会比较复杂，另一方面改动它的可能性也会很大，改动一个设计复杂的类，实在是很麻烦的一件事情。\n\n如何遵守这个 rule 呢？\n\n其实本质上就是分类的能力，将不属于此类的方法分离到其他类去实现。\n","slug":"Design-Rules","published":1,"updated":"2017-06-15T15:55:48.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjbdyo31e000dnf8jvofcnqoa","content":"<h1 id=\"Design-Patterns\"><a href=\"#Design-Patterns\" class=\"headerlink\" title=\"Design Patterns\"></a>Design Patterns</h1><p>我本来还是相当推崇设计模式的，但是在公司里一些前辈的建议下，让我淡化设计模式本身，记住软件设计的原则，通过多看多写，来自我领悟软件工程的精髓所在，以避免生搬硬套，而走向歧途。</p>\n<h1 id=\"Design-Rules\"><a href=\"#Design-Rules\" class=\"headerlink\" title=\"Design Rules\"></a>Design Rules</h1><h2 id=\"0-隔离变化代码-Encapsulate-varying-code\"><a href=\"#0-隔离变化代码-Encapsulate-varying-code\" class=\"headerlink\" title=\"0.隔离变化代码(Encapsulate varying code)\"></a>0.隔离变化代码(Encapsulate varying code)</h2><p>应该说这是设计模式的核心思想，所有的设计模式都是按照这个规则来提出的，因此这个规则也没有什么可以说的，只需要牢记在心。</p>\n<h2 id=\"1-面向接口优于面向实现-Programming-to-Interface-ranther-Implements\"><a href=\"#1-面向接口优于面向实现-Programming-to-Interface-ranther-Implements\" class=\"headerlink\" title=\"1.面向接口优于面向实现(Programming to Interface ranther Implements)\"></a>1.面向接口优于面向实现(Programming to Interface ranther Implements)</h2><p>这是很重要的一点，在举例子之前首先需要知道这里 Interface 和 Implement 的意思，尤其是对 Java 的使用者来说，很容易产生混乱。</p>\n<p>这里 Interface 更好的表述其实应该是 Supertype，所谓面向 Interface，其实应该说是面向 Supertype，而作为 Supertype，我们需要知道的是使用 Supertype 再配合 Polymophism，就可以使得代码的变化变少，因为 Supertype 类型的 variable 有着更强的代码兼容性（越抽象适用性更广泛）。</p>\n<p>而所谓的 Implement 其实是相对于 Supertype 来说的，面向 Implement 编程实际上就是在编程中经常使用具体的类或类型来定义变量，从而导致代码发生变化的时候，改动会非常多。</p>\n<p>下面举一个例子会更方便理解。</p>\n<h3 id=\"问题描述：现在假设我们要设计一个游戏场景，场景中我们需要让一个狗发出声音，面对这个需求我们怎么实现会比较优雅？\"><a href=\"#问题描述：现在假设我们要设计一个游戏场景，场景中我们需要让一个狗发出声音，面对这个需求我们怎么实现会比较优雅？\" class=\"headerlink\" title=\"问题描述：现在假设我们要设计一个游戏场景，场景中我们需要让一个狗发出声音，面对这个需求我们怎么实现会比较优雅？\"></a>问题描述：现在假设我们要设计一个游戏场景，场景中我们需要让一个狗发出声音，面对这个需求我们怎么实现会比较优雅？</h3><p>一种快速的方法其实就是面向 Implement 的实现，首先实现一个 class 叫做 Dog:<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Dog</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">private</span> name;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Dog</span><span class=\"params\">(name)</span> </span>&#123;</div><div class=\"line\">        name = name;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getName</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> name;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">bark</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"comment\">//...</span></div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>然后在需要的地方，加上这段代码：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">Dog dog = <span class=\"keyword\">new</span> Dog(<span class=\"string\">\"Spot\"</span>);</div><div class=\"line\">dog.bark()</div></pre></td></tr></table></figure></p>\n<p>看上去挺不错的，然后你要知道代码工程中，最常见的就是需求改变，比如，将这只狗变为猫？在这样的时候你该怎么办？<br>你会说很简单啊，实现一个 Cat 的 class，实现 meow 方法，然后改代码：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;&lt;&lt;&lt;&lt;HEAD</div><div class=\"line\">Cat cat = <span class=\"keyword\">new</span> Cat(<span class=\"string\">\"Mimi\"</span>);</div><div class=\"line\">cat.meow()</div><div class=\"line\">==========</div><div class=\"line\">Dog dog = <span class=\"keyword\">new</span> Dog(<span class=\"string\">\"Spot\"</span>);</div><div class=\"line\">dog.bark()</div><div class=\"line\">&gt;&gt;&gt;&gt;&gt;Old</div></pre></td></tr></table></figure></p>\n<p>现在看来改动也不是很多嘛，但是这里只是举一个例子，然而在实际工程中，很有可能这样的改动会牵扯到几十处，那么那样的改动就十分痛苦了。</p>\n<p>现在我们看看如何使用，面向 Interface 编程来解决这个问题。</p>\n<p>记住：面向 Interface == 面向 Supertype<br>因此我们首先先设计一个抽象类：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">Abstract <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Animal</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">private</span> name;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Animal</span><span class=\"params\">(name)</span> </span>&#123;</div><div class=\"line\">        name = name;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getName</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> name;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">makeSound</span><span class=\"params\">()</span></span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>然后我们继承这个类，先实现 Dog 类：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Dog</span> <span class=\"keyword\">extends</span> <span class=\"title\">Animal</span> </span>&#123;</div><div class=\"line\">    <span class=\"meta\">@override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">makeSound</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"comment\">//...</span></div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>那么调用这段代码的时候，我们要这么写:<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">Animal animal = <span class=\"keyword\">new</span> Dog(<span class=\"string\">\"Spot\"</span>);</div><div class=\"line\">animal.makeSound()</div></pre></td></tr></table></figure></p>\n<p>如果再遇到要将 Dog 改成 Cat 的情况，那么我们就可以先实现 Cat 这个类（继承自 Animal），然后只需要改动一行：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;&lt;&lt;&lt;&lt;HEAD</div><div class=\"line\">Animal animal = <span class=\"keyword\">new</span> Cat(<span class=\"string\">\"Mimi\"</span>);</div><div class=\"line\">=====</div><div class=\"line\">Animal animal = <span class=\"keyword\">new</span> Dog(<span class=\"string\">\"Sopt\"</span>);</div><div class=\"line\">&gt;&gt;&gt;&gt;&gt;Old</div><div class=\"line\">animal.makeSound</div></pre></td></tr></table></figure></p>\n<p>这里也许有一点不好的事， animal 这个变量名太过抽象，代码的可读性不是很好，其实这里可以用具体的名字来代替，之后可以借助一些 Refactor 工具，可以瞬间改掉所有的名字，完全没有任何风险。</p>\n<h2 id=\"2-组合优于继承-Favor-Composition-over-Inheritance\"><a href=\"#2-组合优于继承-Favor-Composition-over-Inheritance\" class=\"headerlink\" title=\"2.组合优于继承(Favor Composition over Inheritance)\"></a>2.组合优于继承(Favor Composition over Inheritance)</h2><p>组合优于继承的原因其实是很容易理解的，一旦使用了继承那么你的方法都必须被实现，被实现就意味着代码无法动态变化，无法动态变化也就意味着复用率变低。</p>\n<p>而如果使用组合的话，我们便可以使用 Supertype 来持有某个类的 Instance，然后在需要变化的时候，可以将这个变量动态换成另外的 Instance 并且同时不对代码造成影响。</p>\n<h2 id=\"3-低耦合-Loose-Coupling\"><a href=\"#3-低耦合-Loose-Coupling\" class=\"headerlink\" title=\"3.低耦合(Loose Coupling)\"></a>3.低耦合(Loose Coupling)</h2><p>不同对象之间的耦合度越低自然会带来越好的编程体验，不过在说它的好处之前有一点需要理清的是，什么样的耦合算低？</p>\n<p>我现在的看法是，两个对象之间对彼此的 Knowledge 知道的越少，耦合越低，那么什么是 Knowledge 呢？<br>具体来说有两点：</p>\n<ol>\n<li>使用对方的 public method 的次数，使用的越少，耦合度就越低。（<strong>有待商榷</strong>）</li>\n<li>一个类知道的其他 type 越少，耦合度就越低。</li>\n</ol>\n<p>低耦合带来的好处是显而易见的：</p>\n<ol>\n<li>修改各自的代码实现对另一方的影响会很低，或者说只要保证暴露给对方的 method 不变，就几乎不会对对方造成任何影响</li>\n<li>代码复用率高，双方的使用场景将不限于彼此</li>\n</ol>\n<p>观察者模式就是这条规则的具体体现。</p>\n<h2 id=\"4-拓展类而非修改-Classes-should-be-open-for-extension-but-closed-for-modification\"><a href=\"#4-拓展类而非修改-Classes-should-be-open-for-extension-but-closed-for-modification\" class=\"headerlink\" title=\"4.拓展类而非修改(Classes should be open for extension, but closed for modification)\"></a>4.拓展类而非修改(Classes should be open for extension, but closed for modification)</h2><p>好处不必多说，花了大力气写好的、工作正常的、可读性好的代码，如果随便修改那是多么可惜，因此拓展类而不是修改它。</p>\n<p>其实这条 rule 的关键在于怎么做到？这个问题又分为两个子问题：</p>\n<ol>\n<li><p>怎么在设计的时候，就避免之后的出现必要的改动？</p>\n<p> 这个问题我觉得自己暂时还讲不清楚，可能更多的是需要经验，然后总结出规律。</p>\n</li>\n<li><p>怎么在使用拓展来代替修改？</p>\n<p> 这个可以借助一些设计模式，比如 Decorator。</p>\n</li>\n</ol>\n<h2 id=\"5-依赖逆转-Dependency-Invertion\"><a href=\"#5-依赖逆转-Dependency-Invertion\" class=\"headerlink\" title=\"5.依赖逆转(Dependency Invertion)\"></a>5.依赖逆转(Dependency Invertion)</h2><p>这是一个很重要的原则，在 Head 书中我个人觉得讲得不是很清楚。</p>\n<p>在用具体的例子解释之前，名词的定义必须要理解，即什么是 Dependency？什么是 Invertion？</p>\n<h3 id=\"Dependency\"><a href=\"#Dependency\" class=\"headerlink\" title=\"Dependency\"></a>Dependency</h3><p>从字面上理解，就知道肯定存在多个事物，不妨就认为是两个类，Class A &amp; B，那么我们都知道，如果在 A 中使用 B 的同时，又在 B 中使用 A，肯定是一种一般意义上不好的用法，因此不妨认为只会在 A 中使用 B。</p>\n<p>如果我们需要在 A 中使用 B，那么实际上就是 A 需要让 B 来达到某种效果，而一般认为的做法实际上就是在实现 B 的时候，实现某些功能，然后我们在 A 中会根据 B 暴露的方法去使用，然后便可以通过这一系列的调用来解决问题，这个过程中 A 是 depend on B 的，得看 B 实现了什么功能，然后去调用它实现的功能。</p>\n<p>这就是 Dependncy Invertion 中 Dependency 的含义。</p>\n<h3 id=\"Invertion\"><a href=\"#Invertion\" class=\"headerlink\" title=\"Invertion\"></a>Invertion</h3><p>说到这里你也许就知道了，Invertion 含义就是将上面的例子中 A depend on B，转化为 B depend on A。</p>\n<p>至于怎么 invert，以及为什么要 invert。我们直接通过一个例子来看。</p>\n<p>试想这样一个例子，我们有两个类，PriceAverager 和 Commodity，基本的定义如下:<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PriceAverager</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">private</span> Commodity commodity1;</div><div class=\"line\">    <span class=\"keyword\">private</span> Commodity commodity2;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">PriceAverager</span><span class=\"params\">(Commodity c1, Commodity c2)</span> </span>&#123;</div><div class=\"line\">        commodity1 = c1;</div><div class=\"line\">        commodity2 = c2;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">float</span> <span class=\"title\">getAveragePrice</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> (c1.getPrice() + c2.getPrice()) / <span class=\"number\">2</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Commodity</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">private</span> String name;</div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">float</span> price;</div><div class=\"line\"></div><div class=\"line\">    constructor(String name, <span class=\"keyword\">float</span> price) &#123;</div><div class=\"line\">        <span class=\"keyword\">this</span>.name = name;</div><div class=\"line\">        <span class=\"keyword\">this</span>.price = price;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">float</span> <span class=\"title\">getPrice</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> price;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\">String <span class=\"title\">getName</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> name;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>上面的代码很简单，就不作解释了，从代码结构看来，明显是 PriceAvereger 依赖于 Commodity 的实现，最明显的一个缺点是 PriceAverager 不能给除了 Commodity 以外的类使用（比如有一个 Food 类，并且这个类和 Commodity 没有任何关系，那么即使给 Food 类添加 getPrice 方法也没有用）。</p>\n<p>因此我们需要 Dependency Invertion，那么怎么做？<br>提取一个接口：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">Interface Priceable &#123;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">float</span> <span class=\"title\">getPrice</span><span class=\"params\">()</span></span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>然后将之前的两个类加以修改：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PriceAverager</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">private</span> Priceable thing1;</div><div class=\"line\">    <span class=\"keyword\">private</span> Priceable thing2;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">PriceAverager</span><span class=\"params\">(Priceable t1, Priceable t2)</span> </span>&#123;</div><div class=\"line\">        thing1 = t1;</div><div class=\"line\">        thing2 = t2;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">float</span> <span class=\"title\">getAveragePrice</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> (t1.getPrice() + t2.getPrice()) / <span class=\"number\">2</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Commodity</span> <span class=\"keyword\">implements</span> <span class=\"title\">Priceable</span></span>&#123;</div><div class=\"line\">    <span class=\"keyword\">private</span> String name;</div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">float</span> price;</div><div class=\"line\"></div><div class=\"line\">    constructor(String name, <span class=\"keyword\">float</span> price) &#123;</div><div class=\"line\">        <span class=\"keyword\">this</span>.name = name;</div><div class=\"line\">        <span class=\"keyword\">this</span>.price = price;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"meta\">@override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">float</span> <span class=\"title\">getPrice</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> price;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\">String <span class=\"title\">getName</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> name;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>那么如果再想添加新的、可以给 PriceAverager 使用的类，只需要实现 Priceable 就行了。</p>\n<p>观察第二种写法会发现在实现 Commodity 的时候，它不在是自己随便实现了，而是被限制了，它有了 dependency，它依赖于 Priceable 接口，而 Priceable 接口实际上是直接和 PriceAverager 绑定的，因此说是 Dependency Invertion， 这样做的好处也是显而易见的。</p>\n<p>其实这个例子和 <strong>面向接口优于实现</strong> 中的例子几乎是一样的，这是因为后者是更抽象的表达。</p>\n<h2 id=\"6-知道的越少越好-Least-Knowledge\"><a href=\"#6-知道的越少越好-Least-Knowledge\" class=\"headerlink\" title=\"6.知道的越少越好(Least Knowledge)\"></a>6.知道的越少越好(Least Knowledge)</h2><p>这个和  <strong>Loose Coupling</strong> 其实很类似，但是却是更具体的实现，毕竟低耦合一句话还是太过笼统，设计一个低耦合的系统需要考虑的事情还是很多的。</p>\n<p>现在这个 rule 所说的就是在设计某个类的时候，需要做到让他知道的越少越好，那么究竟是什么不能让他多知道呢？<br>答案就是其他 class。<br>根据 HEAD 书所说，在某个具体的 method 中，使用的 Object 必须符合以下条件之一或多个：</p>\n<ol>\n<li>是 this</li>\n<li>是 method 的参数</li>\n<li>是 在这个 method 中通过 new 创建的</li>\n<li>是 this 的某个 member</li>\n</ol>\n<p>看一个例子就知道了：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// Bad Code</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">float</span> <span class=\"title\">getTemp</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    Thermometer thermometer = station.getThermometer(); </div><div class=\"line\">    <span class=\"keyword\">return</span> thermometer.getTemperature();</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// Good Code</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">float</span> <span class=\"title\">getTemp</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> station.getTemperature();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h2 id=\"7-好莱坞法则（Don’t-call-us-we’ll-call-you）\"><a href=\"#7-好莱坞法则（Don’t-call-us-we’ll-call-you）\" class=\"headerlink\" title=\"7.好莱坞法则（Don’t call us, we’ll call you）\"></a>7.好莱坞法则（Don’t call us, we’ll call you）</h2><p>这个是很常见的设计规则，会一下流行的框架，比如 Android SDK，iOS，React，生命周期回调函数，让 high-level component 控制流程， low-level component 控制具体实现。</p>\n<p>在设计模式里，基本上就是 Template Method Pattern \b直接对应了这条 rule。</p>\n<h2 id=\"8-单一职责-Single-Responsibility\"><a href=\"#8-单一职责-Single-Responsibility\" class=\"headerlink\" title=\"8.单一职责(Single Responsibility)\"></a>8.单一职责(Single Responsibility)</h2><p>这个看上 rule 看上去是比较简单，就不多说了，基本上就是一个类不应该实现它不应该具备的功能，否则就会变成 God Object 的了。</p>\n<p>遵守这个 rule 的理由是，如果一个类具备了多个 responsibility，一方面这个类本身就会比较复杂，另一方面改动它的可能性也会很大，改动一个设计复杂的类，实在是很麻烦的一件事情。</p>\n<p>如何遵守这个 rule 呢？</p>\n<p>其实本质上就是分类的能力，将不属于此类的方法分离到其他类去实现。</p>\n","excerpt":"","more":"<h1 id=\"Design-Patterns\"><a href=\"#Design-Patterns\" class=\"headerlink\" title=\"Design Patterns\"></a>Design Patterns</h1><p>我本来还是相当推崇设计模式的，但是在公司里一些前辈的建议下，让我淡化设计模式本身，记住软件设计的原则，通过多看多写，来自我领悟软件工程的精髓所在，以避免生搬硬套，而走向歧途。</p>\n<h1 id=\"Design-Rules\"><a href=\"#Design-Rules\" class=\"headerlink\" title=\"Design Rules\"></a>Design Rules</h1><h2 id=\"0-隔离变化代码-Encapsulate-varying-code\"><a href=\"#0-隔离变化代码-Encapsulate-varying-code\" class=\"headerlink\" title=\"0.隔离变化代码(Encapsulate varying code)\"></a>0.隔离变化代码(Encapsulate varying code)</h2><p>应该说这是设计模式的核心思想，所有的设计模式都是按照这个规则来提出的，因此这个规则也没有什么可以说的，只需要牢记在心。</p>\n<h2 id=\"1-面向接口优于面向实现-Programming-to-Interface-ranther-Implements\"><a href=\"#1-面向接口优于面向实现-Programming-to-Interface-ranther-Implements\" class=\"headerlink\" title=\"1.面向接口优于面向实现(Programming to Interface ranther Implements)\"></a>1.面向接口优于面向实现(Programming to Interface ranther Implements)</h2><p>这是很重要的一点，在举例子之前首先需要知道这里 Interface 和 Implement 的意思，尤其是对 Java 的使用者来说，很容易产生混乱。</p>\n<p>这里 Interface 更好的表述其实应该是 Supertype，所谓面向 Interface，其实应该说是面向 Supertype，而作为 Supertype，我们需要知道的是使用 Supertype 再配合 Polymophism，就可以使得代码的变化变少，因为 Supertype 类型的 variable 有着更强的代码兼容性（越抽象适用性更广泛）。</p>\n<p>而所谓的 Implement 其实是相对于 Supertype 来说的，面向 Implement 编程实际上就是在编程中经常使用具体的类或类型来定义变量，从而导致代码发生变化的时候，改动会非常多。</p>\n<p>下面举一个例子会更方便理解。</p>\n<h3 id=\"问题描述：现在假设我们要设计一个游戏场景，场景中我们需要让一个狗发出声音，面对这个需求我们怎么实现会比较优雅？\"><a href=\"#问题描述：现在假设我们要设计一个游戏场景，场景中我们需要让一个狗发出声音，面对这个需求我们怎么实现会比较优雅？\" class=\"headerlink\" title=\"问题描述：现在假设我们要设计一个游戏场景，场景中我们需要让一个狗发出声音，面对这个需求我们怎么实现会比较优雅？\"></a>问题描述：现在假设我们要设计一个游戏场景，场景中我们需要让一个狗发出声音，面对这个需求我们怎么实现会比较优雅？</h3><p>一种快速的方法其实就是面向 Implement 的实现，首先实现一个 class 叫做 Dog:<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Dog</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">private</span> name;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Dog</span><span class=\"params\">(name)</span> </span>&#123;</div><div class=\"line\">        name = name;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getName</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> name;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">bark</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"comment\">//...</span></div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>然后在需要的地方，加上这段代码：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">Dog dog = <span class=\"keyword\">new</span> Dog(<span class=\"string\">\"Spot\"</span>);</div><div class=\"line\">dog.bark()</div></pre></td></tr></table></figure></p>\n<p>看上去挺不错的，然后你要知道代码工程中，最常见的就是需求改变，比如，将这只狗变为猫？在这样的时候你该怎么办？<br>你会说很简单啊，实现一个 Cat 的 class，实现 meow 方法，然后改代码：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;&lt;&lt;&lt;&lt;HEAD</div><div class=\"line\">Cat cat = <span class=\"keyword\">new</span> Cat(<span class=\"string\">\"Mimi\"</span>);</div><div class=\"line\">cat.meow()</div><div class=\"line\">==========</div><div class=\"line\">Dog dog = <span class=\"keyword\">new</span> Dog(<span class=\"string\">\"Spot\"</span>);</div><div class=\"line\">dog.bark()</div><div class=\"line\">&gt;&gt;&gt;&gt;&gt;Old</div></pre></td></tr></table></figure></p>\n<p>现在看来改动也不是很多嘛，但是这里只是举一个例子，然而在实际工程中，很有可能这样的改动会牵扯到几十处，那么那样的改动就十分痛苦了。</p>\n<p>现在我们看看如何使用，面向 Interface 编程来解决这个问题。</p>\n<p>记住：面向 Interface == 面向 Supertype<br>因此我们首先先设计一个抽象类：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">Abstract <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Animal</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">private</span> name;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Animal</span><span class=\"params\">(name)</span> </span>&#123;</div><div class=\"line\">        name = name;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getName</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> name;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">makeSound</span><span class=\"params\">()</span></span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>然后我们继承这个类，先实现 Dog 类：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Dog</span> <span class=\"keyword\">extends</span> <span class=\"title\">Animal</span> </span>&#123;</div><div class=\"line\">    <span class=\"meta\">@override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">makeSound</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"comment\">//...</span></div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>那么调用这段代码的时候，我们要这么写:<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">Animal animal = <span class=\"keyword\">new</span> Dog(<span class=\"string\">\"Spot\"</span>);</div><div class=\"line\">animal.makeSound()</div></pre></td></tr></table></figure></p>\n<p>如果再遇到要将 Dog 改成 Cat 的情况，那么我们就可以先实现 Cat 这个类（继承自 Animal），然后只需要改动一行：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;&lt;&lt;&lt;&lt;HEAD</div><div class=\"line\">Animal animal = <span class=\"keyword\">new</span> Cat(<span class=\"string\">\"Mimi\"</span>);</div><div class=\"line\">=====</div><div class=\"line\">Animal animal = <span class=\"keyword\">new</span> Dog(<span class=\"string\">\"Sopt\"</span>);</div><div class=\"line\">&gt;&gt;&gt;&gt;&gt;Old</div><div class=\"line\">animal.makeSound</div></pre></td></tr></table></figure></p>\n<p>这里也许有一点不好的事， animal 这个变量名太过抽象，代码的可读性不是很好，其实这里可以用具体的名字来代替，之后可以借助一些 Refactor 工具，可以瞬间改掉所有的名字，完全没有任何风险。</p>\n<h2 id=\"2-组合优于继承-Favor-Composition-over-Inheritance\"><a href=\"#2-组合优于继承-Favor-Composition-over-Inheritance\" class=\"headerlink\" title=\"2.组合优于继承(Favor Composition over Inheritance)\"></a>2.组合优于继承(Favor Composition over Inheritance)</h2><p>组合优于继承的原因其实是很容易理解的，一旦使用了继承那么你的方法都必须被实现，被实现就意味着代码无法动态变化，无法动态变化也就意味着复用率变低。</p>\n<p>而如果使用组合的话，我们便可以使用 Supertype 来持有某个类的 Instance，然后在需要变化的时候，可以将这个变量动态换成另外的 Instance 并且同时不对代码造成影响。</p>\n<h2 id=\"3-低耦合-Loose-Coupling\"><a href=\"#3-低耦合-Loose-Coupling\" class=\"headerlink\" title=\"3.低耦合(Loose Coupling)\"></a>3.低耦合(Loose Coupling)</h2><p>不同对象之间的耦合度越低自然会带来越好的编程体验，不过在说它的好处之前有一点需要理清的是，什么样的耦合算低？</p>\n<p>我现在的看法是，两个对象之间对彼此的 Knowledge 知道的越少，耦合越低，那么什么是 Knowledge 呢？<br>具体来说有两点：</p>\n<ol>\n<li>使用对方的 public method 的次数，使用的越少，耦合度就越低。（<strong>有待商榷</strong>）</li>\n<li>一个类知道的其他 type 越少，耦合度就越低。</li>\n</ol>\n<p>低耦合带来的好处是显而易见的：</p>\n<ol>\n<li>修改各自的代码实现对另一方的影响会很低，或者说只要保证暴露给对方的 method 不变，就几乎不会对对方造成任何影响</li>\n<li>代码复用率高，双方的使用场景将不限于彼此</li>\n</ol>\n<p>观察者模式就是这条规则的具体体现。</p>\n<h2 id=\"4-拓展类而非修改-Classes-should-be-open-for-extension-but-closed-for-modification\"><a href=\"#4-拓展类而非修改-Classes-should-be-open-for-extension-but-closed-for-modification\" class=\"headerlink\" title=\"4.拓展类而非修改(Classes should be open for extension, but closed for modification)\"></a>4.拓展类而非修改(Classes should be open for extension, but closed for modification)</h2><p>好处不必多说，花了大力气写好的、工作正常的、可读性好的代码，如果随便修改那是多么可惜，因此拓展类而不是修改它。</p>\n<p>其实这条 rule 的关键在于怎么做到？这个问题又分为两个子问题：</p>\n<ol>\n<li><p>怎么在设计的时候，就避免之后的出现必要的改动？</p>\n<p> 这个问题我觉得自己暂时还讲不清楚，可能更多的是需要经验，然后总结出规律。</p>\n</li>\n<li><p>怎么在使用拓展来代替修改？</p>\n<p> 这个可以借助一些设计模式，比如 Decorator。</p>\n</li>\n</ol>\n<h2 id=\"5-依赖逆转-Dependency-Invertion\"><a href=\"#5-依赖逆转-Dependency-Invertion\" class=\"headerlink\" title=\"5.依赖逆转(Dependency Invertion)\"></a>5.依赖逆转(Dependency Invertion)</h2><p>这是一个很重要的原则，在 Head 书中我个人觉得讲得不是很清楚。</p>\n<p>在用具体的例子解释之前，名词的定义必须要理解，即什么是 Dependency？什么是 Invertion？</p>\n<h3 id=\"Dependency\"><a href=\"#Dependency\" class=\"headerlink\" title=\"Dependency\"></a>Dependency</h3><p>从字面上理解，就知道肯定存在多个事物，不妨就认为是两个类，Class A &amp; B，那么我们都知道，如果在 A 中使用 B 的同时，又在 B 中使用 A，肯定是一种一般意义上不好的用法，因此不妨认为只会在 A 中使用 B。</p>\n<p>如果我们需要在 A 中使用 B，那么实际上就是 A 需要让 B 来达到某种效果，而一般认为的做法实际上就是在实现 B 的时候，实现某些功能，然后我们在 A 中会根据 B 暴露的方法去使用，然后便可以通过这一系列的调用来解决问题，这个过程中 A 是 depend on B 的，得看 B 实现了什么功能，然后去调用它实现的功能。</p>\n<p>这就是 Dependncy Invertion 中 Dependency 的含义。</p>\n<h3 id=\"Invertion\"><a href=\"#Invertion\" class=\"headerlink\" title=\"Invertion\"></a>Invertion</h3><p>说到这里你也许就知道了，Invertion 含义就是将上面的例子中 A depend on B，转化为 B depend on A。</p>\n<p>至于怎么 invert，以及为什么要 invert。我们直接通过一个例子来看。</p>\n<p>试想这样一个例子，我们有两个类，PriceAverager 和 Commodity，基本的定义如下:<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PriceAverager</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">private</span> Commodity commodity1;</div><div class=\"line\">    <span class=\"keyword\">private</span> Commodity commodity2;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">PriceAverager</span><span class=\"params\">(Commodity c1, Commodity c2)</span> </span>&#123;</div><div class=\"line\">        commodity1 = c1;</div><div class=\"line\">        commodity2 = c2;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">float</span> <span class=\"title\">getAveragePrice</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> (c1.getPrice() + c2.getPrice()) / <span class=\"number\">2</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Commodity</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">private</span> String name;</div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">float</span> price;</div><div class=\"line\"></div><div class=\"line\">    constructor(String name, <span class=\"keyword\">float</span> price) &#123;</div><div class=\"line\">        <span class=\"keyword\">this</span>.name = name;</div><div class=\"line\">        <span class=\"keyword\">this</span>.price = price;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">float</span> <span class=\"title\">getPrice</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> price;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\">String <span class=\"title\">getName</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> name;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>上面的代码很简单，就不作解释了，从代码结构看来，明显是 PriceAvereger 依赖于 Commodity 的实现，最明显的一个缺点是 PriceAverager 不能给除了 Commodity 以外的类使用（比如有一个 Food 类，并且这个类和 Commodity 没有任何关系，那么即使给 Food 类添加 getPrice 方法也没有用）。</p>\n<p>因此我们需要 Dependency Invertion，那么怎么做？<br>提取一个接口：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">Interface Priceable &#123;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">float</span> <span class=\"title\">getPrice</span><span class=\"params\">()</span></span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>然后将之前的两个类加以修改：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PriceAverager</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">private</span> Priceable thing1;</div><div class=\"line\">    <span class=\"keyword\">private</span> Priceable thing2;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">PriceAverager</span><span class=\"params\">(Priceable t1, Priceable t2)</span> </span>&#123;</div><div class=\"line\">        thing1 = t1;</div><div class=\"line\">        thing2 = t2;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">float</span> <span class=\"title\">getAveragePrice</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> (t1.getPrice() + t2.getPrice()) / <span class=\"number\">2</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Commodity</span> <span class=\"keyword\">implements</span> <span class=\"title\">Priceable</span></span>&#123;</div><div class=\"line\">    <span class=\"keyword\">private</span> String name;</div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">float</span> price;</div><div class=\"line\"></div><div class=\"line\">    constructor(String name, <span class=\"keyword\">float</span> price) &#123;</div><div class=\"line\">        <span class=\"keyword\">this</span>.name = name;</div><div class=\"line\">        <span class=\"keyword\">this</span>.price = price;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"meta\">@override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">float</span> <span class=\"title\">getPrice</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> price;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\">String <span class=\"title\">getName</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> name;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>那么如果再想添加新的、可以给 PriceAverager 使用的类，只需要实现 Priceable 就行了。</p>\n<p>观察第二种写法会发现在实现 Commodity 的时候，它不在是自己随便实现了，而是被限制了，它有了 dependency，它依赖于 Priceable 接口，而 Priceable 接口实际上是直接和 PriceAverager 绑定的，因此说是 Dependency Invertion， 这样做的好处也是显而易见的。</p>\n<p>其实这个例子和 <strong>面向接口优于实现</strong> 中的例子几乎是一样的，这是因为后者是更抽象的表达。</p>\n<h2 id=\"6-知道的越少越好-Least-Knowledge\"><a href=\"#6-知道的越少越好-Least-Knowledge\" class=\"headerlink\" title=\"6.知道的越少越好(Least Knowledge)\"></a>6.知道的越少越好(Least Knowledge)</h2><p>这个和  <strong>Loose Coupling</strong> 其实很类似，但是却是更具体的实现，毕竟低耦合一句话还是太过笼统，设计一个低耦合的系统需要考虑的事情还是很多的。</p>\n<p>现在这个 rule 所说的就是在设计某个类的时候，需要做到让他知道的越少越好，那么究竟是什么不能让他多知道呢？<br>答案就是其他 class。<br>根据 HEAD 书所说，在某个具体的 method 中，使用的 Object 必须符合以下条件之一或多个：</p>\n<ol>\n<li>是 this</li>\n<li>是 method 的参数</li>\n<li>是 在这个 method 中通过 new 创建的</li>\n<li>是 this 的某个 member</li>\n</ol>\n<p>看一个例子就知道了：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// Bad Code</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">float</span> <span class=\"title\">getTemp</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    Thermometer thermometer = station.getThermometer(); </div><div class=\"line\">    <span class=\"keyword\">return</span> thermometer.getTemperature();</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// Good Code</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">float</span> <span class=\"title\">getTemp</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> station.getTemperature();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h2 id=\"7-好莱坞法则（Don’t-call-us-we’ll-call-you）\"><a href=\"#7-好莱坞法则（Don’t-call-us-we’ll-call-you）\" class=\"headerlink\" title=\"7.好莱坞法则（Don’t call us, we’ll call you）\"></a>7.好莱坞法则（Don’t call us, we’ll call you）</h2><p>这个是很常见的设计规则，会一下流行的框架，比如 Android SDK，iOS，React，生命周期回调函数，让 high-level component 控制流程， low-level component 控制具体实现。</p>\n<p>在设计模式里，基本上就是 Template Method Pattern \b直接对应了这条 rule。</p>\n<h2 id=\"8-单一职责-Single-Responsibility\"><a href=\"#8-单一职责-Single-Responsibility\" class=\"headerlink\" title=\"8.单一职责(Single Responsibility)\"></a>8.单一职责(Single Responsibility)</h2><p>这个看上 rule 看上去是比较简单，就不多说了，基本上就是一个类不应该实现它不应该具备的功能，否则就会变成 God Object 的了。</p>\n<p>遵守这个 rule 的理由是，如果一个类具备了多个 responsibility，一方面这个类本身就会比较复杂，另一方面改动它的可能性也会很大，改动一个设计复杂的类，实在是很麻烦的一件事情。</p>\n<p>如何遵守这个 rule 呢？</p>\n<p>其实本质上就是分类的能力，将不属于此类的方法分离到其他类去实现。</p>\n"},{"title":"ES6-异步编程","date":"2017-04-02T16:36:55.000Z","_content":"## 异步编程\n异步编程是 Javascript 的一大特色，因为 Javascript 是单线程工作，因此如果没有异步方式的话，基本上用户体验将会是无法忍受的。\n\n因此 Javascript 的语法对异步的看重使得其对异步编程用了比较大的力气去优化，本文将会对直到 ES7 的异步编程方式进行总结：\n1. Callback\n2. Promise\n3. Generator\n4. asyn + await\n\n但是在阐述这些方式之前，有一个概念需要事先阐述的是 Javascript 的事件循环。\n\n### 事件循环(event loop)\nevent loop 是 Javascript 作为单线程语言完成非阻塞处理的重要机制，但其本身很容易理解，就是 Javascript 解释器的实现中会维护一个队列，task queue，当在执行语句中出现异步函数（比如 setTimeout）的时候，这样的函数是不会立即执行的，而是会被挂起，当空闲的时候，Javascript 解释器会处理这个异步操作，当处理完毕后，会在 task queue 里面插入一个事件，这个事件一般绑定了定义好的 callback。\n\n下面是一个最简单的一个例子是：\n\n```javascript\nsetTimeout(()=>console.log('World'), 0)\nconsole.log('Hello')\n// output: \"Hello\\nWorld\" \n```\n\n结果是在意料之中的，这是因为当调用 setTimeout 函数时，你即使设置了 timeout 是 0ms，callback 函数的执行仍然会被放入 task queue 里，等到当前的 call stack 被清空后（这里停止的时机我还不是很清楚，可能是 call stack 清空，但也可能是其他判定条件，比如跑了指定长度的代码）再回来从 task queue 里面取出最新的 event 来处理，也就是执行回调。\n\n### 异步编程方式\n有了 event loop 这个概念，那么对于操作异步函数就有帮助了，下面总结异步编程的方式，为了便于说明和调试，在需要使用异步函数的时候，本文都会使用 setTimeout 这个异步函数，其实本质上他和其他异步函数没什么区别，如果设置了 timeout 参数，就可看成其他异步函数的工作时间（这和 Java 中使用 Thread.sleep() 模拟线程运行是一个道理），下面会罗列目前 Javascript 的异步处理的几种常见的方式。\n\n由于 setTimeout 的书写方式和正常异步函数不一致，此外不想在每次写 setTimeout 的时候，总是设置 timeout，所以先将其包装一下：\n\n```javascript\nvar afunc = (callback) => setTimeout(callback,1000)\n```\n此外，需要强调的是，这里所说的是异步编程方式，而不是异步函数，所谓异步编程方式（Asynchronized Programming)是指编写含有异步函数的代码的方式。\n#### Callback\n所谓的 Callback 是最原始的方式，也就说说直接将 callback 函数作为异步函数的参数传入，比如：\n```javascript\nafunc(()=>{\n    console.log(\"Hello\");\n    afunc(()=>{\n        console.log(\"World\");\n        afunc(()=>console.log(\"!\"));\n    })\n})\n//output: Hello\\nWorld\\n!\n```\n\n当然如果写成原来的样子，应该是：\n\n```javascript\nsetTimeout(()=>{\n    console.log(\"Hello\");\n    setTimeout(()=>{\n        console.log(\"World\");\n        setTimeout(()=>console.log('!'),1000);\n    },1000)\n},1000)\n```\n\n(之后就会直接使用 afunc)\n\n可以发现这样写不很方便，而且很丑，于是在 ES6 中 Promise 应运而生。\n\n#### Promise\nPromise 会提供刚好的异步编程体验，同样的例子可以这么写：\n```javascript\nnew Promise((resolve,reject)=>{\n    afunc(()=>{console.log(\"Hello\");resolve();})\n}).then(()=>new Promise((resolve)=>afunc(()=>{console.log(\"World\");resolve()})))\n.then(()=>new Promise((resolve)=>afunc(()=>{console.log(\"!\");resolve()})))\n```\n这样就写成了链式的调用，但看上去非常繁琐，实际上我们可以将 afunc 封装一下：(为了不起冲突，命名成 afuncp)\n```javascript\nvar afuncp = (callback)=>{\n    return new Promise((resolve)=>{\n        setTimeout(()=>{\n            callback();resolve()\n            }, 1000);\n    })\n}\n\n// then the statement can be expressed as:\nafuncp(()=>console.log(\"Hello\"))\n.then(()=>afuncp(()=>console.log(\"World\")))\n.then(()=>afuncp(()=>console.log(\"!\")))\n```\n是不是简洁多了？\n这里的改写实际上和 fs 中的 readFile 和 fs-readfile-promise 类似。\n\n但即使如此，还有更方便的写法。\n\n#### Generator\n如果能把异步编程的方式写成同步形式，那岂不是更加美观？\n\nGenerator 应运而生。\n\n如果使用 Generator 的话，上面的写法将会变成：（注意这里使用的是 afuncp 而不是 afunc，当然使用 afunc 也是可以的，但是在下面要使用 Promise 的特性时就行不通了）\n```javascript\nfunction* genHelloWorld(){\n    yield afuncp(()=>console.log(\"Hello\"));\n    yield afuncp(()=>console.log(\"World\"));\n    yield afuncp(()=>console.log(\"!\"));\n}\n\nvar g = genHelloWorld();\ng.next()\ng.next()\ng.next()\n```\n但是这么写却是不对的，（你可以发现三个字符串是同时出现的）为什么呢？因为虽然通过利用 Generator 执行到下一个 yield 会停止的特性来做到了，这样顺序执行了三个异步操作，但是和之前两个异步操作不一样，因为我们之前写的异步操作是有先后关系的，后一个异步操作必须是在前一个异步操作完成之后才能执行的。\n\n也就是说 Generator 其实本身不支持异步操作的依赖执行（就是前一个先执行了，才能执行下一个），但是具备记录上次执行位置和状态使得它有可能完成异步编程方式，而其所欠缺的只是一个使得依赖执行能够运作的机制（姑且成为依赖运行器）。\n\n下面我们就来实现这个机制，这个机制的关键地方在于控制依赖，以及自动运行：\n```javascript\nfunction genController(gen){\n    let g = gen();\n    function next(){\n        let res = g.next();\n        if(!res.done){\n            res.value.then(next);\n        }\n    }\n    next();\n}\n\n// now let's run genHelloWorld\ngenContorller(genHelloWorld);\n```\n如果想在 production 环境中使用这样的机制，可以考虑 co 这个模块。\n\n#### async + await\n通过上面的例子可以看出来，Generator 虽然在表达异步编程上非常具有优势，但是容易发现需要自己定义依赖运行器，于是 async 函数应运而生，其本质还是 Generator 但是却自带了依赖运行器。\n下面试试，async 的写法：\n```javascript\nasync function genHelloWorld() {\n    await afuncp(()=>console.log(\"Hello\"));\n    await afuncp(()=>console.log(\"World\"));\n    await afuncp(()=>console.log(\"!\"));\n}\ngenHelloWorld();\n```\n很完美！\n\n#### Promise 的实现\n\n之前有个工作上的前辈让我实现一个 Promise，叫我半个小时写出来一个有 resolve、then 功能的 Promise 类，结果我花了一晚上才实现出来。\n代码如下：\n```javascript\nclass PPromise {\n    constructor(asyncF) {\n        this.cb = null; \n        this.resolve = this.resolve.bind(this);\n        this.then = this.then.bind(this);\n        // convert resolve to async function calling\n        asyncF.apply(null, [(data)=>setTimeout(()=>this.resolve(data),0)])\n    }\n\n    resolve(data) {\n            var cb = this.cb;\n            if (cb!==null)\n                cb.apply(null,[data]);\n    }\n\n    then(cb) {\n        var newPromise = new PPromise(()=>null);\n        // link the next promise in the cb\n        this.cb = (data)=>{\n            var d = cb.apply(null,[data]) \n            newPromise.resolve(d); \n        }   \n        return newPromise;\n    }\n}\n```\n实现的时候有两点需要注意的是：\n1. new Promise((resolve)=>resolve(data)).then(console.log) 这个 resolve 调用是会被挂起的，这点也是这行代码 `asyncF.apply(null, [(data)=>setTimeout(()=>this.resolve(data),0)])` 的作用。\n2. then 返回的是一个什么？ 答案是还是一个 Promise，这里的实现是返回一个新的 Promise 然后在当前 Promise 的 callback 中调用新 Promise 的 resolve 方法。","source":"_posts/ES6-异步编程.md","raw":"---\ntitle: ES6-异步编程\ndate: 2017-04-03 00:36:55\ntags: Javascript 异步编程\n---\n## 异步编程\n异步编程是 Javascript 的一大特色，因为 Javascript 是单线程工作，因此如果没有异步方式的话，基本上用户体验将会是无法忍受的。\n\n因此 Javascript 的语法对异步的看重使得其对异步编程用了比较大的力气去优化，本文将会对直到 ES7 的异步编程方式进行总结：\n1. Callback\n2. Promise\n3. Generator\n4. asyn + await\n\n但是在阐述这些方式之前，有一个概念需要事先阐述的是 Javascript 的事件循环。\n\n### 事件循环(event loop)\nevent loop 是 Javascript 作为单线程语言完成非阻塞处理的重要机制，但其本身很容易理解，就是 Javascript 解释器的实现中会维护一个队列，task queue，当在执行语句中出现异步函数（比如 setTimeout）的时候，这样的函数是不会立即执行的，而是会被挂起，当空闲的时候，Javascript 解释器会处理这个异步操作，当处理完毕后，会在 task queue 里面插入一个事件，这个事件一般绑定了定义好的 callback。\n\n下面是一个最简单的一个例子是：\n\n```javascript\nsetTimeout(()=>console.log('World'), 0)\nconsole.log('Hello')\n// output: \"Hello\\nWorld\" \n```\n\n结果是在意料之中的，这是因为当调用 setTimeout 函数时，你即使设置了 timeout 是 0ms，callback 函数的执行仍然会被放入 task queue 里，等到当前的 call stack 被清空后（这里停止的时机我还不是很清楚，可能是 call stack 清空，但也可能是其他判定条件，比如跑了指定长度的代码）再回来从 task queue 里面取出最新的 event 来处理，也就是执行回调。\n\n### 异步编程方式\n有了 event loop 这个概念，那么对于操作异步函数就有帮助了，下面总结异步编程的方式，为了便于说明和调试，在需要使用异步函数的时候，本文都会使用 setTimeout 这个异步函数，其实本质上他和其他异步函数没什么区别，如果设置了 timeout 参数，就可看成其他异步函数的工作时间（这和 Java 中使用 Thread.sleep() 模拟线程运行是一个道理），下面会罗列目前 Javascript 的异步处理的几种常见的方式。\n\n由于 setTimeout 的书写方式和正常异步函数不一致，此外不想在每次写 setTimeout 的时候，总是设置 timeout，所以先将其包装一下：\n\n```javascript\nvar afunc = (callback) => setTimeout(callback,1000)\n```\n此外，需要强调的是，这里所说的是异步编程方式，而不是异步函数，所谓异步编程方式（Asynchronized Programming)是指编写含有异步函数的代码的方式。\n#### Callback\n所谓的 Callback 是最原始的方式，也就说说直接将 callback 函数作为异步函数的参数传入，比如：\n```javascript\nafunc(()=>{\n    console.log(\"Hello\");\n    afunc(()=>{\n        console.log(\"World\");\n        afunc(()=>console.log(\"!\"));\n    })\n})\n//output: Hello\\nWorld\\n!\n```\n\n当然如果写成原来的样子，应该是：\n\n```javascript\nsetTimeout(()=>{\n    console.log(\"Hello\");\n    setTimeout(()=>{\n        console.log(\"World\");\n        setTimeout(()=>console.log('!'),1000);\n    },1000)\n},1000)\n```\n\n(之后就会直接使用 afunc)\n\n可以发现这样写不很方便，而且很丑，于是在 ES6 中 Promise 应运而生。\n\n#### Promise\nPromise 会提供刚好的异步编程体验，同样的例子可以这么写：\n```javascript\nnew Promise((resolve,reject)=>{\n    afunc(()=>{console.log(\"Hello\");resolve();})\n}).then(()=>new Promise((resolve)=>afunc(()=>{console.log(\"World\");resolve()})))\n.then(()=>new Promise((resolve)=>afunc(()=>{console.log(\"!\");resolve()})))\n```\n这样就写成了链式的调用，但看上去非常繁琐，实际上我们可以将 afunc 封装一下：(为了不起冲突，命名成 afuncp)\n```javascript\nvar afuncp = (callback)=>{\n    return new Promise((resolve)=>{\n        setTimeout(()=>{\n            callback();resolve()\n            }, 1000);\n    })\n}\n\n// then the statement can be expressed as:\nafuncp(()=>console.log(\"Hello\"))\n.then(()=>afuncp(()=>console.log(\"World\")))\n.then(()=>afuncp(()=>console.log(\"!\")))\n```\n是不是简洁多了？\n这里的改写实际上和 fs 中的 readFile 和 fs-readfile-promise 类似。\n\n但即使如此，还有更方便的写法。\n\n#### Generator\n如果能把异步编程的方式写成同步形式，那岂不是更加美观？\n\nGenerator 应运而生。\n\n如果使用 Generator 的话，上面的写法将会变成：（注意这里使用的是 afuncp 而不是 afunc，当然使用 afunc 也是可以的，但是在下面要使用 Promise 的特性时就行不通了）\n```javascript\nfunction* genHelloWorld(){\n    yield afuncp(()=>console.log(\"Hello\"));\n    yield afuncp(()=>console.log(\"World\"));\n    yield afuncp(()=>console.log(\"!\"));\n}\n\nvar g = genHelloWorld();\ng.next()\ng.next()\ng.next()\n```\n但是这么写却是不对的，（你可以发现三个字符串是同时出现的）为什么呢？因为虽然通过利用 Generator 执行到下一个 yield 会停止的特性来做到了，这样顺序执行了三个异步操作，但是和之前两个异步操作不一样，因为我们之前写的异步操作是有先后关系的，后一个异步操作必须是在前一个异步操作完成之后才能执行的。\n\n也就是说 Generator 其实本身不支持异步操作的依赖执行（就是前一个先执行了，才能执行下一个），但是具备记录上次执行位置和状态使得它有可能完成异步编程方式，而其所欠缺的只是一个使得依赖执行能够运作的机制（姑且成为依赖运行器）。\n\n下面我们就来实现这个机制，这个机制的关键地方在于控制依赖，以及自动运行：\n```javascript\nfunction genController(gen){\n    let g = gen();\n    function next(){\n        let res = g.next();\n        if(!res.done){\n            res.value.then(next);\n        }\n    }\n    next();\n}\n\n// now let's run genHelloWorld\ngenContorller(genHelloWorld);\n```\n如果想在 production 环境中使用这样的机制，可以考虑 co 这个模块。\n\n#### async + await\n通过上面的例子可以看出来，Generator 虽然在表达异步编程上非常具有优势，但是容易发现需要自己定义依赖运行器，于是 async 函数应运而生，其本质还是 Generator 但是却自带了依赖运行器。\n下面试试，async 的写法：\n```javascript\nasync function genHelloWorld() {\n    await afuncp(()=>console.log(\"Hello\"));\n    await afuncp(()=>console.log(\"World\"));\n    await afuncp(()=>console.log(\"!\"));\n}\ngenHelloWorld();\n```\n很完美！\n\n#### Promise 的实现\n\n之前有个工作上的前辈让我实现一个 Promise，叫我半个小时写出来一个有 resolve、then 功能的 Promise 类，结果我花了一晚上才实现出来。\n代码如下：\n```javascript\nclass PPromise {\n    constructor(asyncF) {\n        this.cb = null; \n        this.resolve = this.resolve.bind(this);\n        this.then = this.then.bind(this);\n        // convert resolve to async function calling\n        asyncF.apply(null, [(data)=>setTimeout(()=>this.resolve(data),0)])\n    }\n\n    resolve(data) {\n            var cb = this.cb;\n            if (cb!==null)\n                cb.apply(null,[data]);\n    }\n\n    then(cb) {\n        var newPromise = new PPromise(()=>null);\n        // link the next promise in the cb\n        this.cb = (data)=>{\n            var d = cb.apply(null,[data]) \n            newPromise.resolve(d); \n        }   \n        return newPromise;\n    }\n}\n```\n实现的时候有两点需要注意的是：\n1. new Promise((resolve)=>resolve(data)).then(console.log) 这个 resolve 调用是会被挂起的，这点也是这行代码 `asyncF.apply(null, [(data)=>setTimeout(()=>this.resolve(data),0)])` 的作用。\n2. then 返回的是一个什么？ 答案是还是一个 Promise，这里的实现是返回一个新的 Promise 然后在当前 Promise 的 callback 中调用新 Promise 的 resolve 方法。","slug":"ES6-异步编程","published":1,"updated":"2017-05-10T16:13:02.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjbdyo31g000fnf8j64032py9","content":"<h2 id=\"异步编程\"><a href=\"#异步编程\" class=\"headerlink\" title=\"异步编程\"></a>异步编程</h2><p>异步编程是 Javascript 的一大特色，因为 Javascript 是单线程工作，因此如果没有异步方式的话，基本上用户体验将会是无法忍受的。</p>\n<p>因此 Javascript 的语法对异步的看重使得其对异步编程用了比较大的力气去优化，本文将会对直到 ES7 的异步编程方式进行总结：</p>\n<ol>\n<li>Callback</li>\n<li>Promise</li>\n<li>Generator</li>\n<li>asyn + await</li>\n</ol>\n<p>但是在阐述这些方式之前，有一个概念需要事先阐述的是 Javascript 的事件循环。</p>\n<h3 id=\"事件循环-event-loop\"><a href=\"#事件循环-event-loop\" class=\"headerlink\" title=\"事件循环(event loop)\"></a>事件循环(event loop)</h3><p>event loop 是 Javascript 作为单线程语言完成非阻塞处理的重要机制，但其本身很容易理解，就是 Javascript 解释器的实现中会维护一个队列，task queue，当在执行语句中出现异步函数（比如 setTimeout）的时候，这样的函数是不会立即执行的，而是会被挂起，当空闲的时候，Javascript 解释器会处理这个异步操作，当处理完毕后，会在 task queue 里面插入一个事件，这个事件一般绑定了定义好的 callback。</p>\n<p>下面是一个最简单的一个例子是：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">setTimeout(<span class=\"function\"><span class=\"params\">()</span>=&gt;</span><span class=\"built_in\">console</span>.log(<span class=\"string\">'World'</span>), <span class=\"number\">0</span>)</div><div class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'Hello'</span>)</div><div class=\"line\"><span class=\"comment\">// output: \"Hello\\nWorld\"</span></div></pre></td></tr></table></figure>\n<p>结果是在意料之中的，这是因为当调用 setTimeout 函数时，你即使设置了 timeout 是 0ms，callback 函数的执行仍然会被放入 task queue 里，等到当前的 call stack 被清空后（这里停止的时机我还不是很清楚，可能是 call stack 清空，但也可能是其他判定条件，比如跑了指定长度的代码）再回来从 task queue 里面取出最新的 event 来处理，也就是执行回调。</p>\n<h3 id=\"异步编程方式\"><a href=\"#异步编程方式\" class=\"headerlink\" title=\"异步编程方式\"></a>异步编程方式</h3><p>有了 event loop 这个概念，那么对于操作异步函数就有帮助了，下面总结异步编程的方式，为了便于说明和调试，在需要使用异步函数的时候，本文都会使用 setTimeout 这个异步函数，其实本质上他和其他异步函数没什么区别，如果设置了 timeout 参数，就可看成其他异步函数的工作时间（这和 Java 中使用 Thread.sleep() 模拟线程运行是一个道理），下面会罗列目前 Javascript 的异步处理的几种常见的方式。</p>\n<p>由于 setTimeout 的书写方式和正常异步函数不一致，此外不想在每次写 setTimeout 的时候，总是设置 timeout，所以先将其包装一下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> afunc = <span class=\"function\">(<span class=\"params\">callback</span>) =&gt;</span> setTimeout(callback,<span class=\"number\">1000</span>)</div></pre></td></tr></table></figure>\n<p>此外，需要强调的是，这里所说的是异步编程方式，而不是异步函数，所谓异步编程方式（Asynchronized Programming)是指编写含有异步函数的代码的方式。</p>\n<h4 id=\"Callback\"><a href=\"#Callback\" class=\"headerlink\" title=\"Callback\"></a>Callback</h4><p>所谓的 Callback 是最原始的方式，也就说说直接将 callback 函数作为异步函数的参数传入，比如：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">afunc(<span class=\"function\"><span class=\"params\">()</span>=&gt;</span>&#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">\"Hello\"</span>);</div><div class=\"line\">    afunc(<span class=\"function\"><span class=\"params\">()</span>=&gt;</span>&#123;</div><div class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">\"World\"</span>);</div><div class=\"line\">        afunc(<span class=\"function\"><span class=\"params\">()</span>=&gt;</span><span class=\"built_in\">console</span>.log(<span class=\"string\">\"!\"</span>));</div><div class=\"line\">    &#125;)</div><div class=\"line\">&#125;)</div><div class=\"line\"><span class=\"comment\">//output: Hello\\nWorld\\n!</span></div></pre></td></tr></table></figure></p>\n<p>当然如果写成原来的样子，应该是：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">setTimeout(<span class=\"function\"><span class=\"params\">()</span>=&gt;</span>&#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">\"Hello\"</span>);</div><div class=\"line\">    setTimeout(<span class=\"function\"><span class=\"params\">()</span>=&gt;</span>&#123;</div><div class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">\"World\"</span>);</div><div class=\"line\">        setTimeout(<span class=\"function\"><span class=\"params\">()</span>=&gt;</span><span class=\"built_in\">console</span>.log(<span class=\"string\">'!'</span>),<span class=\"number\">1000</span>);</div><div class=\"line\">    &#125;,<span class=\"number\">1000</span>)</div><div class=\"line\">&#125;,<span class=\"number\">1000</span>)</div></pre></td></tr></table></figure>\n<p>(之后就会直接使用 afunc)</p>\n<p>可以发现这样写不很方便，而且很丑，于是在 ES6 中 Promise 应运而生。</p>\n<h4 id=\"Promise\"><a href=\"#Promise\" class=\"headerlink\" title=\"Promise\"></a>Promise</h4><p>Promise 会提供刚好的异步编程体验，同样的例子可以这么写：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve,reject</span>)=&gt;</span>&#123;</div><div class=\"line\">    afunc(<span class=\"function\"><span class=\"params\">()</span>=&gt;</span>&#123;<span class=\"built_in\">console</span>.log(<span class=\"string\">\"Hello\"</span>);resolve();&#125;)</div><div class=\"line\">&#125;).then(<span class=\"function\"><span class=\"params\">()</span>=&gt;</span><span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve</span>)=&gt;</span>afunc(<span class=\"function\"><span class=\"params\">()</span>=&gt;</span>&#123;<span class=\"built_in\">console</span>.log(<span class=\"string\">\"World\"</span>);resolve()&#125;)))</div><div class=\"line\">.then(<span class=\"function\"><span class=\"params\">()</span>=&gt;</span><span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve</span>)=&gt;</span>afunc(<span class=\"function\"><span class=\"params\">()</span>=&gt;</span>&#123;<span class=\"built_in\">console</span>.log(<span class=\"string\">\"!\"</span>);resolve()&#125;)))</div></pre></td></tr></table></figure></p>\n<p>这样就写成了链式的调用，但看上去非常繁琐，实际上我们可以将 afunc 封装一下：(为了不起冲突，命名成 afuncp)<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> afuncp = <span class=\"function\">(<span class=\"params\">callback</span>)=&gt;</span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve</span>)=&gt;</span>&#123;</div><div class=\"line\">        setTimeout(<span class=\"function\"><span class=\"params\">()</span>=&gt;</span>&#123;</div><div class=\"line\">            callback();resolve()</div><div class=\"line\">            &#125;, <span class=\"number\">1000</span>);</div><div class=\"line\">    &#125;)</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// then the statement can be expressed as:</span></div><div class=\"line\">afuncp(<span class=\"function\"><span class=\"params\">()</span>=&gt;</span><span class=\"built_in\">console</span>.log(<span class=\"string\">\"Hello\"</span>))</div><div class=\"line\">.then(<span class=\"function\"><span class=\"params\">()</span>=&gt;</span>afuncp(<span class=\"function\"><span class=\"params\">()</span>=&gt;</span><span class=\"built_in\">console</span>.log(<span class=\"string\">\"World\"</span>)))</div><div class=\"line\">.then(<span class=\"function\"><span class=\"params\">()</span>=&gt;</span>afuncp(<span class=\"function\"><span class=\"params\">()</span>=&gt;</span><span class=\"built_in\">console</span>.log(<span class=\"string\">\"!\"</span>)))</div></pre></td></tr></table></figure></p>\n<p>是不是简洁多了？<br>这里的改写实际上和 fs 中的 readFile 和 fs-readfile-promise 类似。</p>\n<p>但即使如此，还有更方便的写法。</p>\n<h4 id=\"Generator\"><a href=\"#Generator\" class=\"headerlink\" title=\"Generator\"></a>Generator</h4><p>如果能把异步编程的方式写成同步形式，那岂不是更加美观？</p>\n<p>Generator 应运而生。</p>\n<p>如果使用 Generator 的话，上面的写法将会变成：（注意这里使用的是 afuncp 而不是 afunc，当然使用 afunc 也是可以的，但是在下面要使用 Promise 的特性时就行不通了）<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span>* <span class=\"title\">genHelloWorld</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">    <span class=\"keyword\">yield</span> afuncp(<span class=\"function\"><span class=\"params\">()</span>=&gt;</span><span class=\"built_in\">console</span>.log(<span class=\"string\">\"Hello\"</span>));</div><div class=\"line\">    <span class=\"keyword\">yield</span> afuncp(<span class=\"function\"><span class=\"params\">()</span>=&gt;</span><span class=\"built_in\">console</span>.log(<span class=\"string\">\"World\"</span>));</div><div class=\"line\">    <span class=\"keyword\">yield</span> afuncp(<span class=\"function\"><span class=\"params\">()</span>=&gt;</span><span class=\"built_in\">console</span>.log(<span class=\"string\">\"!\"</span>));</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> g = genHelloWorld();</div><div class=\"line\">g.next()</div><div class=\"line\">g.next()</div><div class=\"line\">g.next()</div></pre></td></tr></table></figure></p>\n<p>但是这么写却是不对的，（你可以发现三个字符串是同时出现的）为什么呢？因为虽然通过利用 Generator 执行到下一个 yield 会停止的特性来做到了，这样顺序执行了三个异步操作，但是和之前两个异步操作不一样，因为我们之前写的异步操作是有先后关系的，后一个异步操作必须是在前一个异步操作完成之后才能执行的。</p>\n<p>也就是说 Generator 其实本身不支持异步操作的依赖执行（就是前一个先执行了，才能执行下一个），但是具备记录上次执行位置和状态使得它有可能完成异步编程方式，而其所欠缺的只是一个使得依赖执行能够运作的机制（姑且成为依赖运行器）。</p>\n<p>下面我们就来实现这个机制，这个机制的关键地方在于控制依赖，以及自动运行：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">genController</span>(<span class=\"params\">gen</span>)</span>&#123;</div><div class=\"line\">    <span class=\"keyword\">let</span> g = gen();</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">next</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">        <span class=\"keyword\">let</span> res = g.next();</div><div class=\"line\">        <span class=\"keyword\">if</span>(!res.done)&#123;</div><div class=\"line\">            res.value.then(next);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    next();</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// now let's run genHelloWorld</span></div><div class=\"line\">genContorller(genHelloWorld);</div></pre></td></tr></table></figure></p>\n<p>如果想在 production 环境中使用这样的机制，可以考虑 co 这个模块。</p>\n<h4 id=\"async-await\"><a href=\"#async-await\" class=\"headerlink\" title=\"async + await\"></a>async + await</h4><p>通过上面的例子可以看出来，Generator 虽然在表达异步编程上非常具有优势，但是容易发现需要自己定义依赖运行器，于是 async 函数应运而生，其本质还是 Generator 但是却自带了依赖运行器。<br>下面试试，async 的写法：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">genHelloWorld</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">await</span> afuncp(<span class=\"function\"><span class=\"params\">()</span>=&gt;</span><span class=\"built_in\">console</span>.log(<span class=\"string\">\"Hello\"</span>));</div><div class=\"line\">    <span class=\"keyword\">await</span> afuncp(<span class=\"function\"><span class=\"params\">()</span>=&gt;</span><span class=\"built_in\">console</span>.log(<span class=\"string\">\"World\"</span>));</div><div class=\"line\">    <span class=\"keyword\">await</span> afuncp(<span class=\"function\"><span class=\"params\">()</span>=&gt;</span><span class=\"built_in\">console</span>.log(<span class=\"string\">\"!\"</span>));</div><div class=\"line\">&#125;</div><div class=\"line\">genHelloWorld();</div></pre></td></tr></table></figure></p>\n<p>很完美！</p>\n<h4 id=\"Promise-的实现\"><a href=\"#Promise-的实现\" class=\"headerlink\" title=\"Promise 的实现\"></a>Promise 的实现</h4><p>之前有个工作上的前辈让我实现一个 Promise，叫我半个小时写出来一个有 resolve、then 功能的 Promise 类，结果我花了一晚上才实现出来。<br>代码如下：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PPromise</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">constructor</span>(asyncF) &#123;</div><div class=\"line\">        <span class=\"keyword\">this</span>.cb = <span class=\"literal\">null</span>; </div><div class=\"line\">        <span class=\"keyword\">this</span>.resolve = <span class=\"keyword\">this</span>.resolve.bind(<span class=\"keyword\">this</span>);</div><div class=\"line\">        <span class=\"keyword\">this</span>.then = <span class=\"keyword\">this</span>.then.bind(<span class=\"keyword\">this</span>);</div><div class=\"line\">        <span class=\"comment\">// convert resolve to async function calling</span></div><div class=\"line\">        asyncF.apply(<span class=\"literal\">null</span>, [<span class=\"function\">(<span class=\"params\">data</span>)=&gt;</span>setTimeout(<span class=\"function\"><span class=\"params\">()</span>=&gt;</span><span class=\"keyword\">this</span>.resolve(data),<span class=\"number\">0</span>)])</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    resolve(data) &#123;</div><div class=\"line\">            <span class=\"keyword\">var</span> cb = <span class=\"keyword\">this</span>.cb;</div><div class=\"line\">            <span class=\"keyword\">if</span> (cb!==<span class=\"literal\">null</span>)</div><div class=\"line\">                cb.apply(<span class=\"literal\">null</span>,[data]);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    then(cb) &#123;</div><div class=\"line\">        <span class=\"keyword\">var</span> newPromise = <span class=\"keyword\">new</span> PPromise(<span class=\"function\"><span class=\"params\">()</span>=&gt;</span><span class=\"literal\">null</span>);</div><div class=\"line\">        <span class=\"comment\">// link the next promise in the cb</span></div><div class=\"line\">        <span class=\"keyword\">this</span>.cb = <span class=\"function\">(<span class=\"params\">data</span>)=&gt;</span>&#123;</div><div class=\"line\">            <span class=\"keyword\">var</span> d = cb.apply(<span class=\"literal\">null</span>,[data]) </div><div class=\"line\">            newPromise.resolve(d); </div><div class=\"line\">        &#125;   </div><div class=\"line\">        <span class=\"keyword\">return</span> newPromise;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>实现的时候有两点需要注意的是：</p>\n<ol>\n<li>new Promise((resolve)=&gt;resolve(data)).then(console.log) 这个 resolve 调用是会被挂起的，这点也是这行代码 <code>asyncF.apply(null, [(data)=&gt;setTimeout(()=&gt;this.resolve(data),0)])</code> 的作用。</li>\n<li>then 返回的是一个什么？ 答案是还是一个 Promise，这里的实现是返回一个新的 Promise 然后在当前 Promise 的 callback 中调用新 Promise 的 resolve 方法。</li>\n</ol>\n","excerpt":"","more":"<h2 id=\"异步编程\"><a href=\"#异步编程\" class=\"headerlink\" title=\"异步编程\"></a>异步编程</h2><p>异步编程是 Javascript 的一大特色，因为 Javascript 是单线程工作，因此如果没有异步方式的话，基本上用户体验将会是无法忍受的。</p>\n<p>因此 Javascript 的语法对异步的看重使得其对异步编程用了比较大的力气去优化，本文将会对直到 ES7 的异步编程方式进行总结：</p>\n<ol>\n<li>Callback</li>\n<li>Promise</li>\n<li>Generator</li>\n<li>asyn + await</li>\n</ol>\n<p>但是在阐述这些方式之前，有一个概念需要事先阐述的是 Javascript 的事件循环。</p>\n<h3 id=\"事件循环-event-loop\"><a href=\"#事件循环-event-loop\" class=\"headerlink\" title=\"事件循环(event loop)\"></a>事件循环(event loop)</h3><p>event loop 是 Javascript 作为单线程语言完成非阻塞处理的重要机制，但其本身很容易理解，就是 Javascript 解释器的实现中会维护一个队列，task queue，当在执行语句中出现异步函数（比如 setTimeout）的时候，这样的函数是不会立即执行的，而是会被挂起，当空闲的时候，Javascript 解释器会处理这个异步操作，当处理完毕后，会在 task queue 里面插入一个事件，这个事件一般绑定了定义好的 callback。</p>\n<p>下面是一个最简单的一个例子是：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">setTimeout(<span class=\"function\"><span class=\"params\">()</span>=&gt;</span><span class=\"built_in\">console</span>.log(<span class=\"string\">'World'</span>), <span class=\"number\">0</span>)</div><div class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'Hello'</span>)</div><div class=\"line\"><span class=\"comment\">// output: \"Hello\\nWorld\"</span></div></pre></td></tr></table></figure>\n<p>结果是在意料之中的，这是因为当调用 setTimeout 函数时，你即使设置了 timeout 是 0ms，callback 函数的执行仍然会被放入 task queue 里，等到当前的 call stack 被清空后（这里停止的时机我还不是很清楚，可能是 call stack 清空，但也可能是其他判定条件，比如跑了指定长度的代码）再回来从 task queue 里面取出最新的 event 来处理，也就是执行回调。</p>\n<h3 id=\"异步编程方式\"><a href=\"#异步编程方式\" class=\"headerlink\" title=\"异步编程方式\"></a>异步编程方式</h3><p>有了 event loop 这个概念，那么对于操作异步函数就有帮助了，下面总结异步编程的方式，为了便于说明和调试，在需要使用异步函数的时候，本文都会使用 setTimeout 这个异步函数，其实本质上他和其他异步函数没什么区别，如果设置了 timeout 参数，就可看成其他异步函数的工作时间（这和 Java 中使用 Thread.sleep() 模拟线程运行是一个道理），下面会罗列目前 Javascript 的异步处理的几种常见的方式。</p>\n<p>由于 setTimeout 的书写方式和正常异步函数不一致，此外不想在每次写 setTimeout 的时候，总是设置 timeout，所以先将其包装一下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> afunc = <span class=\"function\">(<span class=\"params\">callback</span>) =&gt;</span> setTimeout(callback,<span class=\"number\">1000</span>)</div></pre></td></tr></table></figure>\n<p>此外，需要强调的是，这里所说的是异步编程方式，而不是异步函数，所谓异步编程方式（Asynchronized Programming)是指编写含有异步函数的代码的方式。</p>\n<h4 id=\"Callback\"><a href=\"#Callback\" class=\"headerlink\" title=\"Callback\"></a>Callback</h4><p>所谓的 Callback 是最原始的方式，也就说说直接将 callback 函数作为异步函数的参数传入，比如：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">afunc(<span class=\"function\"><span class=\"params\">()</span>=&gt;</span>&#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">\"Hello\"</span>);</div><div class=\"line\">    afunc(<span class=\"function\"><span class=\"params\">()</span>=&gt;</span>&#123;</div><div class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">\"World\"</span>);</div><div class=\"line\">        afunc(<span class=\"function\"><span class=\"params\">()</span>=&gt;</span><span class=\"built_in\">console</span>.log(<span class=\"string\">\"!\"</span>));</div><div class=\"line\">    &#125;)</div><div class=\"line\">&#125;)</div><div class=\"line\"><span class=\"comment\">//output: Hello\\nWorld\\n!</span></div></pre></td></tr></table></figure></p>\n<p>当然如果写成原来的样子，应该是：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">setTimeout(<span class=\"function\"><span class=\"params\">()</span>=&gt;</span>&#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">\"Hello\"</span>);</div><div class=\"line\">    setTimeout(<span class=\"function\"><span class=\"params\">()</span>=&gt;</span>&#123;</div><div class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">\"World\"</span>);</div><div class=\"line\">        setTimeout(<span class=\"function\"><span class=\"params\">()</span>=&gt;</span><span class=\"built_in\">console</span>.log(<span class=\"string\">'!'</span>),<span class=\"number\">1000</span>);</div><div class=\"line\">    &#125;,<span class=\"number\">1000</span>)</div><div class=\"line\">&#125;,<span class=\"number\">1000</span>)</div></pre></td></tr></table></figure>\n<p>(之后就会直接使用 afunc)</p>\n<p>可以发现这样写不很方便，而且很丑，于是在 ES6 中 Promise 应运而生。</p>\n<h4 id=\"Promise\"><a href=\"#Promise\" class=\"headerlink\" title=\"Promise\"></a>Promise</h4><p>Promise 会提供刚好的异步编程体验，同样的例子可以这么写：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve,reject</span>)=&gt;</span>&#123;</div><div class=\"line\">    afunc(<span class=\"function\"><span class=\"params\">()</span>=&gt;</span>&#123;<span class=\"built_in\">console</span>.log(<span class=\"string\">\"Hello\"</span>);resolve();&#125;)</div><div class=\"line\">&#125;).then(<span class=\"function\"><span class=\"params\">()</span>=&gt;</span><span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve</span>)=&gt;</span>afunc(<span class=\"function\"><span class=\"params\">()</span>=&gt;</span>&#123;<span class=\"built_in\">console</span>.log(<span class=\"string\">\"World\"</span>);resolve()&#125;)))</div><div class=\"line\">.then(<span class=\"function\"><span class=\"params\">()</span>=&gt;</span><span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve</span>)=&gt;</span>afunc(<span class=\"function\"><span class=\"params\">()</span>=&gt;</span>&#123;<span class=\"built_in\">console</span>.log(<span class=\"string\">\"!\"</span>);resolve()&#125;)))</div></pre></td></tr></table></figure></p>\n<p>这样就写成了链式的调用，但看上去非常繁琐，实际上我们可以将 afunc 封装一下：(为了不起冲突，命名成 afuncp)<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> afuncp = <span class=\"function\">(<span class=\"params\">callback</span>)=&gt;</span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve</span>)=&gt;</span>&#123;</div><div class=\"line\">        setTimeout(<span class=\"function\"><span class=\"params\">()</span>=&gt;</span>&#123;</div><div class=\"line\">            callback();resolve()</div><div class=\"line\">            &#125;, <span class=\"number\">1000</span>);</div><div class=\"line\">    &#125;)</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// then the statement can be expressed as:</span></div><div class=\"line\">afuncp(<span class=\"function\"><span class=\"params\">()</span>=&gt;</span><span class=\"built_in\">console</span>.log(<span class=\"string\">\"Hello\"</span>))</div><div class=\"line\">.then(<span class=\"function\"><span class=\"params\">()</span>=&gt;</span>afuncp(<span class=\"function\"><span class=\"params\">()</span>=&gt;</span><span class=\"built_in\">console</span>.log(<span class=\"string\">\"World\"</span>)))</div><div class=\"line\">.then(<span class=\"function\"><span class=\"params\">()</span>=&gt;</span>afuncp(<span class=\"function\"><span class=\"params\">()</span>=&gt;</span><span class=\"built_in\">console</span>.log(<span class=\"string\">\"!\"</span>)))</div></pre></td></tr></table></figure></p>\n<p>是不是简洁多了？<br>这里的改写实际上和 fs 中的 readFile 和 fs-readfile-promise 类似。</p>\n<p>但即使如此，还有更方便的写法。</p>\n<h4 id=\"Generator\"><a href=\"#Generator\" class=\"headerlink\" title=\"Generator\"></a>Generator</h4><p>如果能把异步编程的方式写成同步形式，那岂不是更加美观？</p>\n<p>Generator 应运而生。</p>\n<p>如果使用 Generator 的话，上面的写法将会变成：（注意这里使用的是 afuncp 而不是 afunc，当然使用 afunc 也是可以的，但是在下面要使用 Promise 的特性时就行不通了）<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span>* <span class=\"title\">genHelloWorld</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">    <span class=\"keyword\">yield</span> afuncp(<span class=\"function\"><span class=\"params\">()</span>=&gt;</span><span class=\"built_in\">console</span>.log(<span class=\"string\">\"Hello\"</span>));</div><div class=\"line\">    <span class=\"keyword\">yield</span> afuncp(<span class=\"function\"><span class=\"params\">()</span>=&gt;</span><span class=\"built_in\">console</span>.log(<span class=\"string\">\"World\"</span>));</div><div class=\"line\">    <span class=\"keyword\">yield</span> afuncp(<span class=\"function\"><span class=\"params\">()</span>=&gt;</span><span class=\"built_in\">console</span>.log(<span class=\"string\">\"!\"</span>));</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> g = genHelloWorld();</div><div class=\"line\">g.next()</div><div class=\"line\">g.next()</div><div class=\"line\">g.next()</div></pre></td></tr></table></figure></p>\n<p>但是这么写却是不对的，（你可以发现三个字符串是同时出现的）为什么呢？因为虽然通过利用 Generator 执行到下一个 yield 会停止的特性来做到了，这样顺序执行了三个异步操作，但是和之前两个异步操作不一样，因为我们之前写的异步操作是有先后关系的，后一个异步操作必须是在前一个异步操作完成之后才能执行的。</p>\n<p>也就是说 Generator 其实本身不支持异步操作的依赖执行（就是前一个先执行了，才能执行下一个），但是具备记录上次执行位置和状态使得它有可能完成异步编程方式，而其所欠缺的只是一个使得依赖执行能够运作的机制（姑且成为依赖运行器）。</p>\n<p>下面我们就来实现这个机制，这个机制的关键地方在于控制依赖，以及自动运行：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">genController</span>(<span class=\"params\">gen</span>)</span>&#123;</div><div class=\"line\">    <span class=\"keyword\">let</span> g = gen();</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">next</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">        <span class=\"keyword\">let</span> res = g.next();</div><div class=\"line\">        <span class=\"keyword\">if</span>(!res.done)&#123;</div><div class=\"line\">            res.value.then(next);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    next();</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// now let's run genHelloWorld</span></div><div class=\"line\">genContorller(genHelloWorld);</div></pre></td></tr></table></figure></p>\n<p>如果想在 production 环境中使用这样的机制，可以考虑 co 这个模块。</p>\n<h4 id=\"async-await\"><a href=\"#async-await\" class=\"headerlink\" title=\"async + await\"></a>async + await</h4><p>通过上面的例子可以看出来，Generator 虽然在表达异步编程上非常具有优势，但是容易发现需要自己定义依赖运行器，于是 async 函数应运而生，其本质还是 Generator 但是却自带了依赖运行器。<br>下面试试，async 的写法：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">genHelloWorld</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">await</span> afuncp(<span class=\"function\"><span class=\"params\">()</span>=&gt;</span><span class=\"built_in\">console</span>.log(<span class=\"string\">\"Hello\"</span>));</div><div class=\"line\">    <span class=\"keyword\">await</span> afuncp(<span class=\"function\"><span class=\"params\">()</span>=&gt;</span><span class=\"built_in\">console</span>.log(<span class=\"string\">\"World\"</span>));</div><div class=\"line\">    <span class=\"keyword\">await</span> afuncp(<span class=\"function\"><span class=\"params\">()</span>=&gt;</span><span class=\"built_in\">console</span>.log(<span class=\"string\">\"!\"</span>));</div><div class=\"line\">&#125;</div><div class=\"line\">genHelloWorld();</div></pre></td></tr></table></figure></p>\n<p>很完美！</p>\n<h4 id=\"Promise-的实现\"><a href=\"#Promise-的实现\" class=\"headerlink\" title=\"Promise 的实现\"></a>Promise 的实现</h4><p>之前有个工作上的前辈让我实现一个 Promise，叫我半个小时写出来一个有 resolve、then 功能的 Promise 类，结果我花了一晚上才实现出来。<br>代码如下：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PPromise</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">constructor</span>(asyncF) &#123;</div><div class=\"line\">        <span class=\"keyword\">this</span>.cb = <span class=\"literal\">null</span>; </div><div class=\"line\">        <span class=\"keyword\">this</span>.resolve = <span class=\"keyword\">this</span>.resolve.bind(<span class=\"keyword\">this</span>);</div><div class=\"line\">        <span class=\"keyword\">this</span>.then = <span class=\"keyword\">this</span>.then.bind(<span class=\"keyword\">this</span>);</div><div class=\"line\">        <span class=\"comment\">// convert resolve to async function calling</span></div><div class=\"line\">        asyncF.apply(<span class=\"literal\">null</span>, [<span class=\"function\">(<span class=\"params\">data</span>)=&gt;</span>setTimeout(<span class=\"function\"><span class=\"params\">()</span>=&gt;</span><span class=\"keyword\">this</span>.resolve(data),<span class=\"number\">0</span>)])</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    resolve(data) &#123;</div><div class=\"line\">            <span class=\"keyword\">var</span> cb = <span class=\"keyword\">this</span>.cb;</div><div class=\"line\">            <span class=\"keyword\">if</span> (cb!==<span class=\"literal\">null</span>)</div><div class=\"line\">                cb.apply(<span class=\"literal\">null</span>,[data]);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    then(cb) &#123;</div><div class=\"line\">        <span class=\"keyword\">var</span> newPromise = <span class=\"keyword\">new</span> PPromise(<span class=\"function\"><span class=\"params\">()</span>=&gt;</span><span class=\"literal\">null</span>);</div><div class=\"line\">        <span class=\"comment\">// link the next promise in the cb</span></div><div class=\"line\">        <span class=\"keyword\">this</span>.cb = <span class=\"function\">(<span class=\"params\">data</span>)=&gt;</span>&#123;</div><div class=\"line\">            <span class=\"keyword\">var</span> d = cb.apply(<span class=\"literal\">null</span>,[data]) </div><div class=\"line\">            newPromise.resolve(d); </div><div class=\"line\">        &#125;   </div><div class=\"line\">        <span class=\"keyword\">return</span> newPromise;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>实现的时候有两点需要注意的是：</p>\n<ol>\n<li>new Promise((resolve)=&gt;resolve(data)).then(console.log) 这个 resolve 调用是会被挂起的，这点也是这行代码 <code>asyncF.apply(null, [(data)=&gt;setTimeout(()=&gt;this.resolve(data),0)])</code> 的作用。</li>\n<li>then 返回的是一个什么？ 答案是还是一个 Promise，这里的实现是返回一个新的 Promise 然后在当前 Promise 的 callback 中调用新 Promise 的 resolve 方法。</li>\n</ol>\n"},{"title":"JSON-Encoding","date":"2017-12-17T15:42:44.000Z","_content":"\n## Problem\n问题是这样的：\n用 golang 需要存储一段 json 数据到数据库，为此先将这段数据 base64 了一下然后再存储到数据库，之后取出之后直接返回给了前端，前端先用 atob 做 base64 解码，之后调用 JSON.parse 尝试将数据恢复成 json，对于 ASCII 字符来说这样并不会有什么问题，然而对于含有 unicode 字符的时候就出现了乱码。\n\n此外，我同样用 python 将一段 json 数据变成 string，然后再使用 base64 encoding 存入数据，然而发现前端取这段数据又是正常的（即使其中含有中文）。\n\n## Conclusion\n因为自己的精力有限，我直接写出最终得到的结论：\n首先乱码的问题其实是 atob 这个 function 引起的，其实 base64 解码本身和 encoding 无关，然而 atob 这个 function 不仅做了 base64 decode 的工作，与此同时它还将 decode 结果转换成一个 javascript 的 string，**然而**你会发现这个字符串解析的过程其实是不识别 unicode 的，因此直接出现了乱码。\n\n那为什么 python 的 base64 encoding 就没有问题呢？\n其实按照上面所述，出现乱码和 base64 根本毫无关系，golang 和 python 产生区别原因只是在于对于 unicode 的 string，golang 的 JSON.Marshal 默认用 UTF-8 编码存储，也就是说如果 JSON 数据如下：\n```javascript\n{name: \"魏\"}\n```\n\n经过 golang 处理会得到如下的编码（ASCII 码用字符表示，其他用数据表示）：\n```javascript\n'{' 'n' 'a' 'm' 'e' ':' '\"' '\\xe9' '\\xad' '\\x8f' '\"' '}'\n```\n\n这个是合法的 JSON 格式，这个对于 atob 也无法解析，因为 atob 不认识 UTF-8，而 python 却不是这样编码的：\n```\n'{' 'n' 'a' 'm' 'e' ':' '\"' '\\' 'u' '9' 'B' '4' 'F' '\"' '}'\n```\n\n这里注意 9B4F 是 '魏' 的 unicode point 参考这个 [link](http://unicode.scarfboy.com/?s=%E9%AD%8F)，如果想知道为什么用 4 个十六进制的数据就可以表达一个 unicode，可以参考这个 [link](https://en.wikipedia.org/wiki/Unicode#Code_point_planes_and_blocks)\n这个也是 JSON 的合法表达，可以参考这个 [link](http://json.org/)， 并且因为也是因为这样编码不会存在任何非 ASCII 码，从而导致 atob 之后仍然可以被 JSON.parse 解析成正确的 javascript  string 对象。\n\n## Solution\n解决方案用两种，封装一个 base64 decoding 的 function，可以在 atob 的基础上做一下 UTF-8 的支持，这段 function 可以从这个 [link](https://developer.mozilla.org/en-US/docs/Web/API/WindowBase64/Base64_encoding_and_decoding) 找到:\n```javascript\nfunction b64DecodeUnicode(str) {\n    // Going backwards: from bytestream, to percent-encoding, to original string.\n    return decodeURIComponent(atob(str).split('').map(function(c) {\n        return '%' + ('00' + c.charCodeAt(0).toString(16)).slice(-2);\n    }).join(''));\n}\n```\n另一种解决方案就是在后端做 base64 的 decoding 工作。\n","source":"_posts/JSON-Encoding.md","raw":"---\ntitle: JSON-Encoding\ndate: 2017-12-17 23:42:44\ntags: Encoding\n---\n\n## Problem\n问题是这样的：\n用 golang 需要存储一段 json 数据到数据库，为此先将这段数据 base64 了一下然后再存储到数据库，之后取出之后直接返回给了前端，前端先用 atob 做 base64 解码，之后调用 JSON.parse 尝试将数据恢复成 json，对于 ASCII 字符来说这样并不会有什么问题，然而对于含有 unicode 字符的时候就出现了乱码。\n\n此外，我同样用 python 将一段 json 数据变成 string，然后再使用 base64 encoding 存入数据，然而发现前端取这段数据又是正常的（即使其中含有中文）。\n\n## Conclusion\n因为自己的精力有限，我直接写出最终得到的结论：\n首先乱码的问题其实是 atob 这个 function 引起的，其实 base64 解码本身和 encoding 无关，然而 atob 这个 function 不仅做了 base64 decode 的工作，与此同时它还将 decode 结果转换成一个 javascript 的 string，**然而**你会发现这个字符串解析的过程其实是不识别 unicode 的，因此直接出现了乱码。\n\n那为什么 python 的 base64 encoding 就没有问题呢？\n其实按照上面所述，出现乱码和 base64 根本毫无关系，golang 和 python 产生区别原因只是在于对于 unicode 的 string，golang 的 JSON.Marshal 默认用 UTF-8 编码存储，也就是说如果 JSON 数据如下：\n```javascript\n{name: \"魏\"}\n```\n\n经过 golang 处理会得到如下的编码（ASCII 码用字符表示，其他用数据表示）：\n```javascript\n'{' 'n' 'a' 'm' 'e' ':' '\"' '\\xe9' '\\xad' '\\x8f' '\"' '}'\n```\n\n这个是合法的 JSON 格式，这个对于 atob 也无法解析，因为 atob 不认识 UTF-8，而 python 却不是这样编码的：\n```\n'{' 'n' 'a' 'm' 'e' ':' '\"' '\\' 'u' '9' 'B' '4' 'F' '\"' '}'\n```\n\n这里注意 9B4F 是 '魏' 的 unicode point 参考这个 [link](http://unicode.scarfboy.com/?s=%E9%AD%8F)，如果想知道为什么用 4 个十六进制的数据就可以表达一个 unicode，可以参考这个 [link](https://en.wikipedia.org/wiki/Unicode#Code_point_planes_and_blocks)\n这个也是 JSON 的合法表达，可以参考这个 [link](http://json.org/)， 并且因为也是因为这样编码不会存在任何非 ASCII 码，从而导致 atob 之后仍然可以被 JSON.parse 解析成正确的 javascript  string 对象。\n\n## Solution\n解决方案用两种，封装一个 base64 decoding 的 function，可以在 atob 的基础上做一下 UTF-8 的支持，这段 function 可以从这个 [link](https://developer.mozilla.org/en-US/docs/Web/API/WindowBase64/Base64_encoding_and_decoding) 找到:\n```javascript\nfunction b64DecodeUnicode(str) {\n    // Going backwards: from bytestream, to percent-encoding, to original string.\n    return decodeURIComponent(atob(str).split('').map(function(c) {\n        return '%' + ('00' + c.charCodeAt(0).toString(16)).slice(-2);\n    }).join(''));\n}\n```\n另一种解决方案就是在后端做 base64 的 decoding 工作。\n","slug":"JSON-Encoding","published":1,"updated":"2017-12-19T18:17:40.798Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjbdyo31i000hnf8j0t03rcl9","content":"<h2 id=\"Problem\"><a href=\"#Problem\" class=\"headerlink\" title=\"Problem\"></a>Problem</h2><p>问题是这样的：<br>用 golang 需要存储一段 json 数据到数据库，为此先将这段数据 base64 了一下然后再存储到数据库，之后取出之后直接返回给了前端，前端先用 atob 做 base64 解码，之后调用 JSON.parse 尝试将数据恢复成 json，对于 ASCII 字符来说这样并不会有什么问题，然而对于含有 unicode 字符的时候就出现了乱码。</p>\n<p>此外，我同样用 python 将一段 json 数据变成 string，然后再使用 base64 encoding 存入数据，然而发现前端取这段数据又是正常的（即使其中含有中文）。</p>\n<h2 id=\"Conclusion\"><a href=\"#Conclusion\" class=\"headerlink\" title=\"Conclusion\"></a>Conclusion</h2><p>因为自己的精力有限，我直接写出最终得到的结论：<br>首先乱码的问题其实是 atob 这个 function 引起的，其实 base64 解码本身和 encoding 无关，然而 atob 这个 function 不仅做了 base64 decode 的工作，与此同时它还将 decode 结果转换成一个 javascript 的 string，<strong>然而</strong>你会发现这个字符串解析的过程其实是不识别 unicode 的，因此直接出现了乱码。</p>\n<p>那为什么 python 的 base64 encoding 就没有问题呢？<br>其实按照上面所述，出现乱码和 base64 根本毫无关系，golang 和 python 产生区别原因只是在于对于 unicode 的 string，golang 的 JSON.Marshal 默认用 UTF-8 编码存储，也就是说如果 JSON 数据如下：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123;<span class=\"attr\">name</span>: <span class=\"string\">\"魏\"</span>&#125;</div></pre></td></tr></table></figure></p>\n<p>经过 golang 处理会得到如下的编码（ASCII 码用字符表示，其他用数据表示）：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"string\">'&#123;'</span> <span class=\"string\">'n'</span> <span class=\"string\">'a'</span> <span class=\"string\">'m'</span> <span class=\"string\">'e'</span> <span class=\"string\">':'</span> <span class=\"string\">'\"'</span> <span class=\"string\">'\\xe9'</span> <span class=\"string\">'\\xad'</span> <span class=\"string\">'\\x8f'</span> <span class=\"string\">'\"'</span> <span class=\"string\">'&#125;'</span></div></pre></td></tr></table></figure></p>\n<p>这个是合法的 JSON 格式，这个对于 atob 也无法解析，因为 atob 不认识 UTF-8，而 python 却不是这样编码的：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">&apos;&#123;&apos; &apos;n&apos; &apos;a&apos; &apos;m&apos; &apos;e&apos; &apos;:&apos; &apos;&quot;&apos; &apos;\\&apos; &apos;u&apos; &apos;9&apos; &apos;B&apos; &apos;4&apos; &apos;F&apos; &apos;&quot;&apos; &apos;&#125;&apos;</div></pre></td></tr></table></figure></p>\n<p>这里注意 9B4F 是 ‘魏’ 的 unicode point 参考这个 <a href=\"http://unicode.scarfboy.com/?s=%E9%AD%8F\" target=\"_blank\" rel=\"external\">link</a>，如果想知道为什么用 4 个十六进制的数据就可以表达一个 unicode，可以参考这个 <a href=\"https://en.wikipedia.org/wiki/Unicode#Code_point_planes_and_blocks\" target=\"_blank\" rel=\"external\">link</a><br>这个也是 JSON 的合法表达，可以参考这个 <a href=\"http://json.org/\" target=\"_blank\" rel=\"external\">link</a>， 并且因为也是因为这样编码不会存在任何非 ASCII 码，从而导致 atob 之后仍然可以被 JSON.parse 解析成正确的 javascript  string 对象。</p>\n<h2 id=\"Solution\"><a href=\"#Solution\" class=\"headerlink\" title=\"Solution\"></a>Solution</h2><p>解决方案用两种，封装一个 base64 decoding 的 function，可以在 atob 的基础上做一下 UTF-8 的支持，这段 function 可以从这个 <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/WindowBase64/Base64_encoding_and_decoding\" target=\"_blank\" rel=\"external\">link</a> 找到:<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">b64DecodeUnicode</span>(<span class=\"params\">str</span>) </span>&#123;</div><div class=\"line\">    <span class=\"comment\">// Going backwards: from bytestream, to percent-encoding, to original string.</span></div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">decodeURIComponent</span>(atob(str).split(<span class=\"string\">''</span>).map(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">c</span>) </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">'%'</span> + (<span class=\"string\">'00'</span> + c.charCodeAt(<span class=\"number\">0</span>).toString(<span class=\"number\">16</span>)).slice(<span class=\"number\">-2</span>);</div><div class=\"line\">    &#125;).join(<span class=\"string\">''</span>));</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>另一种解决方案就是在后端做 base64 的 decoding 工作。</p>\n","excerpt":"","more":"<h2 id=\"Problem\"><a href=\"#Problem\" class=\"headerlink\" title=\"Problem\"></a>Problem</h2><p>问题是这样的：<br>用 golang 需要存储一段 json 数据到数据库，为此先将这段数据 base64 了一下然后再存储到数据库，之后取出之后直接返回给了前端，前端先用 atob 做 base64 解码，之后调用 JSON.parse 尝试将数据恢复成 json，对于 ASCII 字符来说这样并不会有什么问题，然而对于含有 unicode 字符的时候就出现了乱码。</p>\n<p>此外，我同样用 python 将一段 json 数据变成 string，然后再使用 base64 encoding 存入数据，然而发现前端取这段数据又是正常的（即使其中含有中文）。</p>\n<h2 id=\"Conclusion\"><a href=\"#Conclusion\" class=\"headerlink\" title=\"Conclusion\"></a>Conclusion</h2><p>因为自己的精力有限，我直接写出最终得到的结论：<br>首先乱码的问题其实是 atob 这个 function 引起的，其实 base64 解码本身和 encoding 无关，然而 atob 这个 function 不仅做了 base64 decode 的工作，与此同时它还将 decode 结果转换成一个 javascript 的 string，<strong>然而</strong>你会发现这个字符串解析的过程其实是不识别 unicode 的，因此直接出现了乱码。</p>\n<p>那为什么 python 的 base64 encoding 就没有问题呢？<br>其实按照上面所述，出现乱码和 base64 根本毫无关系，golang 和 python 产生区别原因只是在于对于 unicode 的 string，golang 的 JSON.Marshal 默认用 UTF-8 编码存储，也就是说如果 JSON 数据如下：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123;<span class=\"attr\">name</span>: <span class=\"string\">\"魏\"</span>&#125;</div></pre></td></tr></table></figure></p>\n<p>经过 golang 处理会得到如下的编码（ASCII 码用字符表示，其他用数据表示）：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"string\">'&#123;'</span> <span class=\"string\">'n'</span> <span class=\"string\">'a'</span> <span class=\"string\">'m'</span> <span class=\"string\">'e'</span> <span class=\"string\">':'</span> <span class=\"string\">'\"'</span> <span class=\"string\">'\\xe9'</span> <span class=\"string\">'\\xad'</span> <span class=\"string\">'\\x8f'</span> <span class=\"string\">'\"'</span> <span class=\"string\">'&#125;'</span></div></pre></td></tr></table></figure></p>\n<p>这个是合法的 JSON 格式，这个对于 atob 也无法解析，因为 atob 不认识 UTF-8，而 python 却不是这样编码的：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">&apos;&#123;&apos; &apos;n&apos; &apos;a&apos; &apos;m&apos; &apos;e&apos; &apos;:&apos; &apos;&quot;&apos; &apos;\\&apos; &apos;u&apos; &apos;9&apos; &apos;B&apos; &apos;4&apos; &apos;F&apos; &apos;&quot;&apos; &apos;&#125;&apos;</div></pre></td></tr></table></figure></p>\n<p>这里注意 9B4F 是 ‘魏’ 的 unicode point 参考这个 <a href=\"http://unicode.scarfboy.com/?s=%E9%AD%8F\">link</a>，如果想知道为什么用 4 个十六进制的数据就可以表达一个 unicode，可以参考这个 <a href=\"https://en.wikipedia.org/wiki/Unicode#Code_point_planes_and_blocks\">link</a><br>这个也是 JSON 的合法表达，可以参考这个 <a href=\"http://json.org/\">link</a>， 并且因为也是因为这样编码不会存在任何非 ASCII 码，从而导致 atob 之后仍然可以被 JSON.parse 解析成正确的 javascript  string 对象。</p>\n<h2 id=\"Solution\"><a href=\"#Solution\" class=\"headerlink\" title=\"Solution\"></a>Solution</h2><p>解决方案用两种，封装一个 base64 decoding 的 function，可以在 atob 的基础上做一下 UTF-8 的支持，这段 function 可以从这个 <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/WindowBase64/Base64_encoding_and_decoding\">link</a> 找到:<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">b64DecodeUnicode</span>(<span class=\"params\">str</span>) </span>&#123;</div><div class=\"line\">    <span class=\"comment\">// Going backwards: from bytestream, to percent-encoding, to original string.</span></div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">decodeURIComponent</span>(atob(str).split(<span class=\"string\">''</span>).map(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">c</span>) </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">'%'</span> + (<span class=\"string\">'00'</span> + c.charCodeAt(<span class=\"number\">0</span>).toString(<span class=\"number\">16</span>)).slice(<span class=\"number\">-2</span>);</div><div class=\"line\">    &#125;).join(<span class=\"string\">''</span>));</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>另一种解决方案就是在后端做 base64 的 decoding 工作。</p>\n"},{"title":"Deploy Hexo Blogs on GitHub Pages","_content":"\n### Create a GitHub Page\nFollow the steps on this [page](https://pages.github.com/) to create a personal website, say `https://username.github.io`.\n\n### Install Hexo\nAfter `git` and `nodejs` installed, get the Hexo installed by:\n``` bash\nnpm install -g hexo-cli\n```\nTry to get what you are confused about from this [page](https://hexo.io/docs/).\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to `https://username.github.io`\nBefore the deploying, change the deploy settings:\n```\n# Deployment\n## Docs: https://hexo.io/docs/deployment.html\ndeploy:\n  type: git\n  repository: git@github.com:username/username.github.io.git\n  branch: master\n```\n\nAfter the setting, the git deploy helper should be installed by:\n``` bash\nnpm install hexo-deployer-git --save\n```\n\nDeploying:\n``` bash\n$ hexo deploy\n```\nMore info: [Deployment](https://hexo.io/docs/deployment.html)\n","source":"_posts/Hexo-With-GitHub.md","raw":"---\ntitle: Deploy Hexo Blogs on GitHub Pages  \n---\n\n### Create a GitHub Page\nFollow the steps on this [page](https://pages.github.com/) to create a personal website, say `https://username.github.io`.\n\n### Install Hexo\nAfter `git` and `nodejs` installed, get the Hexo installed by:\n``` bash\nnpm install -g hexo-cli\n```\nTry to get what you are confused about from this [page](https://hexo.io/docs/).\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to `https://username.github.io`\nBefore the deploying, change the deploy settings:\n```\n# Deployment\n## Docs: https://hexo.io/docs/deployment.html\ndeploy:\n  type: git\n  repository: git@github.com:username/username.github.io.git\n  branch: master\n```\n\nAfter the setting, the git deploy helper should be installed by:\n``` bash\nnpm install hexo-deployer-git --save\n```\n\nDeploying:\n``` bash\n$ hexo deploy\n```\nMore info: [Deployment](https://hexo.io/docs/deployment.html)\n","slug":"Hexo-With-GitHub","published":1,"date":"2017-02-14T15:46:34.000Z","updated":"2017-07-30T08:06:56.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjbdyo31j000inf8jf866i6w0","content":"<h3 id=\"Create-a-GitHub-Page\"><a href=\"#Create-a-GitHub-Page\" class=\"headerlink\" title=\"Create a GitHub Page\"></a>Create a GitHub Page</h3><p>Follow the steps on this <a href=\"https://pages.github.com/\" target=\"_blank\" rel=\"external\">page</a> to create a personal website, say <code>https://username.github.io</code>.</p>\n<h3 id=\"Install-Hexo\"><a href=\"#Install-Hexo\" class=\"headerlink\" title=\"Install Hexo\"></a>Install Hexo</h3><p>After <code>git</code> and <code>nodejs</code> installed, get the Hexo installed by:<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">npm install -g hexo-cli</div></pre></td></tr></table></figure></p>\n<p>Try to get what you are confused about from this <a href=\"https://hexo.io/docs/\" target=\"_blank\" rel=\"external\">page</a>.</p>\n<h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ hexo new <span class=\"string\">\"My New Post\"</span></div></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\" target=\"_blank\" rel=\"external\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ hexo server</div></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/server.html\" target=\"_blank\" rel=\"external\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ hexo generate</div></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\" target=\"_blank\" rel=\"external\">Generating</a></p>\n<h3 id=\"Deploy-to-https-username-github-io\"><a href=\"#Deploy-to-https-username-github-io\" class=\"headerlink\" title=\"Deploy to https://username.github.io\"></a>Deploy to <code>https://username.github.io</code></h3><p>Before the deploying, change the deploy settings:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"># Deployment</div><div class=\"line\">## Docs: https://hexo.io/docs/deployment.html</div><div class=\"line\">deploy:</div><div class=\"line\">  type: git</div><div class=\"line\">  repository: git@github.com:username/username.github.io.git</div><div class=\"line\">  branch: master</div></pre></td></tr></table></figure></p>\n<p>After the setting, the git deploy helper should be installed by:<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">npm install hexo-deployer-git --save</div></pre></td></tr></table></figure></p>\n<p>Deploying:<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ hexo deploy</div></pre></td></tr></table></figure></p>\n<p>More info: <a href=\"https://hexo.io/docs/deployment.html\" target=\"_blank\" rel=\"external\">Deployment</a></p>\n","excerpt":"","more":"<h3 id=\"Create-a-GitHub-Page\"><a href=\"#Create-a-GitHub-Page\" class=\"headerlink\" title=\"Create a GitHub Page\"></a>Create a GitHub Page</h3><p>Follow the steps on this <a href=\"https://pages.github.com/\">page</a> to create a personal website, say <code>https://username.github.io</code>.</p>\n<h3 id=\"Install-Hexo\"><a href=\"#Install-Hexo\" class=\"headerlink\" title=\"Install Hexo\"></a>Install Hexo</h3><p>After <code>git</code> and <code>nodejs</code> installed, get the Hexo installed by:<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">npm install -g hexo-cli</div></pre></td></tr></table></figure></p>\n<p>Try to get what you are confused about from this <a href=\"https://hexo.io/docs/\">page</a>.</p>\n<h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ hexo new <span class=\"string\">\"My New Post\"</span></div></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ hexo server</div></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/server.html\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ hexo generate</div></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\">Generating</a></p>\n<h3 id=\"Deploy-to-https-username-github-io\"><a href=\"#Deploy-to-https-username-github-io\" class=\"headerlink\" title=\"Deploy to https://username.github.io\"></a>Deploy to <code>https://username.github.io</code></h3><p>Before the deploying, change the deploy settings:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"># Deployment</div><div class=\"line\">## Docs: https://hexo.io/docs/deployment.html</div><div class=\"line\">deploy:</div><div class=\"line\">  type: git</div><div class=\"line\">  repository: git@github.com:username/username.github.io.git</div><div class=\"line\">  branch: master</div></pre></td></tr></table></figure></p>\n<p>After the setting, the git deploy helper should be installed by:<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">npm install hexo-deployer-git --save</div></pre></td></tr></table></figure></p>\n<p>Deploying:<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ hexo deploy</div></pre></td></tr></table></figure></p>\n<p>More info: <a href=\"https://hexo.io/docs/deployment.html\">Deployment</a></p>\n"},{"title":"Git-实践","date":"2017-03-05T06:51:47.000Z","_content":"### 1. git merge 时发生了什么? 如何处理？\n\n发生 conflict 的情况有两种：一种是不同 branch 之间的 merge 时发生，还有一种是同一 branch 上由于同步开发，出现相同父节点上出现了两次不同的 commit（实际上只有本人和远程的差异，再具体点说就是合作者与自己拥有同一个父节点，并且在我提交下一个 commit 之前已经提交了一个 commit，这时候我发现无论我 pull 还是 push 都会出现 conflicts ）。\n\n对于这种情况，首先我想强调的是，不必紧张，git 是会保存所有的东西的，你们所有的更改都会保存下来。\n\n```\nA -----> B1(sb else's commit) ---> C\n|                                  | \n\\                                  /\n ------> B2(your commit)----------\n```\n\n首先，你得了解你的 repo 处在什么状态——实际上是处于一个 merge 状态，这种状态你需要处理所有 unmerged file。\n\n然后，你有两个选择，手动消除 unmerged 的地方，然后使用 `git add <file>` 来表示 merge 完毕，之后就可以提交新的 commit（需要注意的是这时的 commit 是一个 merge 类型的结点，它有两个父节点，这点下面会因此而出现意外情况）。在提交新的 commit 之前，你还可以使用 `git merge --abort` 来取消这次 merge。\n\n但是如果出现这样的情况，merge 完毕后发现自己的 merge 做的有问题，不必担心，由上面的图可以知道，之前的冲突结点都保存着，那么该如何恢复呢？\n\n很简单，通过 revert 恢复是最安全的方式（注意，revert 和 reset 不一样，reset 是恢复到参数指定的 commit 的状态，而 revert 是回滚指定 commit 的状态到上一次 commit）\n\n但是如果你使用 `git revert <B2's SHA>` 会出 conflicts，这是因为你理解错了 revert 的含义（通过 git revert --abort 可以回滚）,而出现 conflicts 的原因是一般 revert 只会用作 `revert HEAD`，因此 git 知道回滚到当前 commit 的上一次 commit的方法，没有其他选择，若是回滚到指定版本的话，git 并不知道如何跨 commit 回滚，因此必须要人来手动 merge 一下。\n\n在这里的情况我们得使用 `git revert HEAD`，但是即使如此，仍然不对，而且是出错，这是因为，回滚 C 的时候，发现 C 有两个父节点，因此必须指定回滚到哪一个结点才行，那么如何知道相应父节点的编号呢？通过 `git log` 即可查看父节点的顺序，有了顺序使用 `git revert HEAD -m <number>` 来回滚到指定的父节点（注意编号从 1 开始）。\n\n### 2. arc 如何结合 phabricator 使用？\nphabricator 是一种工程代码管理集成工具，arc 是进行 phabricator 上的 code review 的重要工具，那么如何使用 arc 呢？\n#### 安装 arc\n参考 [这里](https://secure.phabricator.com/book/phabricator/article/arcanist_quick_start/)\n#### 一次 feature/bug 的提交过程\n1. `git pull` 保证 master 分支最新\n2. `git checkout -b feature/xxx` 进行代码开发\n3. `git add <files needed to be committed>; git commit -m \"...\"` commit 代码\n4. `arc diff` 这个时候提交 diff，根据提示需要指定 diff 的 base，如果你只是 commit 过一次，那么一般使用 HEAD^ 作为 base（这也是默认选项）如果觉得不放心的话，最好使用 `arc diff --preiview` 来确认一下自己这次 diff 的提交是否出错\n5. 代码 review 时出现需要改动的地方，那么改动代码后，使用 `git commit --amend` 来进行 commit，这样就会保证始终只有一次 commit，这样的话，就会方便每次 arc diff 的时候，不必指定 base\n6. review 通过以后 `arc land` 会将该分支 merge 到 master\n\n#### 如果 land diff 的时候发现 master 已经更新，并且 merge 有冲突\n1. 本地 merge 一次（解决冲突、add file、commit）\n2. 再次更新 diff，将 base 设为最新的 master head，等待 review\n更好的解决办法是：\n1. `git checkout master`\n2. `git pull`\n3. `git checkout <diff-branch>`\n4. `git rebase master`\n5. 若是出现冲突，merge 完毕后，可以使用 `rebase --continue`\n6. `arc diff HEAD^`\n\n### 3. git 如何切换到任意结点下的某一个文件？\n`git checkout <commit-hash> path/to/file`","source":"_posts/Git-实践.md","raw":"---\ntitle: Git-实践\ndate: 2017-03-05 14:51:47\ntags: git\n---\n### 1. git merge 时发生了什么? 如何处理？\n\n发生 conflict 的情况有两种：一种是不同 branch 之间的 merge 时发生，还有一种是同一 branch 上由于同步开发，出现相同父节点上出现了两次不同的 commit（实际上只有本人和远程的差异，再具体点说就是合作者与自己拥有同一个父节点，并且在我提交下一个 commit 之前已经提交了一个 commit，这时候我发现无论我 pull 还是 push 都会出现 conflicts ）。\n\n对于这种情况，首先我想强调的是，不必紧张，git 是会保存所有的东西的，你们所有的更改都会保存下来。\n\n```\nA -----> B1(sb else's commit) ---> C\n|                                  | \n\\                                  /\n ------> B2(your commit)----------\n```\n\n首先，你得了解你的 repo 处在什么状态——实际上是处于一个 merge 状态，这种状态你需要处理所有 unmerged file。\n\n然后，你有两个选择，手动消除 unmerged 的地方，然后使用 `git add <file>` 来表示 merge 完毕，之后就可以提交新的 commit（需要注意的是这时的 commit 是一个 merge 类型的结点，它有两个父节点，这点下面会因此而出现意外情况）。在提交新的 commit 之前，你还可以使用 `git merge --abort` 来取消这次 merge。\n\n但是如果出现这样的情况，merge 完毕后发现自己的 merge 做的有问题，不必担心，由上面的图可以知道，之前的冲突结点都保存着，那么该如何恢复呢？\n\n很简单，通过 revert 恢复是最安全的方式（注意，revert 和 reset 不一样，reset 是恢复到参数指定的 commit 的状态，而 revert 是回滚指定 commit 的状态到上一次 commit）\n\n但是如果你使用 `git revert <B2's SHA>` 会出 conflicts，这是因为你理解错了 revert 的含义（通过 git revert --abort 可以回滚）,而出现 conflicts 的原因是一般 revert 只会用作 `revert HEAD`，因此 git 知道回滚到当前 commit 的上一次 commit的方法，没有其他选择，若是回滚到指定版本的话，git 并不知道如何跨 commit 回滚，因此必须要人来手动 merge 一下。\n\n在这里的情况我们得使用 `git revert HEAD`，但是即使如此，仍然不对，而且是出错，这是因为，回滚 C 的时候，发现 C 有两个父节点，因此必须指定回滚到哪一个结点才行，那么如何知道相应父节点的编号呢？通过 `git log` 即可查看父节点的顺序，有了顺序使用 `git revert HEAD -m <number>` 来回滚到指定的父节点（注意编号从 1 开始）。\n\n### 2. arc 如何结合 phabricator 使用？\nphabricator 是一种工程代码管理集成工具，arc 是进行 phabricator 上的 code review 的重要工具，那么如何使用 arc 呢？\n#### 安装 arc\n参考 [这里](https://secure.phabricator.com/book/phabricator/article/arcanist_quick_start/)\n#### 一次 feature/bug 的提交过程\n1. `git pull` 保证 master 分支最新\n2. `git checkout -b feature/xxx` 进行代码开发\n3. `git add <files needed to be committed>; git commit -m \"...\"` commit 代码\n4. `arc diff` 这个时候提交 diff，根据提示需要指定 diff 的 base，如果你只是 commit 过一次，那么一般使用 HEAD^ 作为 base（这也是默认选项）如果觉得不放心的话，最好使用 `arc diff --preiview` 来确认一下自己这次 diff 的提交是否出错\n5. 代码 review 时出现需要改动的地方，那么改动代码后，使用 `git commit --amend` 来进行 commit，这样就会保证始终只有一次 commit，这样的话，就会方便每次 arc diff 的时候，不必指定 base\n6. review 通过以后 `arc land` 会将该分支 merge 到 master\n\n#### 如果 land diff 的时候发现 master 已经更新，并且 merge 有冲突\n1. 本地 merge 一次（解决冲突、add file、commit）\n2. 再次更新 diff，将 base 设为最新的 master head，等待 review\n更好的解决办法是：\n1. `git checkout master`\n2. `git pull`\n3. `git checkout <diff-branch>`\n4. `git rebase master`\n5. 若是出现冲突，merge 完毕后，可以使用 `rebase --continue`\n6. `arc diff HEAD^`\n\n### 3. git 如何切换到任意结点下的某一个文件？\n`git checkout <commit-hash> path/to/file`","slug":"Git-实践","published":1,"updated":"2017-05-20T17:18:32.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjbdyo31l000lnf8jzei3d06v","content":"<h3 id=\"1-git-merge-时发生了什么-如何处理？\"><a href=\"#1-git-merge-时发生了什么-如何处理？\" class=\"headerlink\" title=\"1. git merge 时发生了什么? 如何处理？\"></a>1. git merge 时发生了什么? 如何处理？</h3><p>发生 conflict 的情况有两种：一种是不同 branch 之间的 merge 时发生，还有一种是同一 branch 上由于同步开发，出现相同父节点上出现了两次不同的 commit（实际上只有本人和远程的差异，再具体点说就是合作者与自己拥有同一个父节点，并且在我提交下一个 commit 之前已经提交了一个 commit，这时候我发现无论我 pull 还是 push 都会出现 conflicts ）。</p>\n<p>对于这种情况，首先我想强调的是，不必紧张，git 是会保存所有的东西的，你们所有的更改都会保存下来。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">A -----&gt; B1(sb else&apos;s commit) ---&gt; C</div><div class=\"line\">|                                  | </div><div class=\"line\">\\                                  /</div><div class=\"line\"> ------&gt; B2(your commit)----------</div></pre></td></tr></table></figure>\n<p>首先，你得了解你的 repo 处在什么状态——实际上是处于一个 merge 状态，这种状态你需要处理所有 unmerged file。</p>\n<p>然后，你有两个选择，手动消除 unmerged 的地方，然后使用 <code>git add &lt;file&gt;</code> 来表示 merge 完毕，之后就可以提交新的 commit（需要注意的是这时的 commit 是一个 merge 类型的结点，它有两个父节点，这点下面会因此而出现意外情况）。在提交新的 commit 之前，你还可以使用 <code>git merge --abort</code> 来取消这次 merge。</p>\n<p>但是如果出现这样的情况，merge 完毕后发现自己的 merge 做的有问题，不必担心，由上面的图可以知道，之前的冲突结点都保存着，那么该如何恢复呢？</p>\n<p>很简单，通过 revert 恢复是最安全的方式（注意，revert 和 reset 不一样，reset 是恢复到参数指定的 commit 的状态，而 revert 是回滚指定 commit 的状态到上一次 commit）</p>\n<p>但是如果你使用 <code>git revert &lt;B2&#39;s SHA&gt;</code> 会出 conflicts，这是因为你理解错了 revert 的含义（通过 git revert –abort 可以回滚）,而出现 conflicts 的原因是一般 revert 只会用作 <code>revert HEAD</code>，因此 git 知道回滚到当前 commit 的上一次 commit的方法，没有其他选择，若是回滚到指定版本的话，git 并不知道如何跨 commit 回滚，因此必须要人来手动 merge 一下。</p>\n<p>在这里的情况我们得使用 <code>git revert HEAD</code>，但是即使如此，仍然不对，而且是出错，这是因为，回滚 C 的时候，发现 C 有两个父节点，因此必须指定回滚到哪一个结点才行，那么如何知道相应父节点的编号呢？通过 <code>git log</code> 即可查看父节点的顺序，有了顺序使用 <code>git revert HEAD -m &lt;number&gt;</code> 来回滚到指定的父节点（注意编号从 1 开始）。</p>\n<h3 id=\"2-arc-如何结合-phabricator-使用？\"><a href=\"#2-arc-如何结合-phabricator-使用？\" class=\"headerlink\" title=\"2. arc 如何结合 phabricator 使用？\"></a>2. arc 如何结合 phabricator 使用？</h3><p>phabricator 是一种工程代码管理集成工具，arc 是进行 phabricator 上的 code review 的重要工具，那么如何使用 arc 呢？</p>\n<h4 id=\"安装-arc\"><a href=\"#安装-arc\" class=\"headerlink\" title=\"安装 arc\"></a>安装 arc</h4><p>参考 <a href=\"https://secure.phabricator.com/book/phabricator/article/arcanist_quick_start/\" target=\"_blank\" rel=\"external\">这里</a></p>\n<h4 id=\"一次-feature-bug-的提交过程\"><a href=\"#一次-feature-bug-的提交过程\" class=\"headerlink\" title=\"一次 feature/bug 的提交过程\"></a>一次 feature/bug 的提交过程</h4><ol>\n<li><code>git pull</code> 保证 master 分支最新</li>\n<li><code>git checkout -b feature/xxx</code> 进行代码开发</li>\n<li><code>git add &lt;files needed to be committed&gt;; git commit -m &quot;...&quot;</code> commit 代码</li>\n<li><code>arc diff</code> 这个时候提交 diff，根据提示需要指定 diff 的 base，如果你只是 commit 过一次，那么一般使用 HEAD^ 作为 base（这也是默认选项）如果觉得不放心的话，最好使用 <code>arc diff --preiview</code> 来确认一下自己这次 diff 的提交是否出错</li>\n<li>代码 review 时出现需要改动的地方，那么改动代码后，使用 <code>git commit --amend</code> 来进行 commit，这样就会保证始终只有一次 commit，这样的话，就会方便每次 arc diff 的时候，不必指定 base</li>\n<li>review 通过以后 <code>arc land</code> 会将该分支 merge 到 master</li>\n</ol>\n<h4 id=\"如果-land-diff-的时候发现-master-已经更新，并且-merge-有冲突\"><a href=\"#如果-land-diff-的时候发现-master-已经更新，并且-merge-有冲突\" class=\"headerlink\" title=\"如果 land diff 的时候发现 master 已经更新，并且 merge 有冲突\"></a>如果 land diff 的时候发现 master 已经更新，并且 merge 有冲突</h4><ol>\n<li>本地 merge 一次（解决冲突、add file、commit）</li>\n<li>再次更新 diff，将 base 设为最新的 master head，等待 review<br>更好的解决办法是：</li>\n<li><code>git checkout master</code></li>\n<li><code>git pull</code></li>\n<li><code>git checkout &lt;diff-branch&gt;</code></li>\n<li><code>git rebase master</code></li>\n<li>若是出现冲突，merge 完毕后，可以使用 <code>rebase --continue</code></li>\n<li><code>arc diff HEAD^</code></li>\n</ol>\n<h3 id=\"3-git-如何切换到任意结点下的某一个文件？\"><a href=\"#3-git-如何切换到任意结点下的某一个文件？\" class=\"headerlink\" title=\"3. git 如何切换到任意结点下的某一个文件？\"></a>3. git 如何切换到任意结点下的某一个文件？</h3><p><code>git checkout &lt;commit-hash&gt; path/to/file</code></p>\n","excerpt":"","more":"<h3 id=\"1-git-merge-时发生了什么-如何处理？\"><a href=\"#1-git-merge-时发生了什么-如何处理？\" class=\"headerlink\" title=\"1. git merge 时发生了什么? 如何处理？\"></a>1. git merge 时发生了什么? 如何处理？</h3><p>发生 conflict 的情况有两种：一种是不同 branch 之间的 merge 时发生，还有一种是同一 branch 上由于同步开发，出现相同父节点上出现了两次不同的 commit（实际上只有本人和远程的差异，再具体点说就是合作者与自己拥有同一个父节点，并且在我提交下一个 commit 之前已经提交了一个 commit，这时候我发现无论我 pull 还是 push 都会出现 conflicts ）。</p>\n<p>对于这种情况，首先我想强调的是，不必紧张，git 是会保存所有的东西的，你们所有的更改都会保存下来。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">A -----&gt; B1(sb else&apos;s commit) ---&gt; C</div><div class=\"line\">|                                  | </div><div class=\"line\">\\                                  /</div><div class=\"line\"> ------&gt; B2(your commit)----------</div></pre></td></tr></table></figure>\n<p>首先，你得了解你的 repo 处在什么状态——实际上是处于一个 merge 状态，这种状态你需要处理所有 unmerged file。</p>\n<p>然后，你有两个选择，手动消除 unmerged 的地方，然后使用 <code>git add &lt;file&gt;</code> 来表示 merge 完毕，之后就可以提交新的 commit（需要注意的是这时的 commit 是一个 merge 类型的结点，它有两个父节点，这点下面会因此而出现意外情况）。在提交新的 commit 之前，你还可以使用 <code>git merge --abort</code> 来取消这次 merge。</p>\n<p>但是如果出现这样的情况，merge 完毕后发现自己的 merge 做的有问题，不必担心，由上面的图可以知道，之前的冲突结点都保存着，那么该如何恢复呢？</p>\n<p>很简单，通过 revert 恢复是最安全的方式（注意，revert 和 reset 不一样，reset 是恢复到参数指定的 commit 的状态，而 revert 是回滚指定 commit 的状态到上一次 commit）</p>\n<p>但是如果你使用 <code>git revert &lt;B2&#39;s SHA&gt;</code> 会出 conflicts，这是因为你理解错了 revert 的含义（通过 git revert –abort 可以回滚）,而出现 conflicts 的原因是一般 revert 只会用作 <code>revert HEAD</code>，因此 git 知道回滚到当前 commit 的上一次 commit的方法，没有其他选择，若是回滚到指定版本的话，git 并不知道如何跨 commit 回滚，因此必须要人来手动 merge 一下。</p>\n<p>在这里的情况我们得使用 <code>git revert HEAD</code>，但是即使如此，仍然不对，而且是出错，这是因为，回滚 C 的时候，发现 C 有两个父节点，因此必须指定回滚到哪一个结点才行，那么如何知道相应父节点的编号呢？通过 <code>git log</code> 即可查看父节点的顺序，有了顺序使用 <code>git revert HEAD -m &lt;number&gt;</code> 来回滚到指定的父节点（注意编号从 1 开始）。</p>\n<h3 id=\"2-arc-如何结合-phabricator-使用？\"><a href=\"#2-arc-如何结合-phabricator-使用？\" class=\"headerlink\" title=\"2. arc 如何结合 phabricator 使用？\"></a>2. arc 如何结合 phabricator 使用？</h3><p>phabricator 是一种工程代码管理集成工具，arc 是进行 phabricator 上的 code review 的重要工具，那么如何使用 arc 呢？</p>\n<h4 id=\"安装-arc\"><a href=\"#安装-arc\" class=\"headerlink\" title=\"安装 arc\"></a>安装 arc</h4><p>参考 <a href=\"https://secure.phabricator.com/book/phabricator/article/arcanist_quick_start/\">这里</a></p>\n<h4 id=\"一次-feature-bug-的提交过程\"><a href=\"#一次-feature-bug-的提交过程\" class=\"headerlink\" title=\"一次 feature/bug 的提交过程\"></a>一次 feature/bug 的提交过程</h4><ol>\n<li><code>git pull</code> 保证 master 分支最新</li>\n<li><code>git checkout -b feature/xxx</code> 进行代码开发</li>\n<li><code>git add &lt;files needed to be committed&gt;; git commit -m &quot;...&quot;</code> commit 代码</li>\n<li><code>arc diff</code> 这个时候提交 diff，根据提示需要指定 diff 的 base，如果你只是 commit 过一次，那么一般使用 HEAD^ 作为 base（这也是默认选项）如果觉得不放心的话，最好使用 <code>arc diff --preiview</code> 来确认一下自己这次 diff 的提交是否出错</li>\n<li>代码 review 时出现需要改动的地方，那么改动代码后，使用 <code>git commit --amend</code> 来进行 commit，这样就会保证始终只有一次 commit，这样的话，就会方便每次 arc diff 的时候，不必指定 base</li>\n<li>review 通过以后 <code>arc land</code> 会将该分支 merge 到 master</li>\n</ol>\n<h4 id=\"如果-land-diff-的时候发现-master-已经更新，并且-merge-有冲突\"><a href=\"#如果-land-diff-的时候发现-master-已经更新，并且-merge-有冲突\" class=\"headerlink\" title=\"如果 land diff 的时候发现 master 已经更新，并且 merge 有冲突\"></a>如果 land diff 的时候发现 master 已经更新，并且 merge 有冲突</h4><ol>\n<li>本地 merge 一次（解决冲突、add file、commit）</li>\n<li>再次更新 diff，将 base 设为最新的 master head，等待 review<br>更好的解决办法是：</li>\n<li><code>git checkout master</code></li>\n<li><code>git pull</code></li>\n<li><code>git checkout &lt;diff-branch&gt;</code></li>\n<li><code>git rebase master</code></li>\n<li>若是出现冲突，merge 完毕后，可以使用 <code>rebase --continue</code></li>\n<li><code>arc diff HEAD^</code></li>\n</ol>\n<h3 id=\"3-git-如何切换到任意结点下的某一个文件？\"><a href=\"#3-git-如何切换到任意结点下的某一个文件？\" class=\"headerlink\" title=\"3. git 如何切换到任意结点下的某一个文件？\"></a>3. git 如何切换到任意结点下的某一个文件？</h3><p><code>git checkout &lt;commit-hash&gt; path/to/file</code></p>\n"},{"title":"React-Redux 入门坑总结","date":"2017-02-27T01:13:14.000Z","_content":"## Abstract\n我这个星期基本上在工作之余都在研究 React 和 Redux，我之前对这部分知识完全没用接触过，期间遇到很多坑，尤其是在想自己能够完成一个独立的比较小的 React App 的时候，发现出现了很多意想不到的事情，下面是我这个星期的总结。\n\n注意，本文不是 React 和 Redux 的 tutorial，按道理讲，官方文档已经写的比较好了，但是对于新手来说可能不是很容易上手，因此，如果你看完了官方文档，在自己动手实现自己的第一个 React App 的时候，如果先看一下本文可能会得到一些启示，从而绕过一些坑。\n\n文章分为两个部分，第一部分是关于 React 的内容，第二部分是关于 Redux 的内容（需要注意的是，React 和 Redux 不是必须一起使用的，实际上本文写的时候，Redux 已经有式微的趋势了）。\n\n文中使用的原本 code 来自于 facebook 的 React 项目的 [tutorial](https://codepen.io/ericnakagawa/pen/vXpjwZ?editors=0010)。\n\n## 阅读之前最好先看过……\n1. React 的 [tutorial](https://codepen.io/ericnakagawa/pen/vXpjwZ?editors=0010)。\n2. webpack 的简单介绍\n3. Redux 的基础部分\n\n## React\n首先对 React 的特点做一个总结，React 是 facebook 推出的一个前端框架（注意前端不一定是指 web），其最大的特点在于，**视图组件化**。\n\n我两年前（2015）的时候，还没有接触到 React 这种东西，那时候我只知道 Dom 编程，当时就感觉，开发前端页面非常繁琐，尤其是再结合 PHP 使用，其主要问题就是 JS 代码就是脚本，复用性不高，视图的响应逻辑逻辑很混乱，而 React 很好地解决了这个问题，通过将想要构建的视图直接分解成具有层级的组件，这样就可以大大提高视图组件的复用性，此外，每一个组件都具备相应的 props 和 state，前者是组件的属性值，后者是组件的状态，两者的区别就在于：前者是由父组件提供的组件属性（所以在组件内部是只读的），后者是私有的组件属性（用于保存这个组件的状态，从而实现自更新）:\n\n```javascript\n// 这是 ReactComponent.js 的一段代码\nReactComponent.prototype.setState = function (partialState, callback) {\n  !(typeof partialState === 'object' || typeof partialState === 'function' || partialState == null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'setState(...): takes an object of state variables to update or a function which returns an object of state variables.') : _prodInvariant('85') : void 0;\n  this.updater.enqueueSetState(this, partialState);\n  if (callback) {\n    this.updater.enqueueCallback(this, callback, 'setState');\n  }\n};\n```\n\n其中最重要的一段代码就是   `this.updater.enqueueSetState(this, partialState);`，可以看出来，当使用了 setState 后，便会将新的状态放入 updater 的更新队列中。\n\n\n### 搭建起一个可以构建 React App 的本地环境\n之所以会提到这一点，是因为 facebook 提供的 [starter code](https://codepen.io/ericnakagawa/pen/vXpjwZ?editors=0010) 是在线的版本，当你把代码复制到本地的时候，根本就用不了。\n\n这时候必须使用到一个方便的工具了，叫做 [webpack](https://webpack.github.io/)，这是一个打包 js 代码的工具，通过简单的配置，便可以使用其将所有的 js 代码打包起来，比如叫做 _bundle.js_，然后直接在 _index.html_ 中引用这个脚本。\n\n但是，仅仅如此还不够，因为上述代码使用的是 ES6 + JSX 的形式，因此必须还得配置好 webpack 的配置文件 _webpack.config.js_，在 webpack 这个工具之中有 loader 这个概念，loader 的意思其实就是解析其他形式的语言到 js 的形式，由第三方提供，在这里我们使用 babel 这个 loader，此外必须安装 babel 的另外两个 loader：\n```bash\nnpm i babel-loader babel-preset-es2015 babel-preset-react babel-core -S\n```\n然后要在 _webpack.config.js_ 里配置好：\n\n```javascript\nmodule.exports = {\n    entry:'./index.js',\n    output:{\n        filename:\"bundle.js\",\n        path:path.resolve(__dirname,'dist')\n    },\n    module:{\n        loaders:[\n          {\n            test: /(\\.jsx|\\.js)$/,\n            loaders: 'babel-loader',\n            query:{\n                presets:['es2015','react','stage-0']\n            },\n          },\n          {\n            test: /\\.scss$/,\n            loaders: ['style', 'css', 'sass'],\n          },\n          {\n            test: /\\.html$/,\n            loader: 'file?name=[name].[ext]'\n          },\n        ],\n\n  }\n};\n```\n\n### 使用 JSX 的注意点\nJSX 其实就是将 html 的标签引入进了 js 中，但是在使用上也有必须要注意的问题，我是第一次使用 JSX，因此就遇到了一些问题。\n1. JSX 本质上就是一个 expression，这一点很重要，因此它可以被 return 返回，可以用数组存储\n2. JSX 的 tag 必须成对出现，这一点和 xml 的语法很像，不可省略（若是省略，首 tag 之后的内容会被认为全在 tag 之内）\n2. JSX 中虽然可以通过 `{var}` 这样的方式，来加入上下文的出现的变量，但是在 JSX 的 tag 之间不能出现 expression 以外的 statement，这里之所以会提到这一点是因为想说不要试图通过在 tag 之间加入 for 循环来进行相同类型的 element 的生成（想要达到这一效果，可以使用数组来存储中间的 element，然后最后一起提供给 render 函数\n\n### React 组件的书写\n写 React 组件有两种方法：class 继承 或者 提供一个 function。\n\n在使用 class 继承的时候，有一点必须要注意，class 是 ES6 的语法，因此必须使用 babel-ex2015 这个 loader 来解析，此外根据 es6 的语法，在 class 内部使用方法的时候，必须通过 `this` 来引用。\n\n在使用 function 的时候，一种简洁的方法便是使用 arrow function，但是需要注意的是 arrow function 的时候，提供的参数只有一个，就是用来赋给 props 的，code 里面的例子：\n\n```javascript\nconst Board = ({nextPlayer,squares,handleClick})=>{...}\n```\n\n### javascript 的自动插入 semicolon (ASI, auto semicolon insertion)\n这一点是我这次过程中才发现的，真的让我很无力，关于这一点有很详细的文档记载，可以参考这个 SO [问答](http://stackoverflow.com/questions/2846283/what-are-the-rules-for-javascripts-automatic-semicolon-insertion-asi)，在这里我只想强调一点，就是关于 return 的 ASI：\n\n```javascript\nreturn\n{\n    a:1,\n    b:2\n}\n// will be transformed to:\nreturn ;\n{\n    a:1,\n    b:2,\n};\n```\n\n## Redux\nRedux 的设计思想在我看来还是很先进的，在这里先以我的理解做一下简单的总结。\n\n虽然说 React 和 Redux 和 React 没有必然联系，但是在我看来，没有类似于 React 的这种**视图组件化**的思想的话，那么 Redux 就是空中楼阁，Redux 的设计理念是对 React 的一大应用，它所做的事情其实就是将**视图的响应逻辑集中化**，React 组件在设计庞大之后，将会出现难以避免的视图响应逻辑复杂（复杂之处在于不同组件之间的交互），这也是为什么 React 的官方文档里总是提倡 **lift up state**，通过这样来避免小组件之间的通信。\n\n在 Redux 的设计之外，有一个重要的理念，就是 Component 和 Container 的设计思想，这也是 Redux 官方文档推荐的一篇 [post](https://medium.com/@dan_abramov/smart-and-dumb-components-7ca2f9a7c7d0)。这和 React 的 **lift up state** 思想很相似，其实在最后所有的状态都集中到的那个 Component 就是这里的 Container，因此 Redux 在与 React 的结合使用中，你会发现，Redux 实际上将 state 从 Component 中抽离了，当然也并非存在于 Container，而是存在于全局，Container 只是访问全局 state 的地方而已，那么 UI 的更新又是如何做的呢？Redux 通过 state 的改变，然后将这种改变映射到 props 中去，然后会导致相应的 Component UI 发生变化。\n\n### Redux 的流程\n官方文档的 tutorial 写的很好了，但是我看完之后，真正轮到我实现的时候又变得懵逼了，究其原因其实在于不理解 Redux 的控制流程。\n\n因此 Redux 的入门坑就在于如何正确理解它的控制流程，下面是我的理解：\nstate 作为存储于全局的变量，只要在一开始正确设置了 store，那么在这个 App 的内部任何地方都可以访问到 App 的状态（通过 `store.getState()`）\n\nreducer 实际上就是做了一件事，描述了整个状态机，(previous state, action) => (next state)\n\n在设计的时候，要分别实现相应的 Component 和 Container，其中 Container 中不要涉及 state 的访问，它对 Redux 是一无所知的，而 Container 负责做两件事，分别对应着两个个需要实现的函数：mapStateToProps 和 mapDispatchToProps。\n\n其实这两个函数的名字可以任意取，但是这样取可以表明他们的含义，从名字可以看出它们都是给 Component 的 props 赋值，但赋值的对象和目的有所区别，前者负责描述 (current state) => (current props)，也就是在状态改变的时候如何更新 UI；后者做的是将 dispatch 动作赋值给 Component 的 props 中的事件属性，比如 onclick ，一般只会执行一次，用于触发 action，从而依据自定义的 reducer 推动 state 的更新。\n\n因此，整个触发流程便是含有 dispatch action 的 onClick 被触发了，然后 reducer 指明了下一个 state，然后 mapStateToProps 被调用了，然后 Component 被重新绘制了。\n","source":"_posts/React-Redux-入门坑总结.md","raw":"---\ntitle: React-Redux 入门坑总结\ndate: 2017-02-27 09:13:14\ntags: Web\n---\n## Abstract\n我这个星期基本上在工作之余都在研究 React 和 Redux，我之前对这部分知识完全没用接触过，期间遇到很多坑，尤其是在想自己能够完成一个独立的比较小的 React App 的时候，发现出现了很多意想不到的事情，下面是我这个星期的总结。\n\n注意，本文不是 React 和 Redux 的 tutorial，按道理讲，官方文档已经写的比较好了，但是对于新手来说可能不是很容易上手，因此，如果你看完了官方文档，在自己动手实现自己的第一个 React App 的时候，如果先看一下本文可能会得到一些启示，从而绕过一些坑。\n\n文章分为两个部分，第一部分是关于 React 的内容，第二部分是关于 Redux 的内容（需要注意的是，React 和 Redux 不是必须一起使用的，实际上本文写的时候，Redux 已经有式微的趋势了）。\n\n文中使用的原本 code 来自于 facebook 的 React 项目的 [tutorial](https://codepen.io/ericnakagawa/pen/vXpjwZ?editors=0010)。\n\n## 阅读之前最好先看过……\n1. React 的 [tutorial](https://codepen.io/ericnakagawa/pen/vXpjwZ?editors=0010)。\n2. webpack 的简单介绍\n3. Redux 的基础部分\n\n## React\n首先对 React 的特点做一个总结，React 是 facebook 推出的一个前端框架（注意前端不一定是指 web），其最大的特点在于，**视图组件化**。\n\n我两年前（2015）的时候，还没有接触到 React 这种东西，那时候我只知道 Dom 编程，当时就感觉，开发前端页面非常繁琐，尤其是再结合 PHP 使用，其主要问题就是 JS 代码就是脚本，复用性不高，视图的响应逻辑逻辑很混乱，而 React 很好地解决了这个问题，通过将想要构建的视图直接分解成具有层级的组件，这样就可以大大提高视图组件的复用性，此外，每一个组件都具备相应的 props 和 state，前者是组件的属性值，后者是组件的状态，两者的区别就在于：前者是由父组件提供的组件属性（所以在组件内部是只读的），后者是私有的组件属性（用于保存这个组件的状态，从而实现自更新）:\n\n```javascript\n// 这是 ReactComponent.js 的一段代码\nReactComponent.prototype.setState = function (partialState, callback) {\n  !(typeof partialState === 'object' || typeof partialState === 'function' || partialState == null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'setState(...): takes an object of state variables to update or a function which returns an object of state variables.') : _prodInvariant('85') : void 0;\n  this.updater.enqueueSetState(this, partialState);\n  if (callback) {\n    this.updater.enqueueCallback(this, callback, 'setState');\n  }\n};\n```\n\n其中最重要的一段代码就是   `this.updater.enqueueSetState(this, partialState);`，可以看出来，当使用了 setState 后，便会将新的状态放入 updater 的更新队列中。\n\n\n### 搭建起一个可以构建 React App 的本地环境\n之所以会提到这一点，是因为 facebook 提供的 [starter code](https://codepen.io/ericnakagawa/pen/vXpjwZ?editors=0010) 是在线的版本，当你把代码复制到本地的时候，根本就用不了。\n\n这时候必须使用到一个方便的工具了，叫做 [webpack](https://webpack.github.io/)，这是一个打包 js 代码的工具，通过简单的配置，便可以使用其将所有的 js 代码打包起来，比如叫做 _bundle.js_，然后直接在 _index.html_ 中引用这个脚本。\n\n但是，仅仅如此还不够，因为上述代码使用的是 ES6 + JSX 的形式，因此必须还得配置好 webpack 的配置文件 _webpack.config.js_，在 webpack 这个工具之中有 loader 这个概念，loader 的意思其实就是解析其他形式的语言到 js 的形式，由第三方提供，在这里我们使用 babel 这个 loader，此外必须安装 babel 的另外两个 loader：\n```bash\nnpm i babel-loader babel-preset-es2015 babel-preset-react babel-core -S\n```\n然后要在 _webpack.config.js_ 里配置好：\n\n```javascript\nmodule.exports = {\n    entry:'./index.js',\n    output:{\n        filename:\"bundle.js\",\n        path:path.resolve(__dirname,'dist')\n    },\n    module:{\n        loaders:[\n          {\n            test: /(\\.jsx|\\.js)$/,\n            loaders: 'babel-loader',\n            query:{\n                presets:['es2015','react','stage-0']\n            },\n          },\n          {\n            test: /\\.scss$/,\n            loaders: ['style', 'css', 'sass'],\n          },\n          {\n            test: /\\.html$/,\n            loader: 'file?name=[name].[ext]'\n          },\n        ],\n\n  }\n};\n```\n\n### 使用 JSX 的注意点\nJSX 其实就是将 html 的标签引入进了 js 中，但是在使用上也有必须要注意的问题，我是第一次使用 JSX，因此就遇到了一些问题。\n1. JSX 本质上就是一个 expression，这一点很重要，因此它可以被 return 返回，可以用数组存储\n2. JSX 的 tag 必须成对出现，这一点和 xml 的语法很像，不可省略（若是省略，首 tag 之后的内容会被认为全在 tag 之内）\n2. JSX 中虽然可以通过 `{var}` 这样的方式，来加入上下文的出现的变量，但是在 JSX 的 tag 之间不能出现 expression 以外的 statement，这里之所以会提到这一点是因为想说不要试图通过在 tag 之间加入 for 循环来进行相同类型的 element 的生成（想要达到这一效果，可以使用数组来存储中间的 element，然后最后一起提供给 render 函数\n\n### React 组件的书写\n写 React 组件有两种方法：class 继承 或者 提供一个 function。\n\n在使用 class 继承的时候，有一点必须要注意，class 是 ES6 的语法，因此必须使用 babel-ex2015 这个 loader 来解析，此外根据 es6 的语法，在 class 内部使用方法的时候，必须通过 `this` 来引用。\n\n在使用 function 的时候，一种简洁的方法便是使用 arrow function，但是需要注意的是 arrow function 的时候，提供的参数只有一个，就是用来赋给 props 的，code 里面的例子：\n\n```javascript\nconst Board = ({nextPlayer,squares,handleClick})=>{...}\n```\n\n### javascript 的自动插入 semicolon (ASI, auto semicolon insertion)\n这一点是我这次过程中才发现的，真的让我很无力，关于这一点有很详细的文档记载，可以参考这个 SO [问答](http://stackoverflow.com/questions/2846283/what-are-the-rules-for-javascripts-automatic-semicolon-insertion-asi)，在这里我只想强调一点，就是关于 return 的 ASI：\n\n```javascript\nreturn\n{\n    a:1,\n    b:2\n}\n// will be transformed to:\nreturn ;\n{\n    a:1,\n    b:2,\n};\n```\n\n## Redux\nRedux 的设计思想在我看来还是很先进的，在这里先以我的理解做一下简单的总结。\n\n虽然说 React 和 Redux 和 React 没有必然联系，但是在我看来，没有类似于 React 的这种**视图组件化**的思想的话，那么 Redux 就是空中楼阁，Redux 的设计理念是对 React 的一大应用，它所做的事情其实就是将**视图的响应逻辑集中化**，React 组件在设计庞大之后，将会出现难以避免的视图响应逻辑复杂（复杂之处在于不同组件之间的交互），这也是为什么 React 的官方文档里总是提倡 **lift up state**，通过这样来避免小组件之间的通信。\n\n在 Redux 的设计之外，有一个重要的理念，就是 Component 和 Container 的设计思想，这也是 Redux 官方文档推荐的一篇 [post](https://medium.com/@dan_abramov/smart-and-dumb-components-7ca2f9a7c7d0)。这和 React 的 **lift up state** 思想很相似，其实在最后所有的状态都集中到的那个 Component 就是这里的 Container，因此 Redux 在与 React 的结合使用中，你会发现，Redux 实际上将 state 从 Component 中抽离了，当然也并非存在于 Container，而是存在于全局，Container 只是访问全局 state 的地方而已，那么 UI 的更新又是如何做的呢？Redux 通过 state 的改变，然后将这种改变映射到 props 中去，然后会导致相应的 Component UI 发生变化。\n\n### Redux 的流程\n官方文档的 tutorial 写的很好了，但是我看完之后，真正轮到我实现的时候又变得懵逼了，究其原因其实在于不理解 Redux 的控制流程。\n\n因此 Redux 的入门坑就在于如何正确理解它的控制流程，下面是我的理解：\nstate 作为存储于全局的变量，只要在一开始正确设置了 store，那么在这个 App 的内部任何地方都可以访问到 App 的状态（通过 `store.getState()`）\n\nreducer 实际上就是做了一件事，描述了整个状态机，(previous state, action) => (next state)\n\n在设计的时候，要分别实现相应的 Component 和 Container，其中 Container 中不要涉及 state 的访问，它对 Redux 是一无所知的，而 Container 负责做两件事，分别对应着两个个需要实现的函数：mapStateToProps 和 mapDispatchToProps。\n\n其实这两个函数的名字可以任意取，但是这样取可以表明他们的含义，从名字可以看出它们都是给 Component 的 props 赋值，但赋值的对象和目的有所区别，前者负责描述 (current state) => (current props)，也就是在状态改变的时候如何更新 UI；后者做的是将 dispatch 动作赋值给 Component 的 props 中的事件属性，比如 onclick ，一般只会执行一次，用于触发 action，从而依据自定义的 reducer 推动 state 的更新。\n\n因此，整个触发流程便是含有 dispatch action 的 onClick 被触发了，然后 reducer 指明了下一个 state，然后 mapStateToProps 被调用了，然后 Component 被重新绘制了。\n","slug":"React-Redux-入门坑总结","published":1,"updated":"2017-07-16T01:45:09.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjbdyo31m000mnf8jfncyupkg","content":"<h2 id=\"Abstract\"><a href=\"#Abstract\" class=\"headerlink\" title=\"Abstract\"></a>Abstract</h2><p>我这个星期基本上在工作之余都在研究 React 和 Redux，我之前对这部分知识完全没用接触过，期间遇到很多坑，尤其是在想自己能够完成一个独立的比较小的 React App 的时候，发现出现了很多意想不到的事情，下面是我这个星期的总结。</p>\n<p>注意，本文不是 React 和 Redux 的 tutorial，按道理讲，官方文档已经写的比较好了，但是对于新手来说可能不是很容易上手，因此，如果你看完了官方文档，在自己动手实现自己的第一个 React App 的时候，如果先看一下本文可能会得到一些启示，从而绕过一些坑。</p>\n<p>文章分为两个部分，第一部分是关于 React 的内容，第二部分是关于 Redux 的内容（需要注意的是，React 和 Redux 不是必须一起使用的，实际上本文写的时候，Redux 已经有式微的趋势了）。</p>\n<p>文中使用的原本 code 来自于 facebook 的 React 项目的 <a href=\"https://codepen.io/ericnakagawa/pen/vXpjwZ?editors=0010\" target=\"_blank\" rel=\"external\">tutorial</a>。</p>\n<h2 id=\"阅读之前最好先看过……\"><a href=\"#阅读之前最好先看过……\" class=\"headerlink\" title=\"阅读之前最好先看过……\"></a>阅读之前最好先看过……</h2><ol>\n<li>React 的 <a href=\"https://codepen.io/ericnakagawa/pen/vXpjwZ?editors=0010\" target=\"_blank\" rel=\"external\">tutorial</a>。</li>\n<li>webpack 的简单介绍</li>\n<li>Redux 的基础部分</li>\n</ol>\n<h2 id=\"React\"><a href=\"#React\" class=\"headerlink\" title=\"React\"></a>React</h2><p>首先对 React 的特点做一个总结，React 是 facebook 推出的一个前端框架（注意前端不一定是指 web），其最大的特点在于，<strong>视图组件化</strong>。</p>\n<p>我两年前（2015）的时候，还没有接触到 React 这种东西，那时候我只知道 Dom 编程，当时就感觉，开发前端页面非常繁琐，尤其是再结合 PHP 使用，其主要问题就是 JS 代码就是脚本，复用性不高，视图的响应逻辑逻辑很混乱，而 React 很好地解决了这个问题，通过将想要构建的视图直接分解成具有层级的组件，这样就可以大大提高视图组件的复用性，此外，每一个组件都具备相应的 props 和 state，前者是组件的属性值，后者是组件的状态，两者的区别就在于：前者是由父组件提供的组件属性（所以在组件内部是只读的），后者是私有的组件属性（用于保存这个组件的状态，从而实现自更新）:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 这是 ReactComponent.js 的一段代码</span></div><div class=\"line\">ReactComponent.prototype.setState = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">partialState, callback</span>) </span>&#123;</div><div class=\"line\">  !(<span class=\"keyword\">typeof</span> partialState === <span class=\"string\">'object'</span> || <span class=\"keyword\">typeof</span> partialState === <span class=\"string\">'function'</span> || partialState == <span class=\"literal\">null</span>) ? process.env.NODE_ENV !== <span class=\"string\">'production'</span> ? invariant(<span class=\"literal\">false</span>, <span class=\"string\">'setState(...): takes an object of state variables to update or a function which returns an object of state variables.'</span>) : _prodInvariant(<span class=\"string\">'85'</span>) : <span class=\"keyword\">void</span> <span class=\"number\">0</span>;</div><div class=\"line\">  <span class=\"keyword\">this</span>.updater.enqueueSetState(<span class=\"keyword\">this</span>, partialState);</div><div class=\"line\">  <span class=\"keyword\">if</span> (callback) &#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>.updater.enqueueCallback(<span class=\"keyword\">this</span>, callback, <span class=\"string\">'setState'</span>);</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>其中最重要的一段代码就是   <code>this.updater.enqueueSetState(this, partialState);</code>，可以看出来，当使用了 setState 后，便会将新的状态放入 updater 的更新队列中。</p>\n<h3 id=\"搭建起一个可以构建-React-App-的本地环境\"><a href=\"#搭建起一个可以构建-React-App-的本地环境\" class=\"headerlink\" title=\"搭建起一个可以构建 React App 的本地环境\"></a>搭建起一个可以构建 React App 的本地环境</h3><p>之所以会提到这一点，是因为 facebook 提供的 <a href=\"https://codepen.io/ericnakagawa/pen/vXpjwZ?editors=0010\" target=\"_blank\" rel=\"external\">starter code</a> 是在线的版本，当你把代码复制到本地的时候，根本就用不了。</p>\n<p>这时候必须使用到一个方便的工具了，叫做 <a href=\"https://webpack.github.io/\" target=\"_blank\" rel=\"external\">webpack</a>，这是一个打包 js 代码的工具，通过简单的配置，便可以使用其将所有的 js 代码打包起来，比如叫做 <em>bundle.js</em>，然后直接在 <em>index.html</em> 中引用这个脚本。</p>\n<p>但是，仅仅如此还不够，因为上述代码使用的是 ES6 + JSX 的形式，因此必须还得配置好 webpack 的配置文件 <em>webpack.config.js</em>，在 webpack 这个工具之中有 loader 这个概念，loader 的意思其实就是解析其他形式的语言到 js 的形式，由第三方提供，在这里我们使用 babel 这个 loader，此外必须安装 babel 的另外两个 loader：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">npm i babel-loader babel-preset-es2015 babel-preset-react babel-core -S</div></pre></td></tr></table></figure></p>\n<p>然后要在 <em>webpack.config.js</em> 里配置好：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</div><div class=\"line\">    <span class=\"attr\">entry</span>:<span class=\"string\">'./index.js'</span>,</div><div class=\"line\">    <span class=\"attr\">output</span>:&#123;</div><div class=\"line\">        <span class=\"attr\">filename</span>:<span class=\"string\">\"bundle.js\"</span>,</div><div class=\"line\">        <span class=\"attr\">path</span>:path.resolve(__dirname,<span class=\"string\">'dist'</span>)</div><div class=\"line\">    &#125;,</div><div class=\"line\">    <span class=\"attr\">module</span>:&#123;</div><div class=\"line\">        <span class=\"attr\">loaders</span>:[</div><div class=\"line\">          &#123;</div><div class=\"line\">            <span class=\"attr\">test</span>: <span class=\"regexp\">/(\\.jsx|\\.js)$/</span>,</div><div class=\"line\">            <span class=\"attr\">loaders</span>: <span class=\"string\">'babel-loader'</span>,</div><div class=\"line\">            <span class=\"attr\">query</span>:&#123;</div><div class=\"line\">                <span class=\"attr\">presets</span>:[<span class=\"string\">'es2015'</span>,<span class=\"string\">'react'</span>,<span class=\"string\">'stage-0'</span>]</div><div class=\"line\">            &#125;,</div><div class=\"line\">          &#125;,</div><div class=\"line\">          &#123;</div><div class=\"line\">            <span class=\"attr\">test</span>: <span class=\"regexp\">/\\.scss$/</span>,</div><div class=\"line\">            <span class=\"attr\">loaders</span>: [<span class=\"string\">'style'</span>, <span class=\"string\">'css'</span>, <span class=\"string\">'sass'</span>],</div><div class=\"line\">          &#125;,</div><div class=\"line\">          &#123;</div><div class=\"line\">            <span class=\"attr\">test</span>: <span class=\"regexp\">/\\.html$/</span>,</div><div class=\"line\">            <span class=\"attr\">loader</span>: <span class=\"string\">'file?name=[name].[ext]'</span></div><div class=\"line\">          &#125;,</div><div class=\"line\">        ],</div><div class=\"line\"></div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<h3 id=\"使用-JSX-的注意点\"><a href=\"#使用-JSX-的注意点\" class=\"headerlink\" title=\"使用 JSX 的注意点\"></a>使用 JSX 的注意点</h3><p>JSX 其实就是将 html 的标签引入进了 js 中，但是在使用上也有必须要注意的问题，我是第一次使用 JSX，因此就遇到了一些问题。</p>\n<ol>\n<li>JSX 本质上就是一个 expression，这一点很重要，因此它可以被 return 返回，可以用数组存储</li>\n<li>JSX 的 tag 必须成对出现，这一点和 xml 的语法很像，不可省略（若是省略，首 tag 之后的内容会被认为全在 tag 之内）</li>\n<li>JSX 中虽然可以通过 <code>{var}</code> 这样的方式，来加入上下文的出现的变量，但是在 JSX 的 tag 之间不能出现 expression 以外的 statement，这里之所以会提到这一点是因为想说不要试图通过在 tag 之间加入 for 循环来进行相同类型的 element 的生成（想要达到这一效果，可以使用数组来存储中间的 element，然后最后一起提供给 render 函数</li>\n</ol>\n<h3 id=\"React-组件的书写\"><a href=\"#React-组件的书写\" class=\"headerlink\" title=\"React 组件的书写\"></a>React 组件的书写</h3><p>写 React 组件有两种方法：class 继承 或者 提供一个 function。</p>\n<p>在使用 class 继承的时候，有一点必须要注意，class 是 ES6 的语法，因此必须使用 babel-ex2015 这个 loader 来解析，此外根据 es6 的语法，在 class 内部使用方法的时候，必须通过 <code>this</code> 来引用。</p>\n<p>在使用 function 的时候，一种简洁的方法便是使用 arrow function，但是需要注意的是 arrow function 的时候，提供的参数只有一个，就是用来赋给 props 的，code 里面的例子：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">const</span> Board = <span class=\"function\">(<span class=\"params\">&#123;nextPlayer,squares,handleClick&#125;</span>)=&gt;</span>&#123;...&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"javascript-的自动插入-semicolon-ASI-auto-semicolon-insertion\"><a href=\"#javascript-的自动插入-semicolon-ASI-auto-semicolon-insertion\" class=\"headerlink\" title=\"javascript 的自动插入 semicolon (ASI, auto semicolon insertion)\"></a>javascript 的自动插入 semicolon (ASI, auto semicolon insertion)</h3><p>这一点是我这次过程中才发现的，真的让我很无力，关于这一点有很详细的文档记载，可以参考这个 SO <a href=\"http://stackoverflow.com/questions/2846283/what-are-the-rules-for-javascripts-automatic-semicolon-insertion-asi\" target=\"_blank\" rel=\"external\">问答</a>，在这里我只想强调一点，就是关于 return 的 ASI：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">return</span></div><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"attr\">a</span>:<span class=\"number\">1</span>,</div><div class=\"line\">    <span class=\"attr\">b</span>:<span class=\"number\">2</span></div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">// will be transformed to:</span></div><div class=\"line\"><span class=\"keyword\">return</span> ;</div><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"attr\">a</span>:<span class=\"number\">1</span>,</div><div class=\"line\">    <span class=\"attr\">b</span>:<span class=\"number\">2</span>,</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<h2 id=\"Redux\"><a href=\"#Redux\" class=\"headerlink\" title=\"Redux\"></a>Redux</h2><p>Redux 的设计思想在我看来还是很先进的，在这里先以我的理解做一下简单的总结。</p>\n<p>虽然说 React 和 Redux 和 React 没有必然联系，但是在我看来，没有类似于 React 的这种<strong>视图组件化</strong>的思想的话，那么 Redux 就是空中楼阁，Redux 的设计理念是对 React 的一大应用，它所做的事情其实就是将<strong>视图的响应逻辑集中化</strong>，React 组件在设计庞大之后，将会出现难以避免的视图响应逻辑复杂（复杂之处在于不同组件之间的交互），这也是为什么 React 的官方文档里总是提倡 <strong>lift up state</strong>，通过这样来避免小组件之间的通信。</p>\n<p>在 Redux 的设计之外，有一个重要的理念，就是 Component 和 Container 的设计思想，这也是 Redux 官方文档推荐的一篇 <a href=\"https://medium.com/@dan_abramov/smart-and-dumb-components-7ca2f9a7c7d0\" target=\"_blank\" rel=\"external\">post</a>。这和 React 的 <strong>lift up state</strong> 思想很相似，其实在最后所有的状态都集中到的那个 Component 就是这里的 Container，因此 Redux 在与 React 的结合使用中，你会发现，Redux 实际上将 state 从 Component 中抽离了，当然也并非存在于 Container，而是存在于全局，Container 只是访问全局 state 的地方而已，那么 UI 的更新又是如何做的呢？Redux 通过 state 的改变，然后将这种改变映射到 props 中去，然后会导致相应的 Component UI 发生变化。</p>\n<h3 id=\"Redux-的流程\"><a href=\"#Redux-的流程\" class=\"headerlink\" title=\"Redux 的流程\"></a>Redux 的流程</h3><p>官方文档的 tutorial 写的很好了，但是我看完之后，真正轮到我实现的时候又变得懵逼了，究其原因其实在于不理解 Redux 的控制流程。</p>\n<p>因此 Redux 的入门坑就在于如何正确理解它的控制流程，下面是我的理解：<br>state 作为存储于全局的变量，只要在一开始正确设置了 store，那么在这个 App 的内部任何地方都可以访问到 App 的状态（通过 <code>store.getState()</code>）</p>\n<p>reducer 实际上就是做了一件事，描述了整个状态机，(previous state, action) =&gt; (next state)</p>\n<p>在设计的时候，要分别实现相应的 Component 和 Container，其中 Container 中不要涉及 state 的访问，它对 Redux 是一无所知的，而 Container 负责做两件事，分别对应着两个个需要实现的函数：mapStateToProps 和 mapDispatchToProps。</p>\n<p>其实这两个函数的名字可以任意取，但是这样取可以表明他们的含义，从名字可以看出它们都是给 Component 的 props 赋值，但赋值的对象和目的有所区别，前者负责描述 (current state) =&gt; (current props)，也就是在状态改变的时候如何更新 UI；后者做的是将 dispatch 动作赋值给 Component 的 props 中的事件属性，比如 onclick ，一般只会执行一次，用于触发 action，从而依据自定义的 reducer 推动 state 的更新。</p>\n<p>因此，整个触发流程便是含有 dispatch action 的 onClick 被触发了，然后 reducer 指明了下一个 state，然后 mapStateToProps 被调用了，然后 Component 被重新绘制了。</p>\n","excerpt":"","more":"<h2 id=\"Abstract\"><a href=\"#Abstract\" class=\"headerlink\" title=\"Abstract\"></a>Abstract</h2><p>我这个星期基本上在工作之余都在研究 React 和 Redux，我之前对这部分知识完全没用接触过，期间遇到很多坑，尤其是在想自己能够完成一个独立的比较小的 React App 的时候，发现出现了很多意想不到的事情，下面是我这个星期的总结。</p>\n<p>注意，本文不是 React 和 Redux 的 tutorial，按道理讲，官方文档已经写的比较好了，但是对于新手来说可能不是很容易上手，因此，如果你看完了官方文档，在自己动手实现自己的第一个 React App 的时候，如果先看一下本文可能会得到一些启示，从而绕过一些坑。</p>\n<p>文章分为两个部分，第一部分是关于 React 的内容，第二部分是关于 Redux 的内容（需要注意的是，React 和 Redux 不是必须一起使用的，实际上本文写的时候，Redux 已经有式微的趋势了）。</p>\n<p>文中使用的原本 code 来自于 facebook 的 React 项目的 <a href=\"https://codepen.io/ericnakagawa/pen/vXpjwZ?editors=0010\">tutorial</a>。</p>\n<h2 id=\"阅读之前最好先看过……\"><a href=\"#阅读之前最好先看过……\" class=\"headerlink\" title=\"阅读之前最好先看过……\"></a>阅读之前最好先看过……</h2><ol>\n<li>React 的 <a href=\"https://codepen.io/ericnakagawa/pen/vXpjwZ?editors=0010\">tutorial</a>。</li>\n<li>webpack 的简单介绍</li>\n<li>Redux 的基础部分</li>\n</ol>\n<h2 id=\"React\"><a href=\"#React\" class=\"headerlink\" title=\"React\"></a>React</h2><p>首先对 React 的特点做一个总结，React 是 facebook 推出的一个前端框架（注意前端不一定是指 web），其最大的特点在于，<strong>视图组件化</strong>。</p>\n<p>我两年前（2015）的时候，还没有接触到 React 这种东西，那时候我只知道 Dom 编程，当时就感觉，开发前端页面非常繁琐，尤其是再结合 PHP 使用，其主要问题就是 JS 代码就是脚本，复用性不高，视图的响应逻辑逻辑很混乱，而 React 很好地解决了这个问题，通过将想要构建的视图直接分解成具有层级的组件，这样就可以大大提高视图组件的复用性，此外，每一个组件都具备相应的 props 和 state，前者是组件的属性值，后者是组件的状态，两者的区别就在于：前者是由父组件提供的组件属性（所以在组件内部是只读的），后者是私有的组件属性（用于保存这个组件的状态，从而实现自更新）:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 这是 ReactComponent.js 的一段代码</span></div><div class=\"line\">ReactComponent.prototype.setState = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">partialState, callback</span>) </span>&#123;</div><div class=\"line\">  !(<span class=\"keyword\">typeof</span> partialState === <span class=\"string\">'object'</span> || <span class=\"keyword\">typeof</span> partialState === <span class=\"string\">'function'</span> || partialState == <span class=\"literal\">null</span>) ? process.env.NODE_ENV !== <span class=\"string\">'production'</span> ? invariant(<span class=\"literal\">false</span>, <span class=\"string\">'setState(...): takes an object of state variables to update or a function which returns an object of state variables.'</span>) : _prodInvariant(<span class=\"string\">'85'</span>) : <span class=\"keyword\">void</span> <span class=\"number\">0</span>;</div><div class=\"line\">  <span class=\"keyword\">this</span>.updater.enqueueSetState(<span class=\"keyword\">this</span>, partialState);</div><div class=\"line\">  <span class=\"keyword\">if</span> (callback) &#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>.updater.enqueueCallback(<span class=\"keyword\">this</span>, callback, <span class=\"string\">'setState'</span>);</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>其中最重要的一段代码就是   <code>this.updater.enqueueSetState(this, partialState);</code>，可以看出来，当使用了 setState 后，便会将新的状态放入 updater 的更新队列中。</p>\n<h3 id=\"搭建起一个可以构建-React-App-的本地环境\"><a href=\"#搭建起一个可以构建-React-App-的本地环境\" class=\"headerlink\" title=\"搭建起一个可以构建 React App 的本地环境\"></a>搭建起一个可以构建 React App 的本地环境</h3><p>之所以会提到这一点，是因为 facebook 提供的 <a href=\"https://codepen.io/ericnakagawa/pen/vXpjwZ?editors=0010\">starter code</a> 是在线的版本，当你把代码复制到本地的时候，根本就用不了。</p>\n<p>这时候必须使用到一个方便的工具了，叫做 <a href=\"https://webpack.github.io/\">webpack</a>，这是一个打包 js 代码的工具，通过简单的配置，便可以使用其将所有的 js 代码打包起来，比如叫做 <em>bundle.js</em>，然后直接在 <em>index.html</em> 中引用这个脚本。</p>\n<p>但是，仅仅如此还不够，因为上述代码使用的是 ES6 + JSX 的形式，因此必须还得配置好 webpack 的配置文件 <em>webpack.config.js</em>，在 webpack 这个工具之中有 loader 这个概念，loader 的意思其实就是解析其他形式的语言到 js 的形式，由第三方提供，在这里我们使用 babel 这个 loader，此外必须安装 babel 的另外两个 loader：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">npm i babel-loader babel-preset-es2015 babel-preset-react babel-core -S</div></pre></td></tr></table></figure></p>\n<p>然后要在 <em>webpack.config.js</em> 里配置好：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</div><div class=\"line\">    <span class=\"attr\">entry</span>:<span class=\"string\">'./index.js'</span>,</div><div class=\"line\">    <span class=\"attr\">output</span>:&#123;</div><div class=\"line\">        <span class=\"attr\">filename</span>:<span class=\"string\">\"bundle.js\"</span>,</div><div class=\"line\">        <span class=\"attr\">path</span>:path.resolve(__dirname,<span class=\"string\">'dist'</span>)</div><div class=\"line\">    &#125;,</div><div class=\"line\">    <span class=\"attr\">module</span>:&#123;</div><div class=\"line\">        <span class=\"attr\">loaders</span>:[</div><div class=\"line\">          &#123;</div><div class=\"line\">            <span class=\"attr\">test</span>: <span class=\"regexp\">/(\\.jsx|\\.js)$/</span>,</div><div class=\"line\">            <span class=\"attr\">loaders</span>: <span class=\"string\">'babel-loader'</span>,</div><div class=\"line\">            <span class=\"attr\">query</span>:&#123;</div><div class=\"line\">                <span class=\"attr\">presets</span>:[<span class=\"string\">'es2015'</span>,<span class=\"string\">'react'</span>,<span class=\"string\">'stage-0'</span>]</div><div class=\"line\">            &#125;,</div><div class=\"line\">          &#125;,</div><div class=\"line\">          &#123;</div><div class=\"line\">            <span class=\"attr\">test</span>: <span class=\"regexp\">/\\.scss$/</span>,</div><div class=\"line\">            <span class=\"attr\">loaders</span>: [<span class=\"string\">'style'</span>, <span class=\"string\">'css'</span>, <span class=\"string\">'sass'</span>],</div><div class=\"line\">          &#125;,</div><div class=\"line\">          &#123;</div><div class=\"line\">            <span class=\"attr\">test</span>: <span class=\"regexp\">/\\.html$/</span>,</div><div class=\"line\">            <span class=\"attr\">loader</span>: <span class=\"string\">'file?name=[name].[ext]'</span></div><div class=\"line\">          &#125;,</div><div class=\"line\">        ],</div><div class=\"line\"></div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<h3 id=\"使用-JSX-的注意点\"><a href=\"#使用-JSX-的注意点\" class=\"headerlink\" title=\"使用 JSX 的注意点\"></a>使用 JSX 的注意点</h3><p>JSX 其实就是将 html 的标签引入进了 js 中，但是在使用上也有必须要注意的问题，我是第一次使用 JSX，因此就遇到了一些问题。</p>\n<ol>\n<li>JSX 本质上就是一个 expression，这一点很重要，因此它可以被 return 返回，可以用数组存储</li>\n<li>JSX 的 tag 必须成对出现，这一点和 xml 的语法很像，不可省略（若是省略，首 tag 之后的内容会被认为全在 tag 之内）</li>\n<li>JSX 中虽然可以通过 <code>{var}</code> 这样的方式，来加入上下文的出现的变量，但是在 JSX 的 tag 之间不能出现 expression 以外的 statement，这里之所以会提到这一点是因为想说不要试图通过在 tag 之间加入 for 循环来进行相同类型的 element 的生成（想要达到这一效果，可以使用数组来存储中间的 element，然后最后一起提供给 render 函数</li>\n</ol>\n<h3 id=\"React-组件的书写\"><a href=\"#React-组件的书写\" class=\"headerlink\" title=\"React 组件的书写\"></a>React 组件的书写</h3><p>写 React 组件有两种方法：class 继承 或者 提供一个 function。</p>\n<p>在使用 class 继承的时候，有一点必须要注意，class 是 ES6 的语法，因此必须使用 babel-ex2015 这个 loader 来解析，此外根据 es6 的语法，在 class 内部使用方法的时候，必须通过 <code>this</code> 来引用。</p>\n<p>在使用 function 的时候，一种简洁的方法便是使用 arrow function，但是需要注意的是 arrow function 的时候，提供的参数只有一个，就是用来赋给 props 的，code 里面的例子：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">const</span> Board = <span class=\"function\">(<span class=\"params\">&#123;nextPlayer,squares,handleClick&#125;</span>)=&gt;</span>&#123;...&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"javascript-的自动插入-semicolon-ASI-auto-semicolon-insertion\"><a href=\"#javascript-的自动插入-semicolon-ASI-auto-semicolon-insertion\" class=\"headerlink\" title=\"javascript 的自动插入 semicolon (ASI, auto semicolon insertion)\"></a>javascript 的自动插入 semicolon (ASI, auto semicolon insertion)</h3><p>这一点是我这次过程中才发现的，真的让我很无力，关于这一点有很详细的文档记载，可以参考这个 SO <a href=\"http://stackoverflow.com/questions/2846283/what-are-the-rules-for-javascripts-automatic-semicolon-insertion-asi\">问答</a>，在这里我只想强调一点，就是关于 return 的 ASI：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">return</span></div><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"attr\">a</span>:<span class=\"number\">1</span>,</div><div class=\"line\">    <span class=\"attr\">b</span>:<span class=\"number\">2</span></div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">// will be transformed to:</span></div><div class=\"line\"><span class=\"keyword\">return</span> ;</div><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"attr\">a</span>:<span class=\"number\">1</span>,</div><div class=\"line\">    <span class=\"attr\">b</span>:<span class=\"number\">2</span>,</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<h2 id=\"Redux\"><a href=\"#Redux\" class=\"headerlink\" title=\"Redux\"></a>Redux</h2><p>Redux 的设计思想在我看来还是很先进的，在这里先以我的理解做一下简单的总结。</p>\n<p>虽然说 React 和 Redux 和 React 没有必然联系，但是在我看来，没有类似于 React 的这种<strong>视图组件化</strong>的思想的话，那么 Redux 就是空中楼阁，Redux 的设计理念是对 React 的一大应用，它所做的事情其实就是将<strong>视图的响应逻辑集中化</strong>，React 组件在设计庞大之后，将会出现难以避免的视图响应逻辑复杂（复杂之处在于不同组件之间的交互），这也是为什么 React 的官方文档里总是提倡 <strong>lift up state</strong>，通过这样来避免小组件之间的通信。</p>\n<p>在 Redux 的设计之外，有一个重要的理念，就是 Component 和 Container 的设计思想，这也是 Redux 官方文档推荐的一篇 <a href=\"https://medium.com/@dan_abramov/smart-and-dumb-components-7ca2f9a7c7d0\">post</a>。这和 React 的 <strong>lift up state</strong> 思想很相似，其实在最后所有的状态都集中到的那个 Component 就是这里的 Container，因此 Redux 在与 React 的结合使用中，你会发现，Redux 实际上将 state 从 Component 中抽离了，当然也并非存在于 Container，而是存在于全局，Container 只是访问全局 state 的地方而已，那么 UI 的更新又是如何做的呢？Redux 通过 state 的改变，然后将这种改变映射到 props 中去，然后会导致相应的 Component UI 发生变化。</p>\n<h3 id=\"Redux-的流程\"><a href=\"#Redux-的流程\" class=\"headerlink\" title=\"Redux 的流程\"></a>Redux 的流程</h3><p>官方文档的 tutorial 写的很好了，但是我看完之后，真正轮到我实现的时候又变得懵逼了，究其原因其实在于不理解 Redux 的控制流程。</p>\n<p>因此 Redux 的入门坑就在于如何正确理解它的控制流程，下面是我的理解：<br>state 作为存储于全局的变量，只要在一开始正确设置了 store，那么在这个 App 的内部任何地方都可以访问到 App 的状态（通过 <code>store.getState()</code>）</p>\n<p>reducer 实际上就是做了一件事，描述了整个状态机，(previous state, action) =&gt; (next state)</p>\n<p>在设计的时候，要分别实现相应的 Component 和 Container，其中 Container 中不要涉及 state 的访问，它对 Redux 是一无所知的，而 Container 负责做两件事，分别对应着两个个需要实现的函数：mapStateToProps 和 mapDispatchToProps。</p>\n<p>其实这两个函数的名字可以任意取，但是这样取可以表明他们的含义，从名字可以看出它们都是给 Component 的 props 赋值，但赋值的对象和目的有所区别，前者负责描述 (current state) =&gt; (current props)，也就是在状态改变的时候如何更新 UI；后者做的是将 dispatch 动作赋值给 Component 的 props 中的事件属性，比如 onclick ，一般只会执行一次，用于触发 action，从而依据自定义的 reducer 推动 state 的更新。</p>\n<p>因此，整个触发流程便是含有 dispatch action 的 onClick 被触发了，然后 reducer 指明了下一个 state，然后 mapStateToProps 被调用了，然后 Component 被重新绘制了。</p>\n"},{"title":"JavaScript ES5 总结","date":"2017-02-16T16:05:46.000Z","_content":"\n## Abstract\nJavaScript 的语法让我感到非常不舒服，究其原因其实是因为两点：\n1. 动态语言\n2. 原型编程\n\n对于动态语言，我个人始终认为是不符合大型 project 的要求的，因为动态语言的特性导致阅读代码的时候非常不顺利，比如你看到一个 function 的参数时候，你完全不知道它是怎样的结构，但是像 Java 这样的强类型语言，每一个参数都有类型，就使得对于每一个参数你都知道它实实在在的含义（可以去查看参数类型的定义）。\n此外原型编程，我迄今看不出其优势所在，不仅每一个对象的原型都可以被随意改变，而且根本没有访问控制。\n\n但尽管如此，我个人认为 JavaScript 还是更加现代化的编程语言，比如它的 function 可以作为对象任意传递，这一点和 Python 类似，对于异步编程可以说是非常直观地支持。\n然而 JavaScript 的发展在 2015 年 ES6 发布后，就迎来了非常大的增强，我想为了更好的学习 ES6，对之前版本的深层次的理解还是需要的，相当于打好基础才能更好地前进。\n在本篇 post 中，我主要是对自己看过的 Dmitry Soshnikov 的一系列关于 ES3-ES5 的 [posts](http://dmitrysoshnikov.com) 总结，主要包含 JavaScript 中最迷惑人的两个部分：\n1. 变量管理\n2. 原型编程\n\n## 变量管理\n这里使用的变量管理并不是指硬件层面的实现，而是指 JavaScript 的变量存储的抽象模型。另外，在概念上，ES3 和 ES5 有着几个区别，因此会分别描述。\n### ES3\n#### Execution Context(EC)\n在 JavaScript 中有两种 EC：global context 和 function context。\n不同的 context 的管理是用 stack 模式管理的，举个例子，在 global context 下定义了一个 function func，那么整个 EC stack 就是：\n```\nEC Stack = {\n    funcContext,\n    globalContext,\n}\n```\n如果从 funcContext 退出那么，EC Stack 将会只剩下 globalContext，符合 Stack 的管理方式。\nEC 有着许多重要的 property，用以在运行时使用，而在本篇 post 中，着重强调变量管理这一个问题，因此会探究其相关属性。\n\n#### Variable Object(VO) / Activation Object(AO)\nVO 和 AO 其实类似于符号表(symbol table)，用以集中管理变量，并且这是 EC 的属性，在 ES6 之前是没有 var 之外的变量定义方式的(有隐式定义变量，下面会提到)，而对 var 的处理会在**静态分析**进行，并且将定义的变量名填入 VO/AO，但是并不会直接对其赋值，而是等到执行到赋值语句的时候才会：\n```javascript\n// now VO = {\n//     a: undefined,\n// }\n\nconsole.log(a); // undefined\nvar a = 13;\n\n// now VO = {\n//     a: 13,\n// }\n```\n这里既然都是符号表，为什么有 VO 和 AO 的区别呢？\nVO 其实是指 global context 的符号表，而 AO 是指 function context 的符号表，之所以有这两者的区别是因为 function context 有着不一样的符号管理，总共包括三类符号：\n\n1. arguments：即 function 的参数\n2. functions：function 内部定义的 function，在静态分析期间，如果符号与 arguments、variables 中的有冲突，直接替代(function 提升)\n3. variables：function 内部定义的变量，如果和 1、2 有冲突，在静态分析期间不会造成影响，在执行期间会直接替代 1 中的冲突项(理所当然的，后来覆盖)，与 2 的互相替代也符合后来覆盖原则\n\n直接看一个例子就知道区别了：\n```javascript\nfunction func(f){\n    console.log(f);\n    var f = 4;\n    function f(){}\n    console.log(f);\n}\nfunc(3);\n// output:\n// [Function: f]\n// 4\n```\n这段的最后还要说明一下隐式声明的问题，上面提到如果直接给一个变量赋值(不用 var)也是可以的，但是其实不是向 VO 中添加符号，而是给当前的 EC 下的 this 变量添加了一个属性而已。\n看下面的例子：\n```javascript\nx = 3;\nvar a = 4;\ndelete a;\ndelete x;\nconsole.log(a); // 4\nconsole.log(x); // Reference Error\n```\n\n### Scope Chain(SC)\n按道理说有了 EC 和 VO，那么便可以在任何一个特定的 EC 下进行变量访问，但是如果出现当前变量无法再当前 EC 下找到，那么该如何处理呢？为了解决这种情况，SC 被引入自然是很正常的事情，而 SC 和其他语言的构造方法基本一致：\n```javascript\nSC(ECStack[top]) = VO/AO + SC(ECStack[top-1]);\nECStack[0] === globalContext;\n```\n但需要注意的是，JavaScript 并没有 block 的概念，这是和其他主流语言的最大区别之一，也正因为如此只有 function 才能创造新的 context，因此常常会说一个 function 的 SC，但实际上是 EC 的 SC。因此对于 function 中的变量解析，自然是很重要的，但其实也很简单，只需要注意一点 **function 的 SC 是静态分析确立的**，会在运行前把需要用的变量的 Reference 记录下来：\n```javascript\nvar x = 3;\nfunction func(){\n    console.log(x);\n}\nfunc(); // output: 3\nx = 4;\nfunc(); // output: 4\n```\n\n此外，with 和 catch 会把其引入的变量加入到当前 SC 的最前面:\n```javascript\nfunction func(){\n    var obj  = {\n        x: 3,\n    }\n    var x = 4;\n    with(obj){\n        console.log(x);\n    }\n}\nfunc();// output: 3\n```\n\n还有一点比较重要的是，因为 JavaScript 的有着 prototype，因此当顺着 SC 找到最后，可以访问到 Object 的 prototype 上去，可以看下面这个例子：\n```javascript\nfunction foo() {\n  console.log(x);\n}\nObject.prototype.x = 10;\nfoo(); // 10\n```\n#### 属性访问\n讲到这里，有了 EC、VO、SC，我们看似便可以对几乎所有的变量进行访问了，但是还有一种情况没有考虑，那就是 object 的属性访问，而在属性访问中，还有一个特别的例子，就是 this 的属性访问。\n##### Reference Type(RT)\n属性访问问题解决的本质其实在于如何定义这样的访问方法，而 JS 的做法是通过 RT 来解决，RT 的产生只在两者情况下：\n\n1. 处理变量名(identifier)[这里表明，普通变量的访问其实也是通过 RT 来解决的]\n2. 处理属性访问符(property accessor)\n\n而 RT 的基本结构如下：\n\n```javascript\nvar foo = 3;\n// fooReferenceType = {\n//    base: null,  => null will be transformed to globalContext's VO\n//    propertyName: foo,\n//}\n```\n\n当引用 foo 变量的时候，首先便会得到一个 fooReferenceType，然后每一个 RT 都有一个获取属性值的方法(GetValue)，这样就解决了属性访问的问题(其实说到可以发现，JS 里所有的变量访问都是属性访问，只不过没有指定 object 的地方基本上使用的 SC 上一层 VO/AO)。\n##### this 绑定\nthis 的使用一般是如下情况：\n\n```javascript\nfunction func() {\n    console.log(this.x);\n}\nvar obj = {x:1};\nobj.func();\n```\n\n这里在 func 的内部如何知道 this 这个 object 是什么呢？这里就涉及到了 this 的 binding 问题。\n其实 this 的绑定规则很简单，可以这么说 **this 的绑定完全由 function 的调用方式决定**，这是因为 this 绑定的 object 就是 **function 前面的变量的 RT 的 base**。\n\n```javascript\nvar obj1 = {\n    x: 1,\n    func:function() {\n        console.log(this.x);\n        },\n};\nvar obj2 = {\n    x: 2,\n    func: undefined,\n};\nobj1.func(); // output 1\nobj2.func = obj1.func;\nobj2.func(); // output 2\n(obj2.func = obj1.func)(); // output undefined\n```\n\n这是一个很经典的例子，1 和 2 的输出根据上面的理论是理所当然的结果，但是最后一个 undefined 的结果可能就有点令人费解了。它背后的机制是这样的，`(obj2.func = obj1.func)` 括号内一个表达式，并不是一个变量名(identifier)，当然也不是属性访问器(property accessor)，因此对它解析不会产生 RT，也因此其 this 的绑定为 null，而 null 作为 this 的值在 non-strict 模式下是会被转化成 globalContext 的 VO 的。\n\n## ES5\n### Call Stack\n将 EC 的称谓正式变为 Call Stack，本质并没有太多变化。\n### Environment\nES5 管理变量的方式发生了比较大的变化，首先不在使用 VO 和 AO 了，统一成了 Environment，但是 Environment 分为两类，Variable Environment(VE) 和 Lexical Environment(LE) 两种，但是和 VO/AO 的分类并没有直接关系，其实 VE 本质上和 ES3 中的 VO/AO 是同一个东西，负责管理所有的变量访问，LE 的提出是为了解决这样一个特定问题：**with 下的 function expression 中的变量访问**：\n```javascript\nvar x = 1;\nfunction foo() {\n    console.log(x);\n}\n \nwith ({x: 2}) {\n    // this is a function expression\n    var bar = function () {\n        console.log(x);\n    };\n    foo(); // 1, from VariableEnvrionment\n    bar(); // 2, from LexicalEnvrionment\n}\nfoo(); // 1\nbar(); // still 2\n```\n其实一般情况下，LE 只是 VE 的一个复制值，但是当出现例子这种情况的时候，必须在不破坏 VE 的情况下(因为 `foo` 的调用需要用到 `x = 1`)，同时提供另一套 `{x: 2}` 会被先访问的 Environment(`bar` 的调用要用到 `x:2`)，于是会在进入 with block 的时候，保存好当前的 LE，同时改变 LE 为需要的 LE，在 with block 结束的时候恢复。\n### Enviroment Record(ER)\n每一个 Environment 的结构会包含一个 ER 以及一个 outer，outer 其实就是上一层的 Environment，这点和 SC 很类似，不过是不完全一样的，下面的一个例子可以说明问题：\n```javascript\nvar x = 1;\nfunction func() {\n    var y = 2;\n}\n\nglobalEnvironment = {\n    environmentRecord: {\n \n        // built-ins:\n        Object: function,\n        Array: function,\n        // etc ...\n    \n        // our bindings:\n        x: 1,\n        func: function,\n\n    },\n \n    outer: null // no parent environment\n \n};\n \n// environment of the \"foo\" function\n \nfooEnvironment = {\n    environmentRecord: {\n        y: 2,\n    },\n    outer: globalEnvironment\n};\n```\n\n也许你有这样的疑惑，为什么需要做这样的改变呢？\n答案是为了 Efficiency！\n需要提到的是，规定(specification)并不提倡将 ER 实现为一个 simple object，这意味着各大 Engine 在这里可以提供自定义的优化！仔细想一想就会发现 SC 的设计会导致一层一层地查找某个变量，这个效率实在是太过低下，为什么不把会用到的变量放入当前 ER 中以提供直接的访问？此外还可以将不用到的变量不保存，这两点可以通过静态分析做到，V8 Engine 却是也是这样做的。\n此外 environment record 有两种类型 decorative environment record(VER) 和 object environment record(OER)，两者的区别在于前者处理 function activition 以及 catch 时的 environment record(相当于以前的 AO)，后者用于处理 global context 下的 function、variable 以及 with 语句下的变量 binding，这只是规定(specification)上的区别，在实际实现中，并没有这个标志来指定 ER 的区别。\n\n## 原型编程\n### \\_\\_proto__ 和 prototype 的区别\n在阐述原型之前，必须先澄清这两个概念的区别，其实说穿了也很简单，一个 object 的原型实际上就是 \\_\\_proto__，那么 prototype 又是什么呢？\n直接看如下一个例子：\n\n```javascript\nfunction Constructor() {\n    this.x = 3;\n}\nConstructor.prototype. y = 4;\nvar obj = new Constructor();\nconsole.log(obj.__proto__ === Constructor.prototype) //true\nconsole.log(obj.x, obj.y) //3, 4\n```\n看到这里你就知道了，当使用 `new Cnostructor()` 来创建对象的话，那么 Constructor 的 prototype 便会是新创建对象的 \\_\\_proto__。\n值得注意的是，上面这个例子中，x 和 y 的查询是不同的，x 属于 obj 自己的属性，而 y 是属于其原型的属性。\n\n因此一般说来，prototype 是 function 才有的属性，而所谓的原型编程实际上就是指使用 function 来进行 \\_\\_proto__ 的创建与传递。\n\n另外，这里给出 Object 和 Function 的 \\_\\_proto__ 和 prototype:（注意 Object 和 Funtion 都是 function 类型的）\n\n```nodejs\n> Function.__proto__\n[Function]\n> Function.__proto__.__proto__\n{}\n> Function.__proto__.__proto__.__proto__\nnull\n> Object.__proto__\n[Function]\n> Object.__proto__.__proto__\n{}\n> Object.__proto__.__proto__.__proto__\nnull\n> Function.prototype\n[Function]\n> Object.prototype\n{}\n```\n### 使用 prototype 来进行面向对象编程\n在 ES6 之前，并没有 class 的对象，但即使到了 ES6，所谓的 class 不过是 syntax sugar，本质其实还是 prototype 编程。\n面向对象的三大特点：封装、继承、多态，下面依次阐述。\n#### 封装\n这个现在即使在 ES6 也没有很好地解决办法，目前所知道的方法有两种\n1. ES7 中出现以 # 表示私有属性\n2. 此外使用 ES6 的 Symbol 也可以达到模拟私有属性的效果\n\n#### 继承\n这个在 ES6 之前的版本，其实是有方法进行继承模拟的，可以看下面的一个例子：\n\n```javascript\nfunction SupCls() {\n    this.x = 1;\n}\nSupCls.prototype.y = 2;\nvar supCls = new SupCls();\nconsole.log(supCls.x, supCls.y);\n// output: 1, 2\n\n// now we will make an inheritance\nfunction SubCls() {\n    this.z = 3;\n}\nSubCls.prototype = new SupCls();\nSubCls.prototype.constructor = SubCls;\nvar subCls = new SubCls();\nconsole.log(subCls.x, subCls.y, subCls.z);\n// output: 1, 2, 3\nconsole.log(subCls.__proto__);\n// output: SubCls { x: 1, constructor: [Function: SubCls] }\nconsole.log(subCls.hasOwnProperty('x'));\n// output: false\n```\n\n这里解释一下最关键的一步，`SubCls.prototype =  new SupCls()`，这可以使得新创建的 subCls 的 \\_\\_proto__ 是 SupCls 的 prototype，从而使得其具有父类的属性。\n\n除此之外还有一个令人迷惑的地方就是，为什么需要做 `SubCls.prototype.constructor = SubCls`？其实这步对于结果来说无关紧要，只是将 SubCls 的原型中的 constructor 指向正确的地方，如果没有这一步，上面的结果依然如此，也就是说 new 不会根据 prototype 的 constructor 来改变其行为，constructor 的存在只是给生成的 object 添加一个正确的引用。\n\n其实这里有一个陷阱，那就是最后一条语句表明，x 不是 subCls 的instance属性！为什么会这样其实很好理解，因为 x 根据我们的做法是属于 SubCls 的 prototype 的属性，自然也是属于 subCls 的 \\_\\_proto__ 属性。\n\n那么如何解决这个问题呢？\n其实很简单，无非就是把 SupCls 中的 this 换成我们想要的，也就是 SubCls 中的 this，做一次 binding 就行了。\n\n看下面的实现方式:\n\n```javascript\nfunction SupCls() {\n    this.x = 1;\n}\nSupCls.prototype.y = 2;\nvar supCls = new SupCls();\nconsole.log(supCls.x, supCls.y);\n// output: 1, 2\n\n// now we will make an inheritance\nfunction SubCls() {\n    this.z = 3;\n    // binding is done here\n    SubCls.supertype.constructor.apply(this);\n}\nSubCls.prototype = new SupCls();\nSubCls.prototype.constructor = SubCls;\nSubCls.supertype = SupCls.prototype;\nvar subCls = new SubCls();\nconsole.log(subCls.x, subCls.y, subCls.z);\n// output: 1, 2, 3\nconsole.log(subCls.__proto__);\n// output: SubCls { x: 1, constructor: [Function: SubCls] }\nconsole.log(subCls.hasOwnProperty('x'));\n// output: true\n```\n\n也许你以为到这里就解决问题了，但实际上还有一个问题！\n你可以发现，SupCls 这个 function 被调用了两次，而这个是可以避免的，为什么这么说？我们看这两次的调用时机：\n1. `SubCls.prototype = new SupCls();`\n2. `SubCls.supertype.constructor.apply(this);`\n\n明显可以发现第一次的调用其实没有必要，因此第一次的调用我们只是想要拿到 SupCls 的 prototype 信息，而不是以它为 constructor 创建的 instance 信息，所以为了避免这个，我们可以这样来结束讨论：\n```javascript\nfunction SupCls() {\n    this.x = 1;\n}\nSupCls.prototype.y = 2;\nvar supCls = new SupCls();\nconsole.log(supCls.x, supCls.y);\n// output: 1, 2\n\n// now we will make an inheritance\nfunction SubCls() {\n    this.z = 3;\n    // binding is done here\n    SubCls.supertype.constructor.apply(this);\n}\n\n// new part start\nfunction middleConstructor() {}\nmiddleConstructor.prototype = SupCls.prototype;\nSubCls.prototype = new middleConstructor();\n// new part end\n\nSubCls.prototype.constructor = SubCls;\nSubCls.supertype = SupCls.prototype;\nvar subCls = new SubCls();\nconsole.log(subCls.x, subCls.y, subCls.z);\n// output: 1, 2, 3\nconsole.log(subCls.__proto__);\n// output: SubCls { x: 1, constructor: [Function: SubCls] }\nconsole.log(subCls.hasOwnProperty('x'));\n// output: true\n```\n\n也许有人会有这样的疑惑，为什么不直接将 SupCls 的 prototype 赋给 SubCls 的 prototype，对此，我表示你自己一试，想一下就知道了原因了。\n\n根据 Dmitry Soshnikov 的说法，ES6 class 的继承就是通过这样的方法实现的，不过我认为应该还是有出入的，这个还需要仔细探究一下。","source":"_posts/JavaScript-ES5-总结.md","raw":"---\ntitle: JavaScript ES5 总结\ndate: 2017-02-17 00:05:46\ntags: JavaScript ECMA\n---\n\n## Abstract\nJavaScript 的语法让我感到非常不舒服，究其原因其实是因为两点：\n1. 动态语言\n2. 原型编程\n\n对于动态语言，我个人始终认为是不符合大型 project 的要求的，因为动态语言的特性导致阅读代码的时候非常不顺利，比如你看到一个 function 的参数时候，你完全不知道它是怎样的结构，但是像 Java 这样的强类型语言，每一个参数都有类型，就使得对于每一个参数你都知道它实实在在的含义（可以去查看参数类型的定义）。\n此外原型编程，我迄今看不出其优势所在，不仅每一个对象的原型都可以被随意改变，而且根本没有访问控制。\n\n但尽管如此，我个人认为 JavaScript 还是更加现代化的编程语言，比如它的 function 可以作为对象任意传递，这一点和 Python 类似，对于异步编程可以说是非常直观地支持。\n然而 JavaScript 的发展在 2015 年 ES6 发布后，就迎来了非常大的增强，我想为了更好的学习 ES6，对之前版本的深层次的理解还是需要的，相当于打好基础才能更好地前进。\n在本篇 post 中，我主要是对自己看过的 Dmitry Soshnikov 的一系列关于 ES3-ES5 的 [posts](http://dmitrysoshnikov.com) 总结，主要包含 JavaScript 中最迷惑人的两个部分：\n1. 变量管理\n2. 原型编程\n\n## 变量管理\n这里使用的变量管理并不是指硬件层面的实现，而是指 JavaScript 的变量存储的抽象模型。另外，在概念上，ES3 和 ES5 有着几个区别，因此会分别描述。\n### ES3\n#### Execution Context(EC)\n在 JavaScript 中有两种 EC：global context 和 function context。\n不同的 context 的管理是用 stack 模式管理的，举个例子，在 global context 下定义了一个 function func，那么整个 EC stack 就是：\n```\nEC Stack = {\n    funcContext,\n    globalContext,\n}\n```\n如果从 funcContext 退出那么，EC Stack 将会只剩下 globalContext，符合 Stack 的管理方式。\nEC 有着许多重要的 property，用以在运行时使用，而在本篇 post 中，着重强调变量管理这一个问题，因此会探究其相关属性。\n\n#### Variable Object(VO) / Activation Object(AO)\nVO 和 AO 其实类似于符号表(symbol table)，用以集中管理变量，并且这是 EC 的属性，在 ES6 之前是没有 var 之外的变量定义方式的(有隐式定义变量，下面会提到)，而对 var 的处理会在**静态分析**进行，并且将定义的变量名填入 VO/AO，但是并不会直接对其赋值，而是等到执行到赋值语句的时候才会：\n```javascript\n// now VO = {\n//     a: undefined,\n// }\n\nconsole.log(a); // undefined\nvar a = 13;\n\n// now VO = {\n//     a: 13,\n// }\n```\n这里既然都是符号表，为什么有 VO 和 AO 的区别呢？\nVO 其实是指 global context 的符号表，而 AO 是指 function context 的符号表，之所以有这两者的区别是因为 function context 有着不一样的符号管理，总共包括三类符号：\n\n1. arguments：即 function 的参数\n2. functions：function 内部定义的 function，在静态分析期间，如果符号与 arguments、variables 中的有冲突，直接替代(function 提升)\n3. variables：function 内部定义的变量，如果和 1、2 有冲突，在静态分析期间不会造成影响，在执行期间会直接替代 1 中的冲突项(理所当然的，后来覆盖)，与 2 的互相替代也符合后来覆盖原则\n\n直接看一个例子就知道区别了：\n```javascript\nfunction func(f){\n    console.log(f);\n    var f = 4;\n    function f(){}\n    console.log(f);\n}\nfunc(3);\n// output:\n// [Function: f]\n// 4\n```\n这段的最后还要说明一下隐式声明的问题，上面提到如果直接给一个变量赋值(不用 var)也是可以的，但是其实不是向 VO 中添加符号，而是给当前的 EC 下的 this 变量添加了一个属性而已。\n看下面的例子：\n```javascript\nx = 3;\nvar a = 4;\ndelete a;\ndelete x;\nconsole.log(a); // 4\nconsole.log(x); // Reference Error\n```\n\n### Scope Chain(SC)\n按道理说有了 EC 和 VO，那么便可以在任何一个特定的 EC 下进行变量访问，但是如果出现当前变量无法再当前 EC 下找到，那么该如何处理呢？为了解决这种情况，SC 被引入自然是很正常的事情，而 SC 和其他语言的构造方法基本一致：\n```javascript\nSC(ECStack[top]) = VO/AO + SC(ECStack[top-1]);\nECStack[0] === globalContext;\n```\n但需要注意的是，JavaScript 并没有 block 的概念，这是和其他主流语言的最大区别之一，也正因为如此只有 function 才能创造新的 context，因此常常会说一个 function 的 SC，但实际上是 EC 的 SC。因此对于 function 中的变量解析，自然是很重要的，但其实也很简单，只需要注意一点 **function 的 SC 是静态分析确立的**，会在运行前把需要用的变量的 Reference 记录下来：\n```javascript\nvar x = 3;\nfunction func(){\n    console.log(x);\n}\nfunc(); // output: 3\nx = 4;\nfunc(); // output: 4\n```\n\n此外，with 和 catch 会把其引入的变量加入到当前 SC 的最前面:\n```javascript\nfunction func(){\n    var obj  = {\n        x: 3,\n    }\n    var x = 4;\n    with(obj){\n        console.log(x);\n    }\n}\nfunc();// output: 3\n```\n\n还有一点比较重要的是，因为 JavaScript 的有着 prototype，因此当顺着 SC 找到最后，可以访问到 Object 的 prototype 上去，可以看下面这个例子：\n```javascript\nfunction foo() {\n  console.log(x);\n}\nObject.prototype.x = 10;\nfoo(); // 10\n```\n#### 属性访问\n讲到这里，有了 EC、VO、SC，我们看似便可以对几乎所有的变量进行访问了，但是还有一种情况没有考虑，那就是 object 的属性访问，而在属性访问中，还有一个特别的例子，就是 this 的属性访问。\n##### Reference Type(RT)\n属性访问问题解决的本质其实在于如何定义这样的访问方法，而 JS 的做法是通过 RT 来解决，RT 的产生只在两者情况下：\n\n1. 处理变量名(identifier)[这里表明，普通变量的访问其实也是通过 RT 来解决的]\n2. 处理属性访问符(property accessor)\n\n而 RT 的基本结构如下：\n\n```javascript\nvar foo = 3;\n// fooReferenceType = {\n//    base: null,  => null will be transformed to globalContext's VO\n//    propertyName: foo,\n//}\n```\n\n当引用 foo 变量的时候，首先便会得到一个 fooReferenceType，然后每一个 RT 都有一个获取属性值的方法(GetValue)，这样就解决了属性访问的问题(其实说到可以发现，JS 里所有的变量访问都是属性访问，只不过没有指定 object 的地方基本上使用的 SC 上一层 VO/AO)。\n##### this 绑定\nthis 的使用一般是如下情况：\n\n```javascript\nfunction func() {\n    console.log(this.x);\n}\nvar obj = {x:1};\nobj.func();\n```\n\n这里在 func 的内部如何知道 this 这个 object 是什么呢？这里就涉及到了 this 的 binding 问题。\n其实 this 的绑定规则很简单，可以这么说 **this 的绑定完全由 function 的调用方式决定**，这是因为 this 绑定的 object 就是 **function 前面的变量的 RT 的 base**。\n\n```javascript\nvar obj1 = {\n    x: 1,\n    func:function() {\n        console.log(this.x);\n        },\n};\nvar obj2 = {\n    x: 2,\n    func: undefined,\n};\nobj1.func(); // output 1\nobj2.func = obj1.func;\nobj2.func(); // output 2\n(obj2.func = obj1.func)(); // output undefined\n```\n\n这是一个很经典的例子，1 和 2 的输出根据上面的理论是理所当然的结果，但是最后一个 undefined 的结果可能就有点令人费解了。它背后的机制是这样的，`(obj2.func = obj1.func)` 括号内一个表达式，并不是一个变量名(identifier)，当然也不是属性访问器(property accessor)，因此对它解析不会产生 RT，也因此其 this 的绑定为 null，而 null 作为 this 的值在 non-strict 模式下是会被转化成 globalContext 的 VO 的。\n\n## ES5\n### Call Stack\n将 EC 的称谓正式变为 Call Stack，本质并没有太多变化。\n### Environment\nES5 管理变量的方式发生了比较大的变化，首先不在使用 VO 和 AO 了，统一成了 Environment，但是 Environment 分为两类，Variable Environment(VE) 和 Lexical Environment(LE) 两种，但是和 VO/AO 的分类并没有直接关系，其实 VE 本质上和 ES3 中的 VO/AO 是同一个东西，负责管理所有的变量访问，LE 的提出是为了解决这样一个特定问题：**with 下的 function expression 中的变量访问**：\n```javascript\nvar x = 1;\nfunction foo() {\n    console.log(x);\n}\n \nwith ({x: 2}) {\n    // this is a function expression\n    var bar = function () {\n        console.log(x);\n    };\n    foo(); // 1, from VariableEnvrionment\n    bar(); // 2, from LexicalEnvrionment\n}\nfoo(); // 1\nbar(); // still 2\n```\n其实一般情况下，LE 只是 VE 的一个复制值，但是当出现例子这种情况的时候，必须在不破坏 VE 的情况下(因为 `foo` 的调用需要用到 `x = 1`)，同时提供另一套 `{x: 2}` 会被先访问的 Environment(`bar` 的调用要用到 `x:2`)，于是会在进入 with block 的时候，保存好当前的 LE，同时改变 LE 为需要的 LE，在 with block 结束的时候恢复。\n### Enviroment Record(ER)\n每一个 Environment 的结构会包含一个 ER 以及一个 outer，outer 其实就是上一层的 Environment，这点和 SC 很类似，不过是不完全一样的，下面的一个例子可以说明问题：\n```javascript\nvar x = 1;\nfunction func() {\n    var y = 2;\n}\n\nglobalEnvironment = {\n    environmentRecord: {\n \n        // built-ins:\n        Object: function,\n        Array: function,\n        // etc ...\n    \n        // our bindings:\n        x: 1,\n        func: function,\n\n    },\n \n    outer: null // no parent environment\n \n};\n \n// environment of the \"foo\" function\n \nfooEnvironment = {\n    environmentRecord: {\n        y: 2,\n    },\n    outer: globalEnvironment\n};\n```\n\n也许你有这样的疑惑，为什么需要做这样的改变呢？\n答案是为了 Efficiency！\n需要提到的是，规定(specification)并不提倡将 ER 实现为一个 simple object，这意味着各大 Engine 在这里可以提供自定义的优化！仔细想一想就会发现 SC 的设计会导致一层一层地查找某个变量，这个效率实在是太过低下，为什么不把会用到的变量放入当前 ER 中以提供直接的访问？此外还可以将不用到的变量不保存，这两点可以通过静态分析做到，V8 Engine 却是也是这样做的。\n此外 environment record 有两种类型 decorative environment record(VER) 和 object environment record(OER)，两者的区别在于前者处理 function activition 以及 catch 时的 environment record(相当于以前的 AO)，后者用于处理 global context 下的 function、variable 以及 with 语句下的变量 binding，这只是规定(specification)上的区别，在实际实现中，并没有这个标志来指定 ER 的区别。\n\n## 原型编程\n### \\_\\_proto__ 和 prototype 的区别\n在阐述原型之前，必须先澄清这两个概念的区别，其实说穿了也很简单，一个 object 的原型实际上就是 \\_\\_proto__，那么 prototype 又是什么呢？\n直接看如下一个例子：\n\n```javascript\nfunction Constructor() {\n    this.x = 3;\n}\nConstructor.prototype. y = 4;\nvar obj = new Constructor();\nconsole.log(obj.__proto__ === Constructor.prototype) //true\nconsole.log(obj.x, obj.y) //3, 4\n```\n看到这里你就知道了，当使用 `new Cnostructor()` 来创建对象的话，那么 Constructor 的 prototype 便会是新创建对象的 \\_\\_proto__。\n值得注意的是，上面这个例子中，x 和 y 的查询是不同的，x 属于 obj 自己的属性，而 y 是属于其原型的属性。\n\n因此一般说来，prototype 是 function 才有的属性，而所谓的原型编程实际上就是指使用 function 来进行 \\_\\_proto__ 的创建与传递。\n\n另外，这里给出 Object 和 Function 的 \\_\\_proto__ 和 prototype:（注意 Object 和 Funtion 都是 function 类型的）\n\n```nodejs\n> Function.__proto__\n[Function]\n> Function.__proto__.__proto__\n{}\n> Function.__proto__.__proto__.__proto__\nnull\n> Object.__proto__\n[Function]\n> Object.__proto__.__proto__\n{}\n> Object.__proto__.__proto__.__proto__\nnull\n> Function.prototype\n[Function]\n> Object.prototype\n{}\n```\n### 使用 prototype 来进行面向对象编程\n在 ES6 之前，并没有 class 的对象，但即使到了 ES6，所谓的 class 不过是 syntax sugar，本质其实还是 prototype 编程。\n面向对象的三大特点：封装、继承、多态，下面依次阐述。\n#### 封装\n这个现在即使在 ES6 也没有很好地解决办法，目前所知道的方法有两种\n1. ES7 中出现以 # 表示私有属性\n2. 此外使用 ES6 的 Symbol 也可以达到模拟私有属性的效果\n\n#### 继承\n这个在 ES6 之前的版本，其实是有方法进行继承模拟的，可以看下面的一个例子：\n\n```javascript\nfunction SupCls() {\n    this.x = 1;\n}\nSupCls.prototype.y = 2;\nvar supCls = new SupCls();\nconsole.log(supCls.x, supCls.y);\n// output: 1, 2\n\n// now we will make an inheritance\nfunction SubCls() {\n    this.z = 3;\n}\nSubCls.prototype = new SupCls();\nSubCls.prototype.constructor = SubCls;\nvar subCls = new SubCls();\nconsole.log(subCls.x, subCls.y, subCls.z);\n// output: 1, 2, 3\nconsole.log(subCls.__proto__);\n// output: SubCls { x: 1, constructor: [Function: SubCls] }\nconsole.log(subCls.hasOwnProperty('x'));\n// output: false\n```\n\n这里解释一下最关键的一步，`SubCls.prototype =  new SupCls()`，这可以使得新创建的 subCls 的 \\_\\_proto__ 是 SupCls 的 prototype，从而使得其具有父类的属性。\n\n除此之外还有一个令人迷惑的地方就是，为什么需要做 `SubCls.prototype.constructor = SubCls`？其实这步对于结果来说无关紧要，只是将 SubCls 的原型中的 constructor 指向正确的地方，如果没有这一步，上面的结果依然如此，也就是说 new 不会根据 prototype 的 constructor 来改变其行为，constructor 的存在只是给生成的 object 添加一个正确的引用。\n\n其实这里有一个陷阱，那就是最后一条语句表明，x 不是 subCls 的instance属性！为什么会这样其实很好理解，因为 x 根据我们的做法是属于 SubCls 的 prototype 的属性，自然也是属于 subCls 的 \\_\\_proto__ 属性。\n\n那么如何解决这个问题呢？\n其实很简单，无非就是把 SupCls 中的 this 换成我们想要的，也就是 SubCls 中的 this，做一次 binding 就行了。\n\n看下面的实现方式:\n\n```javascript\nfunction SupCls() {\n    this.x = 1;\n}\nSupCls.prototype.y = 2;\nvar supCls = new SupCls();\nconsole.log(supCls.x, supCls.y);\n// output: 1, 2\n\n// now we will make an inheritance\nfunction SubCls() {\n    this.z = 3;\n    // binding is done here\n    SubCls.supertype.constructor.apply(this);\n}\nSubCls.prototype = new SupCls();\nSubCls.prototype.constructor = SubCls;\nSubCls.supertype = SupCls.prototype;\nvar subCls = new SubCls();\nconsole.log(subCls.x, subCls.y, subCls.z);\n// output: 1, 2, 3\nconsole.log(subCls.__proto__);\n// output: SubCls { x: 1, constructor: [Function: SubCls] }\nconsole.log(subCls.hasOwnProperty('x'));\n// output: true\n```\n\n也许你以为到这里就解决问题了，但实际上还有一个问题！\n你可以发现，SupCls 这个 function 被调用了两次，而这个是可以避免的，为什么这么说？我们看这两次的调用时机：\n1. `SubCls.prototype = new SupCls();`\n2. `SubCls.supertype.constructor.apply(this);`\n\n明显可以发现第一次的调用其实没有必要，因此第一次的调用我们只是想要拿到 SupCls 的 prototype 信息，而不是以它为 constructor 创建的 instance 信息，所以为了避免这个，我们可以这样来结束讨论：\n```javascript\nfunction SupCls() {\n    this.x = 1;\n}\nSupCls.prototype.y = 2;\nvar supCls = new SupCls();\nconsole.log(supCls.x, supCls.y);\n// output: 1, 2\n\n// now we will make an inheritance\nfunction SubCls() {\n    this.z = 3;\n    // binding is done here\n    SubCls.supertype.constructor.apply(this);\n}\n\n// new part start\nfunction middleConstructor() {}\nmiddleConstructor.prototype = SupCls.prototype;\nSubCls.prototype = new middleConstructor();\n// new part end\n\nSubCls.prototype.constructor = SubCls;\nSubCls.supertype = SupCls.prototype;\nvar subCls = new SubCls();\nconsole.log(subCls.x, subCls.y, subCls.z);\n// output: 1, 2, 3\nconsole.log(subCls.__proto__);\n// output: SubCls { x: 1, constructor: [Function: SubCls] }\nconsole.log(subCls.hasOwnProperty('x'));\n// output: true\n```\n\n也许有人会有这样的疑惑，为什么不直接将 SupCls 的 prototype 赋给 SubCls 的 prototype，对此，我表示你自己一试，想一下就知道了原因了。\n\n根据 Dmitry Soshnikov 的说法，ES6 class 的继承就是通过这样的方法实现的，不过我认为应该还是有出入的，这个还需要仔细探究一下。","slug":"JavaScript-ES5-总结","published":1,"updated":"2017-05-21T13:54:50.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjbdyo31n000onf8ji2v20mau","content":"<h2 id=\"Abstract\"><a href=\"#Abstract\" class=\"headerlink\" title=\"Abstract\"></a>Abstract</h2><p>JavaScript 的语法让我感到非常不舒服，究其原因其实是因为两点：</p>\n<ol>\n<li>动态语言</li>\n<li>原型编程</li>\n</ol>\n<p>对于动态语言，我个人始终认为是不符合大型 project 的要求的，因为动态语言的特性导致阅读代码的时候非常不顺利，比如你看到一个 function 的参数时候，你完全不知道它是怎样的结构，但是像 Java 这样的强类型语言，每一个参数都有类型，就使得对于每一个参数你都知道它实实在在的含义（可以去查看参数类型的定义）。<br>此外原型编程，我迄今看不出其优势所在，不仅每一个对象的原型都可以被随意改变，而且根本没有访问控制。</p>\n<p>但尽管如此，我个人认为 JavaScript 还是更加现代化的编程语言，比如它的 function 可以作为对象任意传递，这一点和 Python 类似，对于异步编程可以说是非常直观地支持。<br>然而 JavaScript 的发展在 2015 年 ES6 发布后，就迎来了非常大的增强，我想为了更好的学习 ES6，对之前版本的深层次的理解还是需要的，相当于打好基础才能更好地前进。<br>在本篇 post 中，我主要是对自己看过的 Dmitry Soshnikov 的一系列关于 ES3-ES5 的 <a href=\"http://dmitrysoshnikov.com\" target=\"_blank\" rel=\"external\">posts</a> 总结，主要包含 JavaScript 中最迷惑人的两个部分：</p>\n<ol>\n<li>变量管理</li>\n<li>原型编程</li>\n</ol>\n<h2 id=\"变量管理\"><a href=\"#变量管理\" class=\"headerlink\" title=\"变量管理\"></a>变量管理</h2><p>这里使用的变量管理并不是指硬件层面的实现，而是指 JavaScript 的变量存储的抽象模型。另外，在概念上，ES3 和 ES5 有着几个区别，因此会分别描述。</p>\n<h3 id=\"ES3\"><a href=\"#ES3\" class=\"headerlink\" title=\"ES3\"></a>ES3</h3><h4 id=\"Execution-Context-EC\"><a href=\"#Execution-Context-EC\" class=\"headerlink\" title=\"Execution Context(EC)\"></a>Execution Context(EC)</h4><p>在 JavaScript 中有两种 EC：global context 和 function context。<br>不同的 context 的管理是用 stack 模式管理的，举个例子，在 global context 下定义了一个 function func，那么整个 EC stack 就是：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">EC Stack = &#123;</div><div class=\"line\">    funcContext,</div><div class=\"line\">    globalContext,</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>如果从 funcContext 退出那么，EC Stack 将会只剩下 globalContext，符合 Stack 的管理方式。<br>EC 有着许多重要的 property，用以在运行时使用，而在本篇 post 中，着重强调变量管理这一个问题，因此会探究其相关属性。</p>\n<h4 id=\"Variable-Object-VO-Activation-Object-AO\"><a href=\"#Variable-Object-VO-Activation-Object-AO\" class=\"headerlink\" title=\"Variable Object(VO) / Activation Object(AO)\"></a>Variable Object(VO) / Activation Object(AO)</h4><p>VO 和 AO 其实类似于符号表(symbol table)，用以集中管理变量，并且这是 EC 的属性，在 ES6 之前是没有 var 之外的变量定义方式的(有隐式定义变量，下面会提到)，而对 var 的处理会在<strong>静态分析</strong>进行，并且将定义的变量名填入 VO/AO，但是并不会直接对其赋值，而是等到执行到赋值语句的时候才会：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// now VO = &#123;</span></div><div class=\"line\"><span class=\"comment\">//     a: undefined,</span></div><div class=\"line\"><span class=\"comment\">// &#125;</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">console</span>.log(a); <span class=\"comment\">// undefined</span></div><div class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">13</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// now VO = &#123;</span></div><div class=\"line\"><span class=\"comment\">//     a: 13,</span></div><div class=\"line\"><span class=\"comment\">// &#125;</span></div></pre></td></tr></table></figure></p>\n<p>这里既然都是符号表，为什么有 VO 和 AO 的区别呢？<br>VO 其实是指 global context 的符号表，而 AO 是指 function context 的符号表，之所以有这两者的区别是因为 function context 有着不一样的符号管理，总共包括三类符号：</p>\n<ol>\n<li>arguments：即 function 的参数</li>\n<li>functions：function 内部定义的 function，在静态分析期间，如果符号与 arguments、variables 中的有冲突，直接替代(function 提升)</li>\n<li>variables：function 内部定义的变量，如果和 1、2 有冲突，在静态分析期间不会造成影响，在执行期间会直接替代 1 中的冲突项(理所当然的，后来覆盖)，与 2 的互相替代也符合后来覆盖原则</li>\n</ol>\n<p>直接看一个例子就知道区别了：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">func</span>(<span class=\"params\">f</span>)</span>&#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(f);</div><div class=\"line\">    <span class=\"keyword\">var</span> f = <span class=\"number\">4</span>;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\"></span>)</span>&#123;&#125;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(f);</div><div class=\"line\">&#125;</div><div class=\"line\">func(<span class=\"number\">3</span>);</div><div class=\"line\"><span class=\"comment\">// output:</span></div><div class=\"line\"><span class=\"comment\">// [Function: f]</span></div><div class=\"line\"><span class=\"comment\">// 4</span></div></pre></td></tr></table></figure></p>\n<p>这段的最后还要说明一下隐式声明的问题，上面提到如果直接给一个变量赋值(不用 var)也是可以的，但是其实不是向 VO 中添加符号，而是给当前的 EC 下的 this 变量添加了一个属性而已。<br>看下面的例子：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">x = <span class=\"number\">3</span>;</div><div class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">4</span>;</div><div class=\"line\"><span class=\"keyword\">delete</span> a;</div><div class=\"line\"><span class=\"keyword\">delete</span> x;</div><div class=\"line\"><span class=\"built_in\">console</span>.log(a); <span class=\"comment\">// 4</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(x); <span class=\"comment\">// Reference Error</span></div></pre></td></tr></table></figure></p>\n<h3 id=\"Scope-Chain-SC\"><a href=\"#Scope-Chain-SC\" class=\"headerlink\" title=\"Scope Chain(SC)\"></a>Scope Chain(SC)</h3><p>按道理说有了 EC 和 VO，那么便可以在任何一个特定的 EC 下进行变量访问，但是如果出现当前变量无法再当前 EC 下找到，那么该如何处理呢？为了解决这种情况，SC 被引入自然是很正常的事情，而 SC 和其他语言的构造方法基本一致：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">SC(ECStack[top]) = VO/AO + SC(ECStack[top<span class=\"number\">-1</span>]);</div><div class=\"line\">ECStack[<span class=\"number\">0</span>] === globalContext;</div></pre></td></tr></table></figure></p>\n<p>但需要注意的是，JavaScript 并没有 block 的概念，这是和其他主流语言的最大区别之一，也正因为如此只有 function 才能创造新的 context，因此常常会说一个 function 的 SC，但实际上是 EC 的 SC。因此对于 function 中的变量解析，自然是很重要的，但其实也很简单，只需要注意一点 <strong>function 的 SC 是静态分析确立的</strong>，会在运行前把需要用的变量的 Reference 记录下来：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> x = <span class=\"number\">3</span>;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">func</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(x);</div><div class=\"line\">&#125;</div><div class=\"line\">func(); <span class=\"comment\">// output: 3</span></div><div class=\"line\">x = <span class=\"number\">4</span>;</div><div class=\"line\">func(); <span class=\"comment\">// output: 4</span></div></pre></td></tr></table></figure></p>\n<p>此外，with 和 catch 会把其引入的变量加入到当前 SC 的最前面:<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">func</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> obj  = &#123;</div><div class=\"line\">        <span class=\"attr\">x</span>: <span class=\"number\">3</span>,</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">var</span> x = <span class=\"number\">4</span>;</div><div class=\"line\">    <span class=\"keyword\">with</span>(obj)&#123;</div><div class=\"line\">        <span class=\"built_in\">console</span>.log(x);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\">func();<span class=\"comment\">// output: 3</span></div></pre></td></tr></table></figure></p>\n<p>还有一点比较重要的是，因为 JavaScript 的有着 prototype，因此当顺着 SC 找到最后，可以访问到 Object 的 prototype 上去，可以看下面这个例子：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(x);</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"built_in\">Object</span>.prototype.x = <span class=\"number\">10</span>;</div><div class=\"line\">foo(); <span class=\"comment\">// 10</span></div></pre></td></tr></table></figure></p>\n<h4 id=\"属性访问\"><a href=\"#属性访问\" class=\"headerlink\" title=\"属性访问\"></a>属性访问</h4><p>讲到这里，有了 EC、VO、SC，我们看似便可以对几乎所有的变量进行访问了，但是还有一种情况没有考虑，那就是 object 的属性访问，而在属性访问中，还有一个特别的例子，就是 this 的属性访问。</p>\n<h5 id=\"Reference-Type-RT\"><a href=\"#Reference-Type-RT\" class=\"headerlink\" title=\"Reference Type(RT)\"></a>Reference Type(RT)</h5><p>属性访问问题解决的本质其实在于如何定义这样的访问方法，而 JS 的做法是通过 RT 来解决，RT 的产生只在两者情况下：</p>\n<ol>\n<li>处理变量名(identifier)[这里表明，普通变量的访问其实也是通过 RT 来解决的]</li>\n<li>处理属性访问符(property accessor)</li>\n</ol>\n<p>而 RT 的基本结构如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> foo = <span class=\"number\">3</span>;</div><div class=\"line\"><span class=\"comment\">// fooReferenceType = &#123;</span></div><div class=\"line\"><span class=\"comment\">//    base: null,  =&gt; null will be transformed to globalContext's VO</span></div><div class=\"line\"><span class=\"comment\">//    propertyName: foo,</span></div><div class=\"line\"><span class=\"comment\">//&#125;</span></div></pre></td></tr></table></figure>\n<p>当引用 foo 变量的时候，首先便会得到一个 fooReferenceType，然后每一个 RT 都有一个获取属性值的方法(GetValue)，这样就解决了属性访问的问题(其实说到可以发现，JS 里所有的变量访问都是属性访问，只不过没有指定 object 的地方基本上使用的 SC 上一层 VO/AO)。</p>\n<h5 id=\"this-绑定\"><a href=\"#this-绑定\" class=\"headerlink\" title=\"this 绑定\"></a>this 绑定</h5><p>this 的使用一般是如下情况：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">func</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.x);</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">var</span> obj = &#123;<span class=\"attr\">x</span>:<span class=\"number\">1</span>&#125;;</div><div class=\"line\">obj.func();</div></pre></td></tr></table></figure>\n<p>这里在 func 的内部如何知道 this 这个 object 是什么呢？这里就涉及到了 this 的 binding 问题。<br>其实 this 的绑定规则很简单，可以这么说 <strong>this 的绑定完全由 function 的调用方式决定</strong>，这是因为 this 绑定的 object 就是 <strong>function 前面的变量的 RT 的 base</strong>。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> obj1 = &#123;</div><div class=\"line\">    <span class=\"attr\">x</span>: <span class=\"number\">1</span>,</div><div class=\"line\">    <span class=\"attr\">func</span>:<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.x);</div><div class=\"line\">        &#125;,</div><div class=\"line\">&#125;;</div><div class=\"line\"><span class=\"keyword\">var</span> obj2 = &#123;</div><div class=\"line\">    <span class=\"attr\">x</span>: <span class=\"number\">2</span>,</div><div class=\"line\">    <span class=\"attr\">func</span>: <span class=\"literal\">undefined</span>,</div><div class=\"line\">&#125;;</div><div class=\"line\">obj1.func(); <span class=\"comment\">// output 1</span></div><div class=\"line\">obj2.func = obj1.func;</div><div class=\"line\">obj2.func(); <span class=\"comment\">// output 2</span></div><div class=\"line\">(obj2.func = obj1.func)(); <span class=\"comment\">// output undefined</span></div></pre></td></tr></table></figure>\n<p>这是一个很经典的例子，1 和 2 的输出根据上面的理论是理所当然的结果，但是最后一个 undefined 的结果可能就有点令人费解了。它背后的机制是这样的，<code>(obj2.func = obj1.func)</code> 括号内一个表达式，并不是一个变量名(identifier)，当然也不是属性访问器(property accessor)，因此对它解析不会产生 RT，也因此其 this 的绑定为 null，而 null 作为 this 的值在 non-strict 模式下是会被转化成 globalContext 的 VO 的。</p>\n<h2 id=\"ES5\"><a href=\"#ES5\" class=\"headerlink\" title=\"ES5\"></a>ES5</h2><h3 id=\"Call-Stack\"><a href=\"#Call-Stack\" class=\"headerlink\" title=\"Call Stack\"></a>Call Stack</h3><p>将 EC 的称谓正式变为 Call Stack，本质并没有太多变化。</p>\n<h3 id=\"Environment\"><a href=\"#Environment\" class=\"headerlink\" title=\"Environment\"></a>Environment</h3><p>ES5 管理变量的方式发生了比较大的变化，首先不在使用 VO 和 AO 了，统一成了 Environment，但是 Environment 分为两类，Variable Environment(VE) 和 Lexical Environment(LE) 两种，但是和 VO/AO 的分类并没有直接关系，其实 VE 本质上和 ES3 中的 VO/AO 是同一个东西，负责管理所有的变量访问，LE 的提出是为了解决这样一个特定问题：<strong>with 下的 function expression 中的变量访问</strong>：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> x = <span class=\"number\">1</span>;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(x);</div><div class=\"line\">&#125;</div><div class=\"line\"> </div><div class=\"line\"><span class=\"keyword\">with</span> (&#123;<span class=\"attr\">x</span>: <span class=\"number\">2</span>&#125;) &#123;</div><div class=\"line\">    <span class=\"comment\">// this is a function expression</span></div><div class=\"line\">    <span class=\"keyword\">var</span> bar = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">        <span class=\"built_in\">console</span>.log(x);</div><div class=\"line\">    &#125;;</div><div class=\"line\">    foo(); <span class=\"comment\">// 1, from VariableEnvrionment</span></div><div class=\"line\">    bar(); <span class=\"comment\">// 2, from LexicalEnvrionment</span></div><div class=\"line\">&#125;</div><div class=\"line\">foo(); <span class=\"comment\">// 1</span></div><div class=\"line\">bar(); <span class=\"comment\">// still 2</span></div></pre></td></tr></table></figure></p>\n<p>其实一般情况下，LE 只是 VE 的一个复制值，但是当出现例子这种情况的时候，必须在不破坏 VE 的情况下(因为 <code>foo</code> 的调用需要用到 <code>x = 1</code>)，同时提供另一套 <code>{x: 2}</code> 会被先访问的 Environment(<code>bar</code> 的调用要用到 <code>x:2</code>)，于是会在进入 with block 的时候，保存好当前的 LE，同时改变 LE 为需要的 LE，在 with block 结束的时候恢复。</p>\n<h3 id=\"Enviroment-Record-ER\"><a href=\"#Enviroment-Record-ER\" class=\"headerlink\" title=\"Enviroment Record(ER)\"></a>Enviroment Record(ER)</h3><p>每一个 Environment 的结构会包含一个 ER 以及一个 outer，outer 其实就是上一层的 Environment，这点和 SC 很类似，不过是不完全一样的，下面的一个例子可以说明问题：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> x = <span class=\"number\">1</span>;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">func</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> y = <span class=\"number\">2</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">globalEnvironment = &#123;</div><div class=\"line\">    <span class=\"attr\">environmentRecord</span>: &#123;</div><div class=\"line\"> </div><div class=\"line\">        <span class=\"comment\">// built-ins:</span></div><div class=\"line\">        <span class=\"built_in\">Object</span>: <span class=\"function\"><span class=\"keyword\">function</span>,</span></div><div class=\"line\">        <span class=\"title\">Array</span>: <span class=\"title\">function</span>,</div><div class=\"line\">        // <span class=\"title\">etc</span> ...</div><div class=\"line\">    </div><div class=\"line\">        // <span class=\"title\">our</span> <span class=\"title\">bindings</span>:</div><div class=\"line\">        <span class=\"title\">x</span>: 1,</div><div class=\"line\">        <span class=\"title\">func</span>: <span class=\"title\">function</span>,</div><div class=\"line\"></div><div class=\"line\">    &#125;,</div><div class=\"line\"> </div><div class=\"line\">    <span class=\"title\">outer</span>: <span class=\"title\">null</span> // <span class=\"title\">no</span> <span class=\"title\">parent</span> <span class=\"title\">environment</span></div><div class=\"line\"> </div><div class=\"line\">&#125;;</div><div class=\"line\"> </div><div class=\"line\">// <span class=\"title\">environment</span> <span class=\"title\">of</span> <span class=\"title\">the</span> \"<span class=\"title\">foo</span>\" <span class=\"title\">function</span></div><div class=\"line\"> </div><div class=\"line\"><span class=\"title\">fooEnvironment</span> = &#123;</div><div class=\"line\">    environmentRecord: &#123;</div><div class=\"line\">        <span class=\"attr\">y</span>: <span class=\"number\">2</span>,</div><div class=\"line\">    &#125;,</div><div class=\"line\">    <span class=\"attr\">outer</span>: globalEnvironment</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure></p>\n<p>也许你有这样的疑惑，为什么需要做这样的改变呢？<br>答案是为了 Efficiency！<br>需要提到的是，规定(specification)并不提倡将 ER 实现为一个 simple object，这意味着各大 Engine 在这里可以提供自定义的优化！仔细想一想就会发现 SC 的设计会导致一层一层地查找某个变量，这个效率实在是太过低下，为什么不把会用到的变量放入当前 ER 中以提供直接的访问？此外还可以将不用到的变量不保存，这两点可以通过静态分析做到，V8 Engine 却是也是这样做的。<br>此外 environment record 有两种类型 decorative environment record(VER) 和 object environment record(OER)，两者的区别在于前者处理 function activition 以及 catch 时的 environment record(相当于以前的 AO)，后者用于处理 global context 下的 function、variable 以及 with 语句下的变量 binding，这只是规定(specification)上的区别，在实际实现中，并没有这个标志来指定 ER 的区别。</p>\n<h2 id=\"原型编程\"><a href=\"#原型编程\" class=\"headerlink\" title=\"原型编程\"></a>原型编程</h2><h3 id=\"proto-和-prototype-的区别\"><a href=\"#proto-和-prototype-的区别\" class=\"headerlink\" title=\"__proto__ 和 prototype 的区别\"></a>__proto__ 和 prototype 的区别</h3><p>在阐述原型之前，必须先澄清这两个概念的区别，其实说穿了也很简单，一个 object 的原型实际上就是 __proto__，那么 prototype 又是什么呢？<br>直接看如下一个例子：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Constructor</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>.x = <span class=\"number\">3</span>;</div><div class=\"line\">&#125;</div><div class=\"line\">Constructor.prototype. y = <span class=\"number\">4</span>;</div><div class=\"line\"><span class=\"keyword\">var</span> obj = <span class=\"keyword\">new</span> Constructor();</div><div class=\"line\"><span class=\"built_in\">console</span>.log(obj.__proto__ === Constructor.prototype) <span class=\"comment\">//true</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(obj.x, obj.y) <span class=\"comment\">//3, 4</span></div></pre></td></tr></table></figure>\n<p>看到这里你就知道了，当使用 <code>new Cnostructor()</code> 来创建对象的话，那么 Constructor 的 prototype 便会是新创建对象的 __proto__。<br>值得注意的是，上面这个例子中，x 和 y 的查询是不同的，x 属于 obj 自己的属性，而 y 是属于其原型的属性。</p>\n<p>因此一般说来，prototype 是 function 才有的属性，而所谓的原型编程实际上就是指使用 function 来进行 __proto__ 的创建与传递。</p>\n<p>另外，这里给出 Object 和 Function 的 __proto__ 和 prototype:（注意 Object 和 Funtion 都是 function 类型的）</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">&gt; Function.__proto__</div><div class=\"line\">[Function]</div><div class=\"line\">&gt; Function.__proto__.__proto__</div><div class=\"line\">&#123;&#125;</div><div class=\"line\">&gt; Function.__proto__.__proto__.__proto__</div><div class=\"line\">null</div><div class=\"line\">&gt; Object.__proto__</div><div class=\"line\">[Function]</div><div class=\"line\">&gt; Object.__proto__.__proto__</div><div class=\"line\">&#123;&#125;</div><div class=\"line\">&gt; Object.__proto__.__proto__.__proto__</div><div class=\"line\">null</div><div class=\"line\">&gt; Function.prototype</div><div class=\"line\">[Function]</div><div class=\"line\">&gt; Object.prototype</div><div class=\"line\">&#123;&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"使用-prototype-来进行面向对象编程\"><a href=\"#使用-prototype-来进行面向对象编程\" class=\"headerlink\" title=\"使用 prototype 来进行面向对象编程\"></a>使用 prototype 来进行面向对象编程</h3><p>在 ES6 之前，并没有 class 的对象，但即使到了 ES6，所谓的 class 不过是 syntax sugar，本质其实还是 prototype 编程。<br>面向对象的三大特点：封装、继承、多态，下面依次阐述。</p>\n<h4 id=\"封装\"><a href=\"#封装\" class=\"headerlink\" title=\"封装\"></a>封装</h4><p>这个现在即使在 ES6 也没有很好地解决办法，目前所知道的方法有两种</p>\n<ol>\n<li>ES7 中出现以 # 表示私有属性</li>\n<li>此外使用 ES6 的 Symbol 也可以达到模拟私有属性的效果</li>\n</ol>\n<h4 id=\"继承\"><a href=\"#继承\" class=\"headerlink\" title=\"继承\"></a>继承</h4><p>这个在 ES6 之前的版本，其实是有方法进行继承模拟的，可以看下面的一个例子：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">SupCls</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>.x = <span class=\"number\">1</span>;</div><div class=\"line\">&#125;</div><div class=\"line\">SupCls.prototype.y = <span class=\"number\">2</span>;</div><div class=\"line\"><span class=\"keyword\">var</span> supCls = <span class=\"keyword\">new</span> SupCls();</div><div class=\"line\"><span class=\"built_in\">console</span>.log(supCls.x, supCls.y);</div><div class=\"line\"><span class=\"comment\">// output: 1, 2</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// now we will make an inheritance</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">SubCls</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>.z = <span class=\"number\">3</span>;</div><div class=\"line\">&#125;</div><div class=\"line\">SubCls.prototype = <span class=\"keyword\">new</span> SupCls();</div><div class=\"line\">SubCls.prototype.constructor = SubCls;</div><div class=\"line\"><span class=\"keyword\">var</span> subCls = <span class=\"keyword\">new</span> SubCls();</div><div class=\"line\"><span class=\"built_in\">console</span>.log(subCls.x, subCls.y, subCls.z);</div><div class=\"line\"><span class=\"comment\">// output: 1, 2, 3</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(subCls.__proto__);</div><div class=\"line\"><span class=\"comment\">// output: SubCls &#123; x: 1, constructor: [Function: SubCls] &#125;</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(subCls.hasOwnProperty(<span class=\"string\">'x'</span>));</div><div class=\"line\"><span class=\"comment\">// output: false</span></div></pre></td></tr></table></figure>\n<p>这里解释一下最关键的一步，<code>SubCls.prototype =  new SupCls()</code>，这可以使得新创建的 subCls 的 __proto__ 是 SupCls 的 prototype，从而使得其具有父类的属性。</p>\n<p>除此之外还有一个令人迷惑的地方就是，为什么需要做 <code>SubCls.prototype.constructor = SubCls</code>？其实这步对于结果来说无关紧要，只是将 SubCls 的原型中的 constructor 指向正确的地方，如果没有这一步，上面的结果依然如此，也就是说 new 不会根据 prototype 的 constructor 来改变其行为，constructor 的存在只是给生成的 object 添加一个正确的引用。</p>\n<p>其实这里有一个陷阱，那就是最后一条语句表明，x 不是 subCls 的instance属性！为什么会这样其实很好理解，因为 x 根据我们的做法是属于 SubCls 的 prototype 的属性，自然也是属于 subCls 的 __proto__ 属性。</p>\n<p>那么如何解决这个问题呢？<br>其实很简单，无非就是把 SupCls 中的 this 换成我们想要的，也就是 SubCls 中的 this，做一次 binding 就行了。</p>\n<p>看下面的实现方式:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">SupCls</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>.x = <span class=\"number\">1</span>;</div><div class=\"line\">&#125;</div><div class=\"line\">SupCls.prototype.y = <span class=\"number\">2</span>;</div><div class=\"line\"><span class=\"keyword\">var</span> supCls = <span class=\"keyword\">new</span> SupCls();</div><div class=\"line\"><span class=\"built_in\">console</span>.log(supCls.x, supCls.y);</div><div class=\"line\"><span class=\"comment\">// output: 1, 2</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// now we will make an inheritance</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">SubCls</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>.z = <span class=\"number\">3</span>;</div><div class=\"line\">    <span class=\"comment\">// binding is done here</span></div><div class=\"line\">    SubCls.supertype.constructor.apply(<span class=\"keyword\">this</span>);</div><div class=\"line\">&#125;</div><div class=\"line\">SubCls.prototype = <span class=\"keyword\">new</span> SupCls();</div><div class=\"line\">SubCls.prototype.constructor = SubCls;</div><div class=\"line\">SubCls.supertype = SupCls.prototype;</div><div class=\"line\"><span class=\"keyword\">var</span> subCls = <span class=\"keyword\">new</span> SubCls();</div><div class=\"line\"><span class=\"built_in\">console</span>.log(subCls.x, subCls.y, subCls.z);</div><div class=\"line\"><span class=\"comment\">// output: 1, 2, 3</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(subCls.__proto__);</div><div class=\"line\"><span class=\"comment\">// output: SubCls &#123; x: 1, constructor: [Function: SubCls] &#125;</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(subCls.hasOwnProperty(<span class=\"string\">'x'</span>));</div><div class=\"line\"><span class=\"comment\">// output: true</span></div></pre></td></tr></table></figure>\n<p>也许你以为到这里就解决问题了，但实际上还有一个问题！<br>你可以发现，SupCls 这个 function 被调用了两次，而这个是可以避免的，为什么这么说？我们看这两次的调用时机：</p>\n<ol>\n<li><code>SubCls.prototype = new SupCls();</code></li>\n<li><code>SubCls.supertype.constructor.apply(this);</code></li>\n</ol>\n<p>明显可以发现第一次的调用其实没有必要，因此第一次的调用我们只是想要拿到 SupCls 的 prototype 信息，而不是以它为 constructor 创建的 instance 信息，所以为了避免这个，我们可以这样来结束讨论：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">SupCls</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>.x = <span class=\"number\">1</span>;</div><div class=\"line\">&#125;</div><div class=\"line\">SupCls.prototype.y = <span class=\"number\">2</span>;</div><div class=\"line\"><span class=\"keyword\">var</span> supCls = <span class=\"keyword\">new</span> SupCls();</div><div class=\"line\"><span class=\"built_in\">console</span>.log(supCls.x, supCls.y);</div><div class=\"line\"><span class=\"comment\">// output: 1, 2</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// now we will make an inheritance</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">SubCls</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>.z = <span class=\"number\">3</span>;</div><div class=\"line\">    <span class=\"comment\">// binding is done here</span></div><div class=\"line\">    SubCls.supertype.constructor.apply(<span class=\"keyword\">this</span>);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// new part start</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">middleConstructor</span>(<span class=\"params\"></span>) </span>&#123;&#125;</div><div class=\"line\">middleConstructor.prototype = SupCls.prototype;</div><div class=\"line\">SubCls.prototype = <span class=\"keyword\">new</span> middleConstructor();</div><div class=\"line\"><span class=\"comment\">// new part end</span></div><div class=\"line\"></div><div class=\"line\">SubCls.prototype.constructor = SubCls;</div><div class=\"line\">SubCls.supertype = SupCls.prototype;</div><div class=\"line\"><span class=\"keyword\">var</span> subCls = <span class=\"keyword\">new</span> SubCls();</div><div class=\"line\"><span class=\"built_in\">console</span>.log(subCls.x, subCls.y, subCls.z);</div><div class=\"line\"><span class=\"comment\">// output: 1, 2, 3</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(subCls.__proto__);</div><div class=\"line\"><span class=\"comment\">// output: SubCls &#123; x: 1, constructor: [Function: SubCls] &#125;</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(subCls.hasOwnProperty(<span class=\"string\">'x'</span>));</div><div class=\"line\"><span class=\"comment\">// output: true</span></div></pre></td></tr></table></figure></p>\n<p>也许有人会有这样的疑惑，为什么不直接将 SupCls 的 prototype 赋给 SubCls 的 prototype，对此，我表示你自己一试，想一下就知道了原因了。</p>\n<p>根据 Dmitry Soshnikov 的说法，ES6 class 的继承就是通过这样的方法实现的，不过我认为应该还是有出入的，这个还需要仔细探究一下。</p>\n","excerpt":"","more":"<h2 id=\"Abstract\"><a href=\"#Abstract\" class=\"headerlink\" title=\"Abstract\"></a>Abstract</h2><p>JavaScript 的语法让我感到非常不舒服，究其原因其实是因为两点：</p>\n<ol>\n<li>动态语言</li>\n<li>原型编程</li>\n</ol>\n<p>对于动态语言，我个人始终认为是不符合大型 project 的要求的，因为动态语言的特性导致阅读代码的时候非常不顺利，比如你看到一个 function 的参数时候，你完全不知道它是怎样的结构，但是像 Java 这样的强类型语言，每一个参数都有类型，就使得对于每一个参数你都知道它实实在在的含义（可以去查看参数类型的定义）。<br>此外原型编程，我迄今看不出其优势所在，不仅每一个对象的原型都可以被随意改变，而且根本没有访问控制。</p>\n<p>但尽管如此，我个人认为 JavaScript 还是更加现代化的编程语言，比如它的 function 可以作为对象任意传递，这一点和 Python 类似，对于异步编程可以说是非常直观地支持。<br>然而 JavaScript 的发展在 2015 年 ES6 发布后，就迎来了非常大的增强，我想为了更好的学习 ES6，对之前版本的深层次的理解还是需要的，相当于打好基础才能更好地前进。<br>在本篇 post 中，我主要是对自己看过的 Dmitry Soshnikov 的一系列关于 ES3-ES5 的 <a href=\"http://dmitrysoshnikov.com\">posts</a> 总结，主要包含 JavaScript 中最迷惑人的两个部分：</p>\n<ol>\n<li>变量管理</li>\n<li>原型编程</li>\n</ol>\n<h2 id=\"变量管理\"><a href=\"#变量管理\" class=\"headerlink\" title=\"变量管理\"></a>变量管理</h2><p>这里使用的变量管理并不是指硬件层面的实现，而是指 JavaScript 的变量存储的抽象模型。另外，在概念上，ES3 和 ES5 有着几个区别，因此会分别描述。</p>\n<h3 id=\"ES3\"><a href=\"#ES3\" class=\"headerlink\" title=\"ES3\"></a>ES3</h3><h4 id=\"Execution-Context-EC\"><a href=\"#Execution-Context-EC\" class=\"headerlink\" title=\"Execution Context(EC)\"></a>Execution Context(EC)</h4><p>在 JavaScript 中有两种 EC：global context 和 function context。<br>不同的 context 的管理是用 stack 模式管理的，举个例子，在 global context 下定义了一个 function func，那么整个 EC stack 就是：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">EC Stack = &#123;</div><div class=\"line\">    funcContext,</div><div class=\"line\">    globalContext,</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>如果从 funcContext 退出那么，EC Stack 将会只剩下 globalContext，符合 Stack 的管理方式。<br>EC 有着许多重要的 property，用以在运行时使用，而在本篇 post 中，着重强调变量管理这一个问题，因此会探究其相关属性。</p>\n<h4 id=\"Variable-Object-VO-Activation-Object-AO\"><a href=\"#Variable-Object-VO-Activation-Object-AO\" class=\"headerlink\" title=\"Variable Object(VO) / Activation Object(AO)\"></a>Variable Object(VO) / Activation Object(AO)</h4><p>VO 和 AO 其实类似于符号表(symbol table)，用以集中管理变量，并且这是 EC 的属性，在 ES6 之前是没有 var 之外的变量定义方式的(有隐式定义变量，下面会提到)，而对 var 的处理会在<strong>静态分析</strong>进行，并且将定义的变量名填入 VO/AO，但是并不会直接对其赋值，而是等到执行到赋值语句的时候才会：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// now VO = &#123;</span></div><div class=\"line\"><span class=\"comment\">//     a: undefined,</span></div><div class=\"line\"><span class=\"comment\">// &#125;</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">console</span>.log(a); <span class=\"comment\">// undefined</span></div><div class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">13</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// now VO = &#123;</span></div><div class=\"line\"><span class=\"comment\">//     a: 13,</span></div><div class=\"line\"><span class=\"comment\">// &#125;</span></div></pre></td></tr></table></figure></p>\n<p>这里既然都是符号表，为什么有 VO 和 AO 的区别呢？<br>VO 其实是指 global context 的符号表，而 AO 是指 function context 的符号表，之所以有这两者的区别是因为 function context 有着不一样的符号管理，总共包括三类符号：</p>\n<ol>\n<li>arguments：即 function 的参数</li>\n<li>functions：function 内部定义的 function，在静态分析期间，如果符号与 arguments、variables 中的有冲突，直接替代(function 提升)</li>\n<li>variables：function 内部定义的变量，如果和 1、2 有冲突，在静态分析期间不会造成影响，在执行期间会直接替代 1 中的冲突项(理所当然的，后来覆盖)，与 2 的互相替代也符合后来覆盖原则</li>\n</ol>\n<p>直接看一个例子就知道区别了：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">func</span>(<span class=\"params\">f</span>)</span>&#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(f);</div><div class=\"line\">    <span class=\"keyword\">var</span> f = <span class=\"number\">4</span>;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\"></span>)</span>&#123;&#125;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(f);</div><div class=\"line\">&#125;</div><div class=\"line\">func(<span class=\"number\">3</span>);</div><div class=\"line\"><span class=\"comment\">// output:</span></div><div class=\"line\"><span class=\"comment\">// [Function: f]</span></div><div class=\"line\"><span class=\"comment\">// 4</span></div></pre></td></tr></table></figure></p>\n<p>这段的最后还要说明一下隐式声明的问题，上面提到如果直接给一个变量赋值(不用 var)也是可以的，但是其实不是向 VO 中添加符号，而是给当前的 EC 下的 this 变量添加了一个属性而已。<br>看下面的例子：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">x = <span class=\"number\">3</span>;</div><div class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">4</span>;</div><div class=\"line\"><span class=\"keyword\">delete</span> a;</div><div class=\"line\"><span class=\"keyword\">delete</span> x;</div><div class=\"line\"><span class=\"built_in\">console</span>.log(a); <span class=\"comment\">// 4</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(x); <span class=\"comment\">// Reference Error</span></div></pre></td></tr></table></figure></p>\n<h3 id=\"Scope-Chain-SC\"><a href=\"#Scope-Chain-SC\" class=\"headerlink\" title=\"Scope Chain(SC)\"></a>Scope Chain(SC)</h3><p>按道理说有了 EC 和 VO，那么便可以在任何一个特定的 EC 下进行变量访问，但是如果出现当前变量无法再当前 EC 下找到，那么该如何处理呢？为了解决这种情况，SC 被引入自然是很正常的事情，而 SC 和其他语言的构造方法基本一致：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">SC(ECStack[top]) = VO/AO + SC(ECStack[top<span class=\"number\">-1</span>]);</div><div class=\"line\">ECStack[<span class=\"number\">0</span>] === globalContext;</div></pre></td></tr></table></figure></p>\n<p>但需要注意的是，JavaScript 并没有 block 的概念，这是和其他主流语言的最大区别之一，也正因为如此只有 function 才能创造新的 context，因此常常会说一个 function 的 SC，但实际上是 EC 的 SC。因此对于 function 中的变量解析，自然是很重要的，但其实也很简单，只需要注意一点 <strong>function 的 SC 是静态分析确立的</strong>，会在运行前把需要用的变量的 Reference 记录下来：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> x = <span class=\"number\">3</span>;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">func</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(x);</div><div class=\"line\">&#125;</div><div class=\"line\">func(); <span class=\"comment\">// output: 3</span></div><div class=\"line\">x = <span class=\"number\">4</span>;</div><div class=\"line\">func(); <span class=\"comment\">// output: 4</span></div></pre></td></tr></table></figure></p>\n<p>此外，with 和 catch 会把其引入的变量加入到当前 SC 的最前面:<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">func</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> obj  = &#123;</div><div class=\"line\">        <span class=\"attr\">x</span>: <span class=\"number\">3</span>,</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">var</span> x = <span class=\"number\">4</span>;</div><div class=\"line\">    <span class=\"keyword\">with</span>(obj)&#123;</div><div class=\"line\">        <span class=\"built_in\">console</span>.log(x);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\">func();<span class=\"comment\">// output: 3</span></div></pre></td></tr></table></figure></p>\n<p>还有一点比较重要的是，因为 JavaScript 的有着 prototype，因此当顺着 SC 找到最后，可以访问到 Object 的 prototype 上去，可以看下面这个例子：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(x);</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"built_in\">Object</span>.prototype.x = <span class=\"number\">10</span>;</div><div class=\"line\">foo(); <span class=\"comment\">// 10</span></div></pre></td></tr></table></figure></p>\n<h4 id=\"属性访问\"><a href=\"#属性访问\" class=\"headerlink\" title=\"属性访问\"></a>属性访问</h4><p>讲到这里，有了 EC、VO、SC，我们看似便可以对几乎所有的变量进行访问了，但是还有一种情况没有考虑，那就是 object 的属性访问，而在属性访问中，还有一个特别的例子，就是 this 的属性访问。</p>\n<h5 id=\"Reference-Type-RT\"><a href=\"#Reference-Type-RT\" class=\"headerlink\" title=\"Reference Type(RT)\"></a>Reference Type(RT)</h5><p>属性访问问题解决的本质其实在于如何定义这样的访问方法，而 JS 的做法是通过 RT 来解决，RT 的产生只在两者情况下：</p>\n<ol>\n<li>处理变量名(identifier)[这里表明，普通变量的访问其实也是通过 RT 来解决的]</li>\n<li>处理属性访问符(property accessor)</li>\n</ol>\n<p>而 RT 的基本结构如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> foo = <span class=\"number\">3</span>;</div><div class=\"line\"><span class=\"comment\">// fooReferenceType = &#123;</span></div><div class=\"line\"><span class=\"comment\">//    base: null,  =&gt; null will be transformed to globalContext's VO</span></div><div class=\"line\"><span class=\"comment\">//    propertyName: foo,</span></div><div class=\"line\"><span class=\"comment\">//&#125;</span></div></pre></td></tr></table></figure>\n<p>当引用 foo 变量的时候，首先便会得到一个 fooReferenceType，然后每一个 RT 都有一个获取属性值的方法(GetValue)，这样就解决了属性访问的问题(其实说到可以发现，JS 里所有的变量访问都是属性访问，只不过没有指定 object 的地方基本上使用的 SC 上一层 VO/AO)。</p>\n<h5 id=\"this-绑定\"><a href=\"#this-绑定\" class=\"headerlink\" title=\"this 绑定\"></a>this 绑定</h5><p>this 的使用一般是如下情况：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">func</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.x);</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">var</span> obj = &#123;<span class=\"attr\">x</span>:<span class=\"number\">1</span>&#125;;</div><div class=\"line\">obj.func();</div></pre></td></tr></table></figure>\n<p>这里在 func 的内部如何知道 this 这个 object 是什么呢？这里就涉及到了 this 的 binding 问题。<br>其实 this 的绑定规则很简单，可以这么说 <strong>this 的绑定完全由 function 的调用方式决定</strong>，这是因为 this 绑定的 object 就是 <strong>function 前面的变量的 RT 的 base</strong>。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> obj1 = &#123;</div><div class=\"line\">    <span class=\"attr\">x</span>: <span class=\"number\">1</span>,</div><div class=\"line\">    <span class=\"attr\">func</span>:<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.x);</div><div class=\"line\">        &#125;,</div><div class=\"line\">&#125;;</div><div class=\"line\"><span class=\"keyword\">var</span> obj2 = &#123;</div><div class=\"line\">    <span class=\"attr\">x</span>: <span class=\"number\">2</span>,</div><div class=\"line\">    <span class=\"attr\">func</span>: <span class=\"literal\">undefined</span>,</div><div class=\"line\">&#125;;</div><div class=\"line\">obj1.func(); <span class=\"comment\">// output 1</span></div><div class=\"line\">obj2.func = obj1.func;</div><div class=\"line\">obj2.func(); <span class=\"comment\">// output 2</span></div><div class=\"line\">(obj2.func = obj1.func)(); <span class=\"comment\">// output undefined</span></div></pre></td></tr></table></figure>\n<p>这是一个很经典的例子，1 和 2 的输出根据上面的理论是理所当然的结果，但是最后一个 undefined 的结果可能就有点令人费解了。它背后的机制是这样的，<code>(obj2.func = obj1.func)</code> 括号内一个表达式，并不是一个变量名(identifier)，当然也不是属性访问器(property accessor)，因此对它解析不会产生 RT，也因此其 this 的绑定为 null，而 null 作为 this 的值在 non-strict 模式下是会被转化成 globalContext 的 VO 的。</p>\n<h2 id=\"ES5\"><a href=\"#ES5\" class=\"headerlink\" title=\"ES5\"></a>ES5</h2><h3 id=\"Call-Stack\"><a href=\"#Call-Stack\" class=\"headerlink\" title=\"Call Stack\"></a>Call Stack</h3><p>将 EC 的称谓正式变为 Call Stack，本质并没有太多变化。</p>\n<h3 id=\"Environment\"><a href=\"#Environment\" class=\"headerlink\" title=\"Environment\"></a>Environment</h3><p>ES5 管理变量的方式发生了比较大的变化，首先不在使用 VO 和 AO 了，统一成了 Environment，但是 Environment 分为两类，Variable Environment(VE) 和 Lexical Environment(LE) 两种，但是和 VO/AO 的分类并没有直接关系，其实 VE 本质上和 ES3 中的 VO/AO 是同一个东西，负责管理所有的变量访问，LE 的提出是为了解决这样一个特定问题：<strong>with 下的 function expression 中的变量访问</strong>：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> x = <span class=\"number\">1</span>;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(x);</div><div class=\"line\">&#125;</div><div class=\"line\"> </div><div class=\"line\"><span class=\"keyword\">with</span> (&#123;<span class=\"attr\">x</span>: <span class=\"number\">2</span>&#125;) &#123;</div><div class=\"line\">    <span class=\"comment\">// this is a function expression</span></div><div class=\"line\">    <span class=\"keyword\">var</span> bar = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">        <span class=\"built_in\">console</span>.log(x);</div><div class=\"line\">    &#125;;</div><div class=\"line\">    foo(); <span class=\"comment\">// 1, from VariableEnvrionment</span></div><div class=\"line\">    bar(); <span class=\"comment\">// 2, from LexicalEnvrionment</span></div><div class=\"line\">&#125;</div><div class=\"line\">foo(); <span class=\"comment\">// 1</span></div><div class=\"line\">bar(); <span class=\"comment\">// still 2</span></div></pre></td></tr></table></figure></p>\n<p>其实一般情况下，LE 只是 VE 的一个复制值，但是当出现例子这种情况的时候，必须在不破坏 VE 的情况下(因为 <code>foo</code> 的调用需要用到 <code>x = 1</code>)，同时提供另一套 <code>{x: 2}</code> 会被先访问的 Environment(<code>bar</code> 的调用要用到 <code>x:2</code>)，于是会在进入 with block 的时候，保存好当前的 LE，同时改变 LE 为需要的 LE，在 with block 结束的时候恢复。</p>\n<h3 id=\"Enviroment-Record-ER\"><a href=\"#Enviroment-Record-ER\" class=\"headerlink\" title=\"Enviroment Record(ER)\"></a>Enviroment Record(ER)</h3><p>每一个 Environment 的结构会包含一个 ER 以及一个 outer，outer 其实就是上一层的 Environment，这点和 SC 很类似，不过是不完全一样的，下面的一个例子可以说明问题：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> x = <span class=\"number\">1</span>;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">func</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> y = <span class=\"number\">2</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">globalEnvironment = &#123;</div><div class=\"line\">    <span class=\"attr\">environmentRecord</span>: &#123;</div><div class=\"line\"> </div><div class=\"line\">        <span class=\"comment\">// built-ins:</span></div><div class=\"line\">        <span class=\"built_in\">Object</span>: <span class=\"function\"><span class=\"keyword\">function</span>,</div><div class=\"line\">        <span class=\"title\">Array</span>: <span class=\"title\">function</span>,</div><div class=\"line\">        // <span class=\"title\">etc</span> ...</div><div class=\"line\">    </div><div class=\"line\">        // <span class=\"title\">our</span> <span class=\"title\">bindings</span>:</div><div class=\"line\">        <span class=\"title\">x</span>: 1,</div><div class=\"line\">        <span class=\"title\">func</span>: <span class=\"title\">function</span>,</div><div class=\"line\"></div><div class=\"line\">    &#125;,</div><div class=\"line\"> </div><div class=\"line\">    <span class=\"title\">outer</span>: <span class=\"title\">null</span> // <span class=\"title\">no</span> <span class=\"title\">parent</span> <span class=\"title\">environment</span></div><div class=\"line\"> </div><div class=\"line\">&#125;;</div><div class=\"line\"> </div><div class=\"line\">// <span class=\"title\">environment</span> <span class=\"title\">of</span> <span class=\"title\">the</span> \"<span class=\"title\">foo</span>\" <span class=\"title\">function</span></div><div class=\"line\"> </div><div class=\"line\"><span class=\"title\">fooEnvironment</span> = </span>&#123;</div><div class=\"line\">    environmentRecord: &#123;</div><div class=\"line\">        <span class=\"attr\">y</span>: <span class=\"number\">2</span>,</div><div class=\"line\">    &#125;,</div><div class=\"line\">    <span class=\"attr\">outer</span>: globalEnvironment</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure></p>\n<p>也许你有这样的疑惑，为什么需要做这样的改变呢？<br>答案是为了 Efficiency！<br>需要提到的是，规定(specification)并不提倡将 ER 实现为一个 simple object，这意味着各大 Engine 在这里可以提供自定义的优化！仔细想一想就会发现 SC 的设计会导致一层一层地查找某个变量，这个效率实在是太过低下，为什么不把会用到的变量放入当前 ER 中以提供直接的访问？此外还可以将不用到的变量不保存，这两点可以通过静态分析做到，V8 Engine 却是也是这样做的。<br>此外 environment record 有两种类型 decorative environment record(VER) 和 object environment record(OER)，两者的区别在于前者处理 function activition 以及 catch 时的 environment record(相当于以前的 AO)，后者用于处理 global context 下的 function、variable 以及 with 语句下的变量 binding，这只是规定(specification)上的区别，在实际实现中，并没有这个标志来指定 ER 的区别。</p>\n<h2 id=\"原型编程\"><a href=\"#原型编程\" class=\"headerlink\" title=\"原型编程\"></a>原型编程</h2><h3 id=\"proto-和-prototype-的区别\"><a href=\"#proto-和-prototype-的区别\" class=\"headerlink\" title=\"__proto__ 和 prototype 的区别\"></a>__proto__ 和 prototype 的区别</h3><p>在阐述原型之前，必须先澄清这两个概念的区别，其实说穿了也很简单，一个 object 的原型实际上就是 __proto__，那么 prototype 又是什么呢？<br>直接看如下一个例子：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Constructor</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>.x = <span class=\"number\">3</span>;</div><div class=\"line\">&#125;</div><div class=\"line\">Constructor.prototype. y = <span class=\"number\">4</span>;</div><div class=\"line\"><span class=\"keyword\">var</span> obj = <span class=\"keyword\">new</span> Constructor();</div><div class=\"line\"><span class=\"built_in\">console</span>.log(obj.__proto__ === Constructor.prototype) <span class=\"comment\">//true</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(obj.x, obj.y) <span class=\"comment\">//3, 4</span></div></pre></td></tr></table></figure>\n<p>看到这里你就知道了，当使用 <code>new Cnostructor()</code> 来创建对象的话，那么 Constructor 的 prototype 便会是新创建对象的 __proto__。<br>值得注意的是，上面这个例子中，x 和 y 的查询是不同的，x 属于 obj 自己的属性，而 y 是属于其原型的属性。</p>\n<p>因此一般说来，prototype 是 function 才有的属性，而所谓的原型编程实际上就是指使用 function 来进行 __proto__ 的创建与传递。</p>\n<p>另外，这里给出 Object 和 Function 的 __proto__ 和 prototype:（注意 Object 和 Funtion 都是 function 类型的）</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">&gt; Function.__proto__</div><div class=\"line\">[Function]</div><div class=\"line\">&gt; Function.__proto__.__proto__</div><div class=\"line\">&#123;&#125;</div><div class=\"line\">&gt; Function.__proto__.__proto__.__proto__</div><div class=\"line\">null</div><div class=\"line\">&gt; Object.__proto__</div><div class=\"line\">[Function]</div><div class=\"line\">&gt; Object.__proto__.__proto__</div><div class=\"line\">&#123;&#125;</div><div class=\"line\">&gt; Object.__proto__.__proto__.__proto__</div><div class=\"line\">null</div><div class=\"line\">&gt; Function.prototype</div><div class=\"line\">[Function]</div><div class=\"line\">&gt; Object.prototype</div><div class=\"line\">&#123;&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"使用-prototype-来进行面向对象编程\"><a href=\"#使用-prototype-来进行面向对象编程\" class=\"headerlink\" title=\"使用 prototype 来进行面向对象编程\"></a>使用 prototype 来进行面向对象编程</h3><p>在 ES6 之前，并没有 class 的对象，但即使到了 ES6，所谓的 class 不过是 syntax sugar，本质其实还是 prototype 编程。<br>面向对象的三大特点：封装、继承、多态，下面依次阐述。</p>\n<h4 id=\"封装\"><a href=\"#封装\" class=\"headerlink\" title=\"封装\"></a>封装</h4><p>这个现在即使在 ES6 也没有很好地解决办法，目前所知道的方法有两种</p>\n<ol>\n<li>ES7 中出现以 # 表示私有属性</li>\n<li>此外使用 ES6 的 Symbol 也可以达到模拟私有属性的效果</li>\n</ol>\n<h4 id=\"继承\"><a href=\"#继承\" class=\"headerlink\" title=\"继承\"></a>继承</h4><p>这个在 ES6 之前的版本，其实是有方法进行继承模拟的，可以看下面的一个例子：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">SupCls</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>.x = <span class=\"number\">1</span>;</div><div class=\"line\">&#125;</div><div class=\"line\">SupCls.prototype.y = <span class=\"number\">2</span>;</div><div class=\"line\"><span class=\"keyword\">var</span> supCls = <span class=\"keyword\">new</span> SupCls();</div><div class=\"line\"><span class=\"built_in\">console</span>.log(supCls.x, supCls.y);</div><div class=\"line\"><span class=\"comment\">// output: 1, 2</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// now we will make an inheritance</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">SubCls</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>.z = <span class=\"number\">3</span>;</div><div class=\"line\">&#125;</div><div class=\"line\">SubCls.prototype = <span class=\"keyword\">new</span> SupCls();</div><div class=\"line\">SubCls.prototype.constructor = SubCls;</div><div class=\"line\"><span class=\"keyword\">var</span> subCls = <span class=\"keyword\">new</span> SubCls();</div><div class=\"line\"><span class=\"built_in\">console</span>.log(subCls.x, subCls.y, subCls.z);</div><div class=\"line\"><span class=\"comment\">// output: 1, 2, 3</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(subCls.__proto__);</div><div class=\"line\"><span class=\"comment\">// output: SubCls &#123; x: 1, constructor: [Function: SubCls] &#125;</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(subCls.hasOwnProperty(<span class=\"string\">'x'</span>));</div><div class=\"line\"><span class=\"comment\">// output: false</span></div></pre></td></tr></table></figure>\n<p>这里解释一下最关键的一步，<code>SubCls.prototype =  new SupCls()</code>，这可以使得新创建的 subCls 的 __proto__ 是 SupCls 的 prototype，从而使得其具有父类的属性。</p>\n<p>除此之外还有一个令人迷惑的地方就是，为什么需要做 <code>SubCls.prototype.constructor = SubCls</code>？其实这步对于结果来说无关紧要，只是将 SubCls 的原型中的 constructor 指向正确的地方，如果没有这一步，上面的结果依然如此，也就是说 new 不会根据 prototype 的 constructor 来改变其行为，constructor 的存在只是给生成的 object 添加一个正确的引用。</p>\n<p>其实这里有一个陷阱，那就是最后一条语句表明，x 不是 subCls 的instance属性！为什么会这样其实很好理解，因为 x 根据我们的做法是属于 SubCls 的 prototype 的属性，自然也是属于 subCls 的 __proto__ 属性。</p>\n<p>那么如何解决这个问题呢？<br>其实很简单，无非就是把 SupCls 中的 this 换成我们想要的，也就是 SubCls 中的 this，做一次 binding 就行了。</p>\n<p>看下面的实现方式:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">SupCls</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>.x = <span class=\"number\">1</span>;</div><div class=\"line\">&#125;</div><div class=\"line\">SupCls.prototype.y = <span class=\"number\">2</span>;</div><div class=\"line\"><span class=\"keyword\">var</span> supCls = <span class=\"keyword\">new</span> SupCls();</div><div class=\"line\"><span class=\"built_in\">console</span>.log(supCls.x, supCls.y);</div><div class=\"line\"><span class=\"comment\">// output: 1, 2</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// now we will make an inheritance</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">SubCls</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>.z = <span class=\"number\">3</span>;</div><div class=\"line\">    <span class=\"comment\">// binding is done here</span></div><div class=\"line\">    SubCls.supertype.constructor.apply(<span class=\"keyword\">this</span>);</div><div class=\"line\">&#125;</div><div class=\"line\">SubCls.prototype = <span class=\"keyword\">new</span> SupCls();</div><div class=\"line\">SubCls.prototype.constructor = SubCls;</div><div class=\"line\">SubCls.supertype = SupCls.prototype;</div><div class=\"line\"><span class=\"keyword\">var</span> subCls = <span class=\"keyword\">new</span> SubCls();</div><div class=\"line\"><span class=\"built_in\">console</span>.log(subCls.x, subCls.y, subCls.z);</div><div class=\"line\"><span class=\"comment\">// output: 1, 2, 3</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(subCls.__proto__);</div><div class=\"line\"><span class=\"comment\">// output: SubCls &#123; x: 1, constructor: [Function: SubCls] &#125;</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(subCls.hasOwnProperty(<span class=\"string\">'x'</span>));</div><div class=\"line\"><span class=\"comment\">// output: true</span></div></pre></td></tr></table></figure>\n<p>也许你以为到这里就解决问题了，但实际上还有一个问题！<br>你可以发现，SupCls 这个 function 被调用了两次，而这个是可以避免的，为什么这么说？我们看这两次的调用时机：</p>\n<ol>\n<li><code>SubCls.prototype = new SupCls();</code></li>\n<li><code>SubCls.supertype.constructor.apply(this);</code></li>\n</ol>\n<p>明显可以发现第一次的调用其实没有必要，因此第一次的调用我们只是想要拿到 SupCls 的 prototype 信息，而不是以它为 constructor 创建的 instance 信息，所以为了避免这个，我们可以这样来结束讨论：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">SupCls</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>.x = <span class=\"number\">1</span>;</div><div class=\"line\">&#125;</div><div class=\"line\">SupCls.prototype.y = <span class=\"number\">2</span>;</div><div class=\"line\"><span class=\"keyword\">var</span> supCls = <span class=\"keyword\">new</span> SupCls();</div><div class=\"line\"><span class=\"built_in\">console</span>.log(supCls.x, supCls.y);</div><div class=\"line\"><span class=\"comment\">// output: 1, 2</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// now we will make an inheritance</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">SubCls</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>.z = <span class=\"number\">3</span>;</div><div class=\"line\">    <span class=\"comment\">// binding is done here</span></div><div class=\"line\">    SubCls.supertype.constructor.apply(<span class=\"keyword\">this</span>);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// new part start</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">middleConstructor</span>(<span class=\"params\"></span>) </span>&#123;&#125;</div><div class=\"line\">middleConstructor.prototype = SupCls.prototype;</div><div class=\"line\">SubCls.prototype = <span class=\"keyword\">new</span> middleConstructor();</div><div class=\"line\"><span class=\"comment\">// new part end</span></div><div class=\"line\"></div><div class=\"line\">SubCls.prototype.constructor = SubCls;</div><div class=\"line\">SubCls.supertype = SupCls.prototype;</div><div class=\"line\"><span class=\"keyword\">var</span> subCls = <span class=\"keyword\">new</span> SubCls();</div><div class=\"line\"><span class=\"built_in\">console</span>.log(subCls.x, subCls.y, subCls.z);</div><div class=\"line\"><span class=\"comment\">// output: 1, 2, 3</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(subCls.__proto__);</div><div class=\"line\"><span class=\"comment\">// output: SubCls &#123; x: 1, constructor: [Function: SubCls] &#125;</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(subCls.hasOwnProperty(<span class=\"string\">'x'</span>));</div><div class=\"line\"><span class=\"comment\">// output: true</span></div></pre></td></tr></table></figure></p>\n<p>也许有人会有这样的疑惑，为什么不直接将 SupCls 的 prototype 赋给 SubCls 的 prototype，对此，我表示你自己一试，想一下就知道了原因了。</p>\n<p>根据 Dmitry Soshnikov 的说法，ES6 class 的继承就是通过这样的方法实现的，不过我认为应该还是有出入的，这个还需要仔细探究一下。</p>\n"},{"title":"React-源码阅读-Component-Mount","date":"2017-06-30T16:06:29.000Z","_content":"## Mount 一个 Component\n### callstack\nReactDomStackEntry => ReactMount => InstantiateReactComponent => CompositeComponent\n\n### ReactMount\nInterfaces:\n1. scrollMonitor\n2. renderSubtreeIntoContainer\n3. render\n4. unmountComponentAtNode\n\n### _renderNewRootComponent\n1. 检查\n2. call instantiateReactComponent 得到 componentInstance\n3. call ReactUpdates.batchedUpdates\n\n然后 ReactUpdates.batchedUpdates 会 call batchingStrategy.batchedUpdates，而这个实际上是在 call 一个在 ReactUpdates.injection 中注入 batchingStrategy，而实际上注入的是 ReactDefaultBatchingStragety，里面实际就是一个 transaction，并且除了一些特殊的初始化工作，就是调用了传给 ReactUpdates.bacthedUpdates 的 callback\n而这个 callback 是：batchedMountComponentIntoNode\n\n### batchedMountComponentIntoNode\n1. 实例化一个 ReactUpdates.ReactReconcileTransaction\n2. 然后 perform mountComponentIntoNode, 会传入 transcaction 和 instance\n\n这里需要了解一下 ReactUpdates.ReactReconcileTransaction, 这个变量和 ReactUpdates.batchUpdates 一样都是动态注入（其实我不明白为什么要这样做），默认的注入是在 ReactDomStackInjection 里面做的，里面做了大量的 transaction 必要的注入，此外还使用 pooledClass wrappert 一下来提升性能。\n\n和 batchingStrategy 一样，主要其实还是调用 callback。\n\n不过这个 transaction 的调用是这样的：\n\n```javascript\ntransaction.perform(\n    mountComponentIntoNode,\n    null,\n    componentInstance,\n    container,\n    transaction,\n    shouldReuseMarkup,\n    context,\n  );\n```\n也就是说把自己作为参数传给了 mountComponentIntoNode\n\n### mountComponentIntoNode\n1. call ReactReconciler.mountComponent 产生 markup\n2. 设置 `wrapperInstance._renderedComponent._topLevelWrapper = wrapperInstance`\n3. call _mountImageIntoNode 传入产生的 markup\n\n这里需要知道 ReactReconciler.mountComponent 是做什么的。\n```javascript\nmountComponent: function(\n    internalInstance,\n    transaction,\n    hostParent,\n    hostContainerInfo,\n    context,\n    parentDebugID, // 0 in production and for roots\n  ) {\n    if (__DEV__) {\n      if (internalInstance._debugID !== 0) {\n        ReactInstrumentation.debugTool.onBeforeMountComponent(\n          internalInstance._debugID,\n          internalInstance._currentElement,\n          parentDebugID,\n        );\n      }\n    }\n    var markup = internalInstance.mountComponent(\n      transaction,\n      hostParent,\n      hostContainerInfo,\n      context,\n      parentDebugID,\n    );\n    if (\n      internalInstance._currentElement &&\n      internalInstance._currentElement.ref != null\n    ) {\n      transaction.getReactMountReady().enqueue(attachRefs, internalInstance);\n    }\n    if (__DEV__) {\n      if (internalInstance._debugID !== 0) {\n        ReactInstrumentation.debugTool.onMountComponent(\n          internalInstance._debugID,\n        );\n      }\n    }\n    return markup;\n  }\n```\n这里可以看到是把 mount 的工作 delegate 给了 internalInstance.mountComponent, 所以我们还得去看 ReactComponent.mountCompoent 方法, 然而 react 内部其实没有 ReactComponent 这个类，看着它的 type 定义发现 ReactBaseClasses 是 React.Component, 但是又发现这个类，并没有什么 mountCompnent 定义，并且很多函数的定义都是 dummy 的（这里有点不明白），于是我想这应该是一个基类定义吧，然后我又找到了 ReactDOMComponent，这个似乎才是真正会使用到的 ReactComponent。\n\n在 mountComponent 中做了很多具体的工作，总结来说就是产生具体的 html element:\n\n```javascript\nif (!tagContent && omittedCloseTags[this._tag]) {\n        mountImage = tagOpen + '/>';\n      } else {\n        mountImage = tagOpen + '>' + tagContent + '</' + type + '>';\n      }\n}\n```\n\n值得一提的是，这个 mountImage 的含义是 html 内容的意思，并且还是 string 类型的，然后:\n\n```javascript\n/**\n   * Generates root tag markup then recurses. This method has side effects and\n   * is not idempotent.\n   *\n   * @internal\n   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction\n   * @param {?ReactDOMComponent} the parent component instance\n   * @param {?object} info about the host container\n   * @param {object} context\n   * @return {string} The computed markup.\n   */\n  mountComponent: function(\n    transaction,\n    hostParent,\n    hostContainerInfo,\n    context,\n  ) {\n      //...\n  }\n```\n\n注释里面表明 markup 也是类似的含义。\n\n### _mountImageIntoNode\n会根据 shouldReuseMarkup，\n**true**：\n获取 rootElement，call ReactMarkupChecksum 传入 markup， rootElement，如果返回 true，意味着可以使用 `ReactDOMComponentTree.precacheNode(instance, rootElement)` 来做到快速 mount，然后直接返回，所用的工作就算完成了。\n\n这里需要知道 React.MarkupChecksum.canReuseMarkup 的实现：\n```javascript\n/**\n   * @param {string} markup to use\n   * @param {DOMElement} element root React element\n   * @returns {boolean} whether or not the markup is the same\n   */\n  canReuseMarkup: function(markup, element) {\n    var existingChecksum = element.getAttribute(\n      ReactMarkupChecksum.CHECKSUM_ATTR_NAME,\n    );\n    existingChecksum = existingChecksum && parseInt(existingChecksum, 10);\n    var markupChecksum = adler32(markup);\n    return markupChecksum === existingChecksum;\n  }\n```\n这里一目了然，对于react render 出来的 element 肯定会把一个 checksum 存到  ReactMarkupChecksum.CHECKSUM\\_ATTR_NAME 中去。\n\n这里还需要知道 ReactDOMComponentTree.precachedNode 的具体实现：\n\n```javascript\n/**\n * Drill down (through composites and empty components) until we get a host or\n * host text component.\n *\n * This is pretty polymorphic but unavoidable with the current structure we have\n * for `_renderedChildren`.\n */\nfunction getRenderedHostOrTextFromComponent(component) {\n  var rendered;\n  while ((rendered = component._renderedComponent)) {\n    component = rendered;\n  }\n  return component;\n}\n\n//...\n\n/**\n * Populate `_hostNode` on the rendered host/text component with the given\n * DOM node. The passed `inst` can be a composite.\n */\nfunction precacheNode(inst, node) {\n  var hostInst = getRenderedHostOrTextFromComponent(inst);\n  hostInst._hostNode = node;\n  node[internalInstanceKey] = hostInst;\n}\n```\n\n这里非常需要知道 inst._renderedComponent 是什么。\n我找来找去发现，一个 instance 的 _renderedComponent 是在 ReactCompositeComponent 中赋值的：\n```javascript\nperformInitialMount: function(\n    renderedElement,\n    hostParent,\n    hostContainerInfo,\n    transaction,\n    context,\n  ) {\n    // If not a stateless component, we now render\n    if (renderedElement === undefined) {\n      renderedElement = this._renderValidatedComponent();\n    }\n\n    var nodeType = ReactNodeTypes.getType(renderedElement);\n    this._renderedNodeType = nodeType;\n    var child = this._instantiateReactComponent(\n      renderedElement,\n      nodeType !== ReactNodeTypes.EMPTY /* shouldHaveDebugID */,\n    );\n    this._renderedComponent = child;\n\n    var debugID = 0;\n    if (__DEV__) {\n      debugID = this._debugID;\n    }\n\n    var markup = ReactReconciler.mountComponent(\n      child,\n      transaction,\n      hostParent,\n      hostContainerInfo,\n      this._processChildContext(context),\n      debugID,\n    );\n\n    if (__DEV__) {\n      if (debugID !== 0) {\n        var childDebugIDs = child._debugID !== 0 ? [child._debugID] : [];\n        ReactInstrumentation.debugTool.onSetChildren(debugID, childDebugIDs);\n      }\n    }\n\n    return markup;\n  }\n```\n这段代码可以说是相当顶层的调用，所以不用太深入去看（因为我们正在一个 call stack 的追踪当中），记住我们的目的是要找到 _renderedComponent 的赋值语句，发现是：\n\n```javascript\nif (renderedElement === undefined) {\n      renderedElement = this._renderValidatedComponent();\n    }\n\nvar nodeType = ReactNodeTypes.getType(renderedElement);\nthis._renderedNodeType = nodeType;\nvar child = this._instantiateReactComponent(\n    renderedElement,\n    nodeType !== ReactNodeTypes.EMPTY /* shouldHaveDebugID */,\n);\nthis._renderedComponent = child;\n```\n（其实 renderedElement 是由 this 的 \\_constructComponent 函数生成的一个 ReactComponent Instance，所以之后用 this._instantiateReactComponent 生成出来的是 child，这个下面会仔细提到）\n它存储了一个 ReactComponent 的 instance，但是我们要知道，先前的代码是存在一个**链表**结构的，所以要注意之后 child 还被执行了什么操作————还被使用 ReactReconciler.mountComponent 执行了一遍，而这个 method 是被分析过的，并且它是通过调用 ReactComponent 的 Instance 的 mountComponent 的方法来进行真正的 mount 工作。\n\n循环调用：\nperformInitialMount => ReactReconciler.mountComponent => Component.mountComponent\n       ||                                                         ||\n        \\======================================================== /\n\n\n为了搞清楚这块调用逻辑，我试图追踪 this._renderedComponent 的改动轨迹：\n```javascript\n// 在 ReactCompositeComponent 中\nperformInitialMount: function(\n    renderedElement,\n    hostParent,\n    hostContainerInfo,\n    transaction,\n    context,\n  ) {\n    // If not a stateless component, we now render\n    if (renderedElement === undefined) {\n      renderedElement = this._renderValidatedComponent();\n    }\n\n    var nodeType = ReactNodeTypes.getType(renderedElement);\n    this._renderedNodeType = nodeType;\n    var child = this._instantiateReactComponent(\n      renderedElement,\n      nodeType !== ReactNodeTypes.EMPTY /* shouldHaveDebugID */,\n    );\n    this._renderedComponent = child;\n    //...\n    var markup = ReactReconciler.mountComponent(\n      child, // 这里被调用了\n      transaction,\n      hostParent,\n      hostContainerInfo,\n      this._processChildContext(context),\n      debugID,\n    );\n```\n\n这段代码中的 child 生成也是需要注意的，也就是说 this._instantiateReactComponent 这个 function 做的是什么事情呢？\n```javascript\n/**\n * Given a ReactNode, create an instance that will actually be mounted.\n *\n * @param {ReactNode} node\n * @param {boolean} shouldHaveDebugID\n * @return {object} A new instance of the element's constructor.\n * @protected\n */\nfunction instantiateReactComponent(node, shouldHaveDebugID) {\n  var instance;\n  //...\n```\n不深入这段代码可以发现这是一段根据 ReactNode（关于 ReactNode 的定义需要仔细研究）来 instance 一个 ReactComponent 的 instance 的方法。\n\n那么我们在深入到 ReactReconciler 的代码中看一下这个 child（ReactComponent 的 instance）究竟被用来做什么了。\n```javascript\n/**\n   * Initializes the component, renders markup, and registers event listeners.\n   *\n   * @param {ReactComponent} internalInstance\n   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction\n   * @param {?object} the containing host component instance\n   * @param {?object} info about the host container\n   * @return {?string} Rendered markup to be inserted into the DOM.\n   * @final\n   * @internal\n   */\n  mountComponent: function(\n    internalInstance,\n    transaction,\n    hostParent,\n    hostContainerInfo,\n    context,\n    parentDebugID, // 0 in production and for roots\n  ) {\n    if (__DEV__) {\n      if (internalInstance._debugID !== 0) {\n        ReactInstrumentation.debugTool.onBeforeMountComponent(\n          internalInstance._debugID,\n          internalInstance._currentElement,\n          parentDebugID,\n        );\n      }\n    }\n    var markup = internalInstance.mountComponent(// 直接又调用了 ReactComponent 的mountComponent 的方法\n      transaction,\n      hostParent,\n      hostContainerInfo,\n      context,\n      parentDebugID,\n    );\n//...\n```\n这里需要注意的是， 这个 internalInstance 是之前的 child，但是这个 child 不一定是 ReactCompositeComponent 类型的 Instance，也有可能是其他类型的 Component 的 Instance，不过我们可以先看，如果是 ReactCompositeComponent 类型的 Instance 的话，怎么处理？\n```javascript\n// ReactCompositeComponent.js\n/**\n   * Initializes the component, renders markup, and registers event listeners.\n   *\n   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction\n   * @param {?object} hostParent\n   * @param {?object} hostContainerInfo\n   * @param {?object} context\n   * @return {?string} Rendered markup to be inserted into the DOM.\n   * @final\n   * @internal\n   */\n  mountComponent: function(\n    transaction,\n    hostParent,\n    hostContainerInfo,\n    context,\n  ) {\n    this._context = context;\n    this._mountOrder = nextMountID++;\n    this._hostParent = hostParent;\n    this._hostContainerInfo = hostContainerInfo;\n\n    var publicProps = this._currentElement.props;\n    var publicContext = this._processContext(context);\n\n    var Component = this._currentElement.type;\n\n    var updateQueue = transaction.getUpdateQueue();\n\n    // Initialize the public class\n    var doConstruct = shouldConstruct(Component);\n    var inst = this._constructComponent(\n      doConstruct,\n      publicProps,\n      publicContext,\n      updateQueue,\n    );\n    var renderedElement; // 注意这个 renderedElement\n\n    // Support functional components\n    if (!doConstruct && (inst == null || inst.render == null)) {\n      renderedElement = inst; // 同时当 doConstruct 和 inst 为空的时候，持有一份 inst，应该其实就是空\n      if (__DEV__) {\n        warning(\n          !Component.childContextTypes,\n          '%s(...): childContextTypes cannot be defined on a functional component.',\n          Component.displayName || Component.name || 'Component',\n        );\n      }\n//...\n    var markup;\n    if (inst.unstable_handleError) {\n      markup = this.performInitialMountWithErrorHandling(\n        renderedElement,  \n        hostParent,\n        hostContainerInfo,\n        transaction,\n        context,\n      );\n    } else {\n      markup = this.performInitialMount(\n        renderedElement,\n        hostParent,\n        hostContainerInfo,\n        transaction,\n        context,\n      );\n    }\n\n```\n需要注意的是，这里的 this 其实就是之前的 child，所以这里会很奇怪，取了 child 的属性，然后又调用 _constructrComponent 方法来进行:\n```javascript\n_constructComponent: function(\n    doConstruct,\n    publicProps,\n    publicContext,\n    updateQueue,\n  ) {\n    if (__DEV__) {\n      ReactCurrentOwner.current = this;\n      try {\n        return this._constructComponentWithoutOwner(\n          doConstruct,\n          publicProps,\n          publicContext,\n          updateQueue,\n        );\n      } finally {\n        ReactCurrentOwner.current = null;\n      }\n    } else {\n      return this._constructComponentWithoutOwner(\n        doConstruct,\n        publicProps,\n        publicContext,\n        updateQueue,\n      );\n    }\n  },\n\n_constructComponentWithoutOwner: function(\n    doConstruct,\n    publicProps,\n    publicContext,\n    updateQueue,\n  ) {\n    var Component = this._currentElement.type; // 注意这里\n\n    if (doConstruct) {\n      if (__DEV__) {\n        return measureLifeCyclePerf(\n          () => new Component(publicProps, publicContext, updateQueue),\n          this._debugID,\n          'ctor',\n        );\n      } else {\n        return new Component(publicProps, publicContext, updateQueue);\n      }\n    }\n  }\n//...\n```\n\n最终 又新建了一个 Component 的 instance，我们来从一开始追溯到这里，看看 `var Component = this._currentElement.type` 这句里面的 Component 究竟和 child 是什么关系:\n`var Component = child._currentElement.type;` （因为这里的 this 就是 child）\n所以这里返回的又是和 child 本身类型相同的 Instance（也许这里类型不一致），非常古怪。\n\n然后在回到之前的代码，我们发现，performInitialMount method 又被调用了，并且传入 this 就是 child 和 renderedElement 就是 null 或者是上面提到的用 child 的 _currentElement.type 构造出来的 Instance。\n\n这个时候，我们发现原来：\n```javascript\n\nperformInitialMount: function(\n    renderedElement,\n    hostParent,\n    hostContainerInfo,\n    transaction,\n    context,\n  ) {\n    // If not a stateless component, we now render\n    if (renderedElement === undefined) {\n      renderedElement = this._renderValidatedComponent();\n    }\n    var nodeType = ReactNodeTypes.getType(renderedElement);\n    this._renderedNodeType = nodeType;\n    var child = this._instantiateReactComponent(\n      renderedElement,\n      nodeType !== ReactNodeTypes.EMPTY /* shouldHaveDebugID */,\n    );\n    this._renderedComponent = child;\n\n//...\n\n/**\n   * @private\n   */\n  _renderValidatedComponent: function() {\n    var renderedElement;\n    if (\n      __DEV__ ||\n      this._compositeType !== ReactCompositeComponentTypes.StatelessFunctional\n    ) {\n      ReactCurrentOwner.current = this;\n      try {\n        renderedElement = this._renderValidatedComponentWithoutOwnerOrContext();\n      } finally {\n        ReactCurrentOwner.current = null;\n      }\n    } else {\n      renderedElement = this._renderValidatedComponentWithoutOwnerOrContext();\n    }\n    invariant(\n      // TODO: An `isValidNode` function would probably be more appropriate\n      renderedElement === null ||\n        renderedElement === false ||\n        React.isValidElement(renderedElement),\n      '%s.render(): A valid React element (or null) must be returned. You may have ' +\n        'returned undefined, an array or some other invalid object.',\n      this.getName() || 'ReactCompositeComponent',\n    );\n\n    return renderedElement;\n  }\n\n//...\n\n _renderValidatedComponentWithoutOwnerOrContext: function() {\n    var inst = this._instance;\n    var renderedElement;\n\n    if (__DEV__) {\n      renderedElement = measureLifeCyclePerf(\n        () => inst.render(),\n        this._debugID,\n        'render',\n      );\n    } else {\n      renderedElement = inst.render();\n    }\n\n    if (__DEV__) {\n      // We allow auto-mocks to proceed as if they're returning null.\n      if (renderedElement === undefined && inst.render._isMockFunction) {\n        // This is probably bad practice. Consider warning here and\n        // deprecating this convenience.\n        renderedElement = null;\n      }\n    }\n\n    return renderedElement;\n  }\n```\n观察这三个方法，发现这个 链表 结构原来是如此搭建起来的，所以 precacheNode 做的遍历实际上就是找到最终的子节点，用一个 随机生成的 key 来存储。\n\n**false**：\n就不会进行上面的这一段处理，也就是说不会重用以前的 markup，而是直接生成将 markup 插入到响应的 dom node 里面去。\n","source":"_posts/React-源码阅读-Component-Mount.md","raw":"---\ntitle: React-源码阅读-Component-Mount\ndate: 2017-07-01 00:06:29\ntags: react\n---\n## Mount 一个 Component\n### callstack\nReactDomStackEntry => ReactMount => InstantiateReactComponent => CompositeComponent\n\n### ReactMount\nInterfaces:\n1. scrollMonitor\n2. renderSubtreeIntoContainer\n3. render\n4. unmountComponentAtNode\n\n### _renderNewRootComponent\n1. 检查\n2. call instantiateReactComponent 得到 componentInstance\n3. call ReactUpdates.batchedUpdates\n\n然后 ReactUpdates.batchedUpdates 会 call batchingStrategy.batchedUpdates，而这个实际上是在 call 一个在 ReactUpdates.injection 中注入 batchingStrategy，而实际上注入的是 ReactDefaultBatchingStragety，里面实际就是一个 transaction，并且除了一些特殊的初始化工作，就是调用了传给 ReactUpdates.bacthedUpdates 的 callback\n而这个 callback 是：batchedMountComponentIntoNode\n\n### batchedMountComponentIntoNode\n1. 实例化一个 ReactUpdates.ReactReconcileTransaction\n2. 然后 perform mountComponentIntoNode, 会传入 transcaction 和 instance\n\n这里需要了解一下 ReactUpdates.ReactReconcileTransaction, 这个变量和 ReactUpdates.batchUpdates 一样都是动态注入（其实我不明白为什么要这样做），默认的注入是在 ReactDomStackInjection 里面做的，里面做了大量的 transaction 必要的注入，此外还使用 pooledClass wrappert 一下来提升性能。\n\n和 batchingStrategy 一样，主要其实还是调用 callback。\n\n不过这个 transaction 的调用是这样的：\n\n```javascript\ntransaction.perform(\n    mountComponentIntoNode,\n    null,\n    componentInstance,\n    container,\n    transaction,\n    shouldReuseMarkup,\n    context,\n  );\n```\n也就是说把自己作为参数传给了 mountComponentIntoNode\n\n### mountComponentIntoNode\n1. call ReactReconciler.mountComponent 产生 markup\n2. 设置 `wrapperInstance._renderedComponent._topLevelWrapper = wrapperInstance`\n3. call _mountImageIntoNode 传入产生的 markup\n\n这里需要知道 ReactReconciler.mountComponent 是做什么的。\n```javascript\nmountComponent: function(\n    internalInstance,\n    transaction,\n    hostParent,\n    hostContainerInfo,\n    context,\n    parentDebugID, // 0 in production and for roots\n  ) {\n    if (__DEV__) {\n      if (internalInstance._debugID !== 0) {\n        ReactInstrumentation.debugTool.onBeforeMountComponent(\n          internalInstance._debugID,\n          internalInstance._currentElement,\n          parentDebugID,\n        );\n      }\n    }\n    var markup = internalInstance.mountComponent(\n      transaction,\n      hostParent,\n      hostContainerInfo,\n      context,\n      parentDebugID,\n    );\n    if (\n      internalInstance._currentElement &&\n      internalInstance._currentElement.ref != null\n    ) {\n      transaction.getReactMountReady().enqueue(attachRefs, internalInstance);\n    }\n    if (__DEV__) {\n      if (internalInstance._debugID !== 0) {\n        ReactInstrumentation.debugTool.onMountComponent(\n          internalInstance._debugID,\n        );\n      }\n    }\n    return markup;\n  }\n```\n这里可以看到是把 mount 的工作 delegate 给了 internalInstance.mountComponent, 所以我们还得去看 ReactComponent.mountCompoent 方法, 然而 react 内部其实没有 ReactComponent 这个类，看着它的 type 定义发现 ReactBaseClasses 是 React.Component, 但是又发现这个类，并没有什么 mountCompnent 定义，并且很多函数的定义都是 dummy 的（这里有点不明白），于是我想这应该是一个基类定义吧，然后我又找到了 ReactDOMComponent，这个似乎才是真正会使用到的 ReactComponent。\n\n在 mountComponent 中做了很多具体的工作，总结来说就是产生具体的 html element:\n\n```javascript\nif (!tagContent && omittedCloseTags[this._tag]) {\n        mountImage = tagOpen + '/>';\n      } else {\n        mountImage = tagOpen + '>' + tagContent + '</' + type + '>';\n      }\n}\n```\n\n值得一提的是，这个 mountImage 的含义是 html 内容的意思，并且还是 string 类型的，然后:\n\n```javascript\n/**\n   * Generates root tag markup then recurses. This method has side effects and\n   * is not idempotent.\n   *\n   * @internal\n   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction\n   * @param {?ReactDOMComponent} the parent component instance\n   * @param {?object} info about the host container\n   * @param {object} context\n   * @return {string} The computed markup.\n   */\n  mountComponent: function(\n    transaction,\n    hostParent,\n    hostContainerInfo,\n    context,\n  ) {\n      //...\n  }\n```\n\n注释里面表明 markup 也是类似的含义。\n\n### _mountImageIntoNode\n会根据 shouldReuseMarkup，\n**true**：\n获取 rootElement，call ReactMarkupChecksum 传入 markup， rootElement，如果返回 true，意味着可以使用 `ReactDOMComponentTree.precacheNode(instance, rootElement)` 来做到快速 mount，然后直接返回，所用的工作就算完成了。\n\n这里需要知道 React.MarkupChecksum.canReuseMarkup 的实现：\n```javascript\n/**\n   * @param {string} markup to use\n   * @param {DOMElement} element root React element\n   * @returns {boolean} whether or not the markup is the same\n   */\n  canReuseMarkup: function(markup, element) {\n    var existingChecksum = element.getAttribute(\n      ReactMarkupChecksum.CHECKSUM_ATTR_NAME,\n    );\n    existingChecksum = existingChecksum && parseInt(existingChecksum, 10);\n    var markupChecksum = adler32(markup);\n    return markupChecksum === existingChecksum;\n  }\n```\n这里一目了然，对于react render 出来的 element 肯定会把一个 checksum 存到  ReactMarkupChecksum.CHECKSUM\\_ATTR_NAME 中去。\n\n这里还需要知道 ReactDOMComponentTree.precachedNode 的具体实现：\n\n```javascript\n/**\n * Drill down (through composites and empty components) until we get a host or\n * host text component.\n *\n * This is pretty polymorphic but unavoidable with the current structure we have\n * for `_renderedChildren`.\n */\nfunction getRenderedHostOrTextFromComponent(component) {\n  var rendered;\n  while ((rendered = component._renderedComponent)) {\n    component = rendered;\n  }\n  return component;\n}\n\n//...\n\n/**\n * Populate `_hostNode` on the rendered host/text component with the given\n * DOM node. The passed `inst` can be a composite.\n */\nfunction precacheNode(inst, node) {\n  var hostInst = getRenderedHostOrTextFromComponent(inst);\n  hostInst._hostNode = node;\n  node[internalInstanceKey] = hostInst;\n}\n```\n\n这里非常需要知道 inst._renderedComponent 是什么。\n我找来找去发现，一个 instance 的 _renderedComponent 是在 ReactCompositeComponent 中赋值的：\n```javascript\nperformInitialMount: function(\n    renderedElement,\n    hostParent,\n    hostContainerInfo,\n    transaction,\n    context,\n  ) {\n    // If not a stateless component, we now render\n    if (renderedElement === undefined) {\n      renderedElement = this._renderValidatedComponent();\n    }\n\n    var nodeType = ReactNodeTypes.getType(renderedElement);\n    this._renderedNodeType = nodeType;\n    var child = this._instantiateReactComponent(\n      renderedElement,\n      nodeType !== ReactNodeTypes.EMPTY /* shouldHaveDebugID */,\n    );\n    this._renderedComponent = child;\n\n    var debugID = 0;\n    if (__DEV__) {\n      debugID = this._debugID;\n    }\n\n    var markup = ReactReconciler.mountComponent(\n      child,\n      transaction,\n      hostParent,\n      hostContainerInfo,\n      this._processChildContext(context),\n      debugID,\n    );\n\n    if (__DEV__) {\n      if (debugID !== 0) {\n        var childDebugIDs = child._debugID !== 0 ? [child._debugID] : [];\n        ReactInstrumentation.debugTool.onSetChildren(debugID, childDebugIDs);\n      }\n    }\n\n    return markup;\n  }\n```\n这段代码可以说是相当顶层的调用，所以不用太深入去看（因为我们正在一个 call stack 的追踪当中），记住我们的目的是要找到 _renderedComponent 的赋值语句，发现是：\n\n```javascript\nif (renderedElement === undefined) {\n      renderedElement = this._renderValidatedComponent();\n    }\n\nvar nodeType = ReactNodeTypes.getType(renderedElement);\nthis._renderedNodeType = nodeType;\nvar child = this._instantiateReactComponent(\n    renderedElement,\n    nodeType !== ReactNodeTypes.EMPTY /* shouldHaveDebugID */,\n);\nthis._renderedComponent = child;\n```\n（其实 renderedElement 是由 this 的 \\_constructComponent 函数生成的一个 ReactComponent Instance，所以之后用 this._instantiateReactComponent 生成出来的是 child，这个下面会仔细提到）\n它存储了一个 ReactComponent 的 instance，但是我们要知道，先前的代码是存在一个**链表**结构的，所以要注意之后 child 还被执行了什么操作————还被使用 ReactReconciler.mountComponent 执行了一遍，而这个 method 是被分析过的，并且它是通过调用 ReactComponent 的 Instance 的 mountComponent 的方法来进行真正的 mount 工作。\n\n循环调用：\nperformInitialMount => ReactReconciler.mountComponent => Component.mountComponent\n       ||                                                         ||\n        \\======================================================== /\n\n\n为了搞清楚这块调用逻辑，我试图追踪 this._renderedComponent 的改动轨迹：\n```javascript\n// 在 ReactCompositeComponent 中\nperformInitialMount: function(\n    renderedElement,\n    hostParent,\n    hostContainerInfo,\n    transaction,\n    context,\n  ) {\n    // If not a stateless component, we now render\n    if (renderedElement === undefined) {\n      renderedElement = this._renderValidatedComponent();\n    }\n\n    var nodeType = ReactNodeTypes.getType(renderedElement);\n    this._renderedNodeType = nodeType;\n    var child = this._instantiateReactComponent(\n      renderedElement,\n      nodeType !== ReactNodeTypes.EMPTY /* shouldHaveDebugID */,\n    );\n    this._renderedComponent = child;\n    //...\n    var markup = ReactReconciler.mountComponent(\n      child, // 这里被调用了\n      transaction,\n      hostParent,\n      hostContainerInfo,\n      this._processChildContext(context),\n      debugID,\n    );\n```\n\n这段代码中的 child 生成也是需要注意的，也就是说 this._instantiateReactComponent 这个 function 做的是什么事情呢？\n```javascript\n/**\n * Given a ReactNode, create an instance that will actually be mounted.\n *\n * @param {ReactNode} node\n * @param {boolean} shouldHaveDebugID\n * @return {object} A new instance of the element's constructor.\n * @protected\n */\nfunction instantiateReactComponent(node, shouldHaveDebugID) {\n  var instance;\n  //...\n```\n不深入这段代码可以发现这是一段根据 ReactNode（关于 ReactNode 的定义需要仔细研究）来 instance 一个 ReactComponent 的 instance 的方法。\n\n那么我们在深入到 ReactReconciler 的代码中看一下这个 child（ReactComponent 的 instance）究竟被用来做什么了。\n```javascript\n/**\n   * Initializes the component, renders markup, and registers event listeners.\n   *\n   * @param {ReactComponent} internalInstance\n   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction\n   * @param {?object} the containing host component instance\n   * @param {?object} info about the host container\n   * @return {?string} Rendered markup to be inserted into the DOM.\n   * @final\n   * @internal\n   */\n  mountComponent: function(\n    internalInstance,\n    transaction,\n    hostParent,\n    hostContainerInfo,\n    context,\n    parentDebugID, // 0 in production and for roots\n  ) {\n    if (__DEV__) {\n      if (internalInstance._debugID !== 0) {\n        ReactInstrumentation.debugTool.onBeforeMountComponent(\n          internalInstance._debugID,\n          internalInstance._currentElement,\n          parentDebugID,\n        );\n      }\n    }\n    var markup = internalInstance.mountComponent(// 直接又调用了 ReactComponent 的mountComponent 的方法\n      transaction,\n      hostParent,\n      hostContainerInfo,\n      context,\n      parentDebugID,\n    );\n//...\n```\n这里需要注意的是， 这个 internalInstance 是之前的 child，但是这个 child 不一定是 ReactCompositeComponent 类型的 Instance，也有可能是其他类型的 Component 的 Instance，不过我们可以先看，如果是 ReactCompositeComponent 类型的 Instance 的话，怎么处理？\n```javascript\n// ReactCompositeComponent.js\n/**\n   * Initializes the component, renders markup, and registers event listeners.\n   *\n   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction\n   * @param {?object} hostParent\n   * @param {?object} hostContainerInfo\n   * @param {?object} context\n   * @return {?string} Rendered markup to be inserted into the DOM.\n   * @final\n   * @internal\n   */\n  mountComponent: function(\n    transaction,\n    hostParent,\n    hostContainerInfo,\n    context,\n  ) {\n    this._context = context;\n    this._mountOrder = nextMountID++;\n    this._hostParent = hostParent;\n    this._hostContainerInfo = hostContainerInfo;\n\n    var publicProps = this._currentElement.props;\n    var publicContext = this._processContext(context);\n\n    var Component = this._currentElement.type;\n\n    var updateQueue = transaction.getUpdateQueue();\n\n    // Initialize the public class\n    var doConstruct = shouldConstruct(Component);\n    var inst = this._constructComponent(\n      doConstruct,\n      publicProps,\n      publicContext,\n      updateQueue,\n    );\n    var renderedElement; // 注意这个 renderedElement\n\n    // Support functional components\n    if (!doConstruct && (inst == null || inst.render == null)) {\n      renderedElement = inst; // 同时当 doConstruct 和 inst 为空的时候，持有一份 inst，应该其实就是空\n      if (__DEV__) {\n        warning(\n          !Component.childContextTypes,\n          '%s(...): childContextTypes cannot be defined on a functional component.',\n          Component.displayName || Component.name || 'Component',\n        );\n      }\n//...\n    var markup;\n    if (inst.unstable_handleError) {\n      markup = this.performInitialMountWithErrorHandling(\n        renderedElement,  \n        hostParent,\n        hostContainerInfo,\n        transaction,\n        context,\n      );\n    } else {\n      markup = this.performInitialMount(\n        renderedElement,\n        hostParent,\n        hostContainerInfo,\n        transaction,\n        context,\n      );\n    }\n\n```\n需要注意的是，这里的 this 其实就是之前的 child，所以这里会很奇怪，取了 child 的属性，然后又调用 _constructrComponent 方法来进行:\n```javascript\n_constructComponent: function(\n    doConstruct,\n    publicProps,\n    publicContext,\n    updateQueue,\n  ) {\n    if (__DEV__) {\n      ReactCurrentOwner.current = this;\n      try {\n        return this._constructComponentWithoutOwner(\n          doConstruct,\n          publicProps,\n          publicContext,\n          updateQueue,\n        );\n      } finally {\n        ReactCurrentOwner.current = null;\n      }\n    } else {\n      return this._constructComponentWithoutOwner(\n        doConstruct,\n        publicProps,\n        publicContext,\n        updateQueue,\n      );\n    }\n  },\n\n_constructComponentWithoutOwner: function(\n    doConstruct,\n    publicProps,\n    publicContext,\n    updateQueue,\n  ) {\n    var Component = this._currentElement.type; // 注意这里\n\n    if (doConstruct) {\n      if (__DEV__) {\n        return measureLifeCyclePerf(\n          () => new Component(publicProps, publicContext, updateQueue),\n          this._debugID,\n          'ctor',\n        );\n      } else {\n        return new Component(publicProps, publicContext, updateQueue);\n      }\n    }\n  }\n//...\n```\n\n最终 又新建了一个 Component 的 instance，我们来从一开始追溯到这里，看看 `var Component = this._currentElement.type` 这句里面的 Component 究竟和 child 是什么关系:\n`var Component = child._currentElement.type;` （因为这里的 this 就是 child）\n所以这里返回的又是和 child 本身类型相同的 Instance（也许这里类型不一致），非常古怪。\n\n然后在回到之前的代码，我们发现，performInitialMount method 又被调用了，并且传入 this 就是 child 和 renderedElement 就是 null 或者是上面提到的用 child 的 _currentElement.type 构造出来的 Instance。\n\n这个时候，我们发现原来：\n```javascript\n\nperformInitialMount: function(\n    renderedElement,\n    hostParent,\n    hostContainerInfo,\n    transaction,\n    context,\n  ) {\n    // If not a stateless component, we now render\n    if (renderedElement === undefined) {\n      renderedElement = this._renderValidatedComponent();\n    }\n    var nodeType = ReactNodeTypes.getType(renderedElement);\n    this._renderedNodeType = nodeType;\n    var child = this._instantiateReactComponent(\n      renderedElement,\n      nodeType !== ReactNodeTypes.EMPTY /* shouldHaveDebugID */,\n    );\n    this._renderedComponent = child;\n\n//...\n\n/**\n   * @private\n   */\n  _renderValidatedComponent: function() {\n    var renderedElement;\n    if (\n      __DEV__ ||\n      this._compositeType !== ReactCompositeComponentTypes.StatelessFunctional\n    ) {\n      ReactCurrentOwner.current = this;\n      try {\n        renderedElement = this._renderValidatedComponentWithoutOwnerOrContext();\n      } finally {\n        ReactCurrentOwner.current = null;\n      }\n    } else {\n      renderedElement = this._renderValidatedComponentWithoutOwnerOrContext();\n    }\n    invariant(\n      // TODO: An `isValidNode` function would probably be more appropriate\n      renderedElement === null ||\n        renderedElement === false ||\n        React.isValidElement(renderedElement),\n      '%s.render(): A valid React element (or null) must be returned. You may have ' +\n        'returned undefined, an array or some other invalid object.',\n      this.getName() || 'ReactCompositeComponent',\n    );\n\n    return renderedElement;\n  }\n\n//...\n\n _renderValidatedComponentWithoutOwnerOrContext: function() {\n    var inst = this._instance;\n    var renderedElement;\n\n    if (__DEV__) {\n      renderedElement = measureLifeCyclePerf(\n        () => inst.render(),\n        this._debugID,\n        'render',\n      );\n    } else {\n      renderedElement = inst.render();\n    }\n\n    if (__DEV__) {\n      // We allow auto-mocks to proceed as if they're returning null.\n      if (renderedElement === undefined && inst.render._isMockFunction) {\n        // This is probably bad practice. Consider warning here and\n        // deprecating this convenience.\n        renderedElement = null;\n      }\n    }\n\n    return renderedElement;\n  }\n```\n观察这三个方法，发现这个 链表 结构原来是如此搭建起来的，所以 precacheNode 做的遍历实际上就是找到最终的子节点，用一个 随机生成的 key 来存储。\n\n**false**：\n就不会进行上面的这一段处理，也就是说不会重用以前的 markup，而是直接生成将 markup 插入到响应的 dom node 里面去。\n","slug":"React-源码阅读-Component-Mount","published":1,"updated":"2017-07-30T07:45:38.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjbdyo31o000qnf8je5yo93sq","content":"<h2 id=\"Mount-一个-Component\"><a href=\"#Mount-一个-Component\" class=\"headerlink\" title=\"Mount 一个 Component\"></a>Mount 一个 Component</h2><h3 id=\"callstack\"><a href=\"#callstack\" class=\"headerlink\" title=\"callstack\"></a>callstack</h3><p>ReactDomStackEntry =&gt; ReactMount =&gt; InstantiateReactComponent =&gt; CompositeComponent</p>\n<h3 id=\"ReactMount\"><a href=\"#ReactMount\" class=\"headerlink\" title=\"ReactMount\"></a>ReactMount</h3><p>Interfaces:</p>\n<ol>\n<li>scrollMonitor</li>\n<li>renderSubtreeIntoContainer</li>\n<li>render</li>\n<li>unmountComponentAtNode</li>\n</ol>\n<h3 id=\"renderNewRootComponent\"><a href=\"#renderNewRootComponent\" class=\"headerlink\" title=\"_renderNewRootComponent\"></a>_renderNewRootComponent</h3><ol>\n<li>检查</li>\n<li>call instantiateReactComponent 得到 componentInstance</li>\n<li>call ReactUpdates.batchedUpdates</li>\n</ol>\n<p>然后 ReactUpdates.batchedUpdates 会 call batchingStrategy.batchedUpdates，而这个实际上是在 call 一个在 ReactUpdates.injection 中注入 batchingStrategy，而实际上注入的是 ReactDefaultBatchingStragety，里面实际就是一个 transaction，并且除了一些特殊的初始化工作，就是调用了传给 ReactUpdates.bacthedUpdates 的 callback<br>而这个 callback 是：batchedMountComponentIntoNode</p>\n<h3 id=\"batchedMountComponentIntoNode\"><a href=\"#batchedMountComponentIntoNode\" class=\"headerlink\" title=\"batchedMountComponentIntoNode\"></a>batchedMountComponentIntoNode</h3><ol>\n<li>实例化一个 ReactUpdates.ReactReconcileTransaction</li>\n<li>然后 perform mountComponentIntoNode, 会传入 transcaction 和 instance</li>\n</ol>\n<p>这里需要了解一下 ReactUpdates.ReactReconcileTransaction, 这个变量和 ReactUpdates.batchUpdates 一样都是动态注入（其实我不明白为什么要这样做），默认的注入是在 ReactDomStackInjection 里面做的，里面做了大量的 transaction 必要的注入，此外还使用 pooledClass wrappert 一下来提升性能。</p>\n<p>和 batchingStrategy 一样，主要其实还是调用 callback。</p>\n<p>不过这个 transaction 的调用是这样的：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">transaction.perform(</div><div class=\"line\">    mountComponentIntoNode,</div><div class=\"line\">    <span class=\"literal\">null</span>,</div><div class=\"line\">    componentInstance,</div><div class=\"line\">    container,</div><div class=\"line\">    transaction,</div><div class=\"line\">    shouldReuseMarkup,</div><div class=\"line\">    context,</div><div class=\"line\">  );</div></pre></td></tr></table></figure>\n<p>也就是说把自己作为参数传给了 mountComponentIntoNode</p>\n<h3 id=\"mountComponentIntoNode\"><a href=\"#mountComponentIntoNode\" class=\"headerlink\" title=\"mountComponentIntoNode\"></a>mountComponentIntoNode</h3><ol>\n<li>call ReactReconciler.mountComponent 产生 markup</li>\n<li>设置 <code>wrapperInstance._renderedComponent._topLevelWrapper = wrapperInstance</code></li>\n<li>call _mountImageIntoNode 传入产生的 markup</li>\n</ol>\n<p>这里需要知道 ReactReconciler.mountComponent 是做什么的。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div></pre></td><td class=\"code\"><pre><div class=\"line\">mountComponent: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span></span></div><div class=\"line\">    internalInstance,</div><div class=\"line\">    transaction,</div><div class=\"line\">    hostParent,</div><div class=\"line\">    hostContainerInfo,</div><div class=\"line\">    context,</div><div class=\"line\">    parentDebugID, <span class=\"regexp\">//</span> <span class=\"number\">0</span> in production and for roots</div><div class=\"line\">  ) &#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (__DEV__) &#123;</div><div class=\"line\">      <span class=\"keyword\">if</span> (internalInstance._debugID !== <span class=\"number\">0</span>) &#123;</div><div class=\"line\">        ReactInstrumentation.debugTool.onBeforeMountComponent(</div><div class=\"line\">          internalInstance._debugID,</div><div class=\"line\">          internalInstance._currentElement,</div><div class=\"line\">          parentDebugID,</div><div class=\"line\">        );</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">var</span> markup = internalInstance.mountComponent(</div><div class=\"line\">      transaction,</div><div class=\"line\">      hostParent,</div><div class=\"line\">      hostContainerInfo,</div><div class=\"line\">      context,</div><div class=\"line\">      parentDebugID,</div><div class=\"line\">    );</div><div class=\"line\">    <span class=\"keyword\">if</span> (</div><div class=\"line\">      internalInstance._currentElement &amp;&amp;</div><div class=\"line\">      internalInstance._currentElement.ref != <span class=\"literal\">null</span></div><div class=\"line\">    ) &#123;</div><div class=\"line\">      transaction.getReactMountReady().enqueue(attachRefs, internalInstance);</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">if</span> (__DEV__) &#123;</div><div class=\"line\">      <span class=\"keyword\">if</span> (internalInstance._debugID !== <span class=\"number\">0</span>) &#123;</div><div class=\"line\">        ReactInstrumentation.debugTool.onMountComponent(</div><div class=\"line\">          internalInstance._debugID,</div><div class=\"line\">        );</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> markup;</div><div class=\"line\">  &#125;</div></pre></td></tr></table></figure></p>\n<p>这里可以看到是把 mount 的工作 delegate 给了 internalInstance.mountComponent, 所以我们还得去看 ReactComponent.mountCompoent 方法, 然而 react 内部其实没有 ReactComponent 这个类，看着它的 type 定义发现 ReactBaseClasses 是 React.Component, 但是又发现这个类，并没有什么 mountCompnent 定义，并且很多函数的定义都是 dummy 的（这里有点不明白），于是我想这应该是一个基类定义吧，然后我又找到了 ReactDOMComponent，这个似乎才是真正会使用到的 ReactComponent。</p>\n<p>在 mountComponent 中做了很多具体的工作，总结来说就是产生具体的 html element:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">if</span> (!tagContent &amp;&amp; omittedCloseTags[<span class=\"keyword\">this</span>._tag]) &#123;</div><div class=\"line\">        mountImage = tagOpen + <span class=\"string\">'/&gt;'</span>;</div><div class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">        mountImage = tagOpen + <span class=\"string\">'&gt;'</span> + tagContent + <span class=\"string\">'&lt;/'</span> + type + <span class=\"string\">'&gt;'</span>;</div><div class=\"line\">      &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>值得一提的是，这个 mountImage 的含义是 html 内容的意思，并且还是 string 类型的，然后:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/**</span></div><div class=\"line\">   * Generates root tag markup then recurses. This method has side effects and</div><div class=\"line\">   * is not idempotent.</div><div class=\"line\">   *</div><div class=\"line\">   * @internal</div><div class=\"line\">   * @param &#123;ReactReconcileTransaction|ReactServerRenderingTransaction&#125; transaction</div><div class=\"line\">   * @param &#123;?ReactDOMComponent&#125; the parent component instance</div><div class=\"line\">   * @param &#123;?object&#125; info about the host container</div><div class=\"line\">   * @param &#123;object&#125; context</div><div class=\"line\">   * @return &#123;string&#125; The computed markup.</div><div class=\"line\">   */</div><div class=\"line\">  mountComponent: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span></span></div><div class=\"line\">    transaction,</div><div class=\"line\">    hostParent,</div><div class=\"line\">    hostContainerInfo,</div><div class=\"line\">    context,</div><div class=\"line\">  ) &#123;</div><div class=\"line\">      <span class=\"comment\">//...</span></div><div class=\"line\">  &#125;</div></pre></td></tr></table></figure>\n<p>注释里面表明 markup 也是类似的含义。</p>\n<h3 id=\"mountImageIntoNode\"><a href=\"#mountImageIntoNode\" class=\"headerlink\" title=\"_mountImageIntoNode\"></a>_mountImageIntoNode</h3><p>会根据 shouldReuseMarkup，<br><strong>true</strong>：<br>获取 rootElement，call ReactMarkupChecksum 传入 markup， rootElement，如果返回 true，意味着可以使用 <code>ReactDOMComponentTree.precacheNode(instance, rootElement)</code> 来做到快速 mount，然后直接返回，所用的工作就算完成了。</p>\n<p>这里需要知道 React.MarkupChecksum.canReuseMarkup 的实现：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/**</span></div><div class=\"line\">   * @param &#123;string&#125; markup to use</div><div class=\"line\">   * @param &#123;DOMElement&#125; element root React element</div><div class=\"line\">   * @returns &#123;boolean&#125; whether or not the markup is the same</div><div class=\"line\">   */</div><div class=\"line\">  canReuseMarkup: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">markup, element</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> existingChecksum = element.getAttribute(</div><div class=\"line\">      ReactMarkupChecksum.CHECKSUM_ATTR_NAME,</div><div class=\"line\">    );</div><div class=\"line\">    existingChecksum = existingChecksum &amp;&amp; <span class=\"built_in\">parseInt</span>(existingChecksum, <span class=\"number\">10</span>);</div><div class=\"line\">    <span class=\"keyword\">var</span> markupChecksum = adler32(markup);</div><div class=\"line\">    <span class=\"keyword\">return</span> markupChecksum === existingChecksum;</div><div class=\"line\">  &#125;</div></pre></td></tr></table></figure></p>\n<p>这里一目了然，对于react render 出来的 element 肯定会把一个 checksum 存到  ReactMarkupChecksum.CHECKSUM_ATTR_NAME 中去。</p>\n<p>这里还需要知道 ReactDOMComponentTree.precachedNode 的具体实现：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/**</span></div><div class=\"line\"> * Drill down (through composites and empty components) until we get a host or</div><div class=\"line\"> * host text component.</div><div class=\"line\"> *</div><div class=\"line\"> * This is pretty polymorphic but unavoidable with the current structure we have</div><div class=\"line\"> * for `_renderedChildren`.</div><div class=\"line\"> */</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getRenderedHostOrTextFromComponent</span>(<span class=\"params\">component</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">var</span> rendered;</div><div class=\"line\">  <span class=\"keyword\">while</span> ((rendered = component._renderedComponent)) &#123;</div><div class=\"line\">    component = rendered;</div><div class=\"line\">  &#125;</div><div class=\"line\">  <span class=\"keyword\">return</span> component;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//...</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">/**</span></div><div class=\"line\"> * Populate `_hostNode` on the rendered host/text component with the given</div><div class=\"line\"> * DOM node. The passed `inst` can be a composite.</div><div class=\"line\"> */</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">precacheNode</span>(<span class=\"params\">inst, node</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">var</span> hostInst = getRenderedHostOrTextFromComponent(inst);</div><div class=\"line\">  hostInst._hostNode = node;</div><div class=\"line\">  node[internalInstanceKey] = hostInst;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这里非常需要知道 inst._renderedComponent 是什么。<br>我找来找去发现，一个 instance 的 _renderedComponent 是在 ReactCompositeComponent 中赋值的：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div></pre></td><td class=\"code\"><pre><div class=\"line\">performInitialMount: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span></span></div><div class=\"line\">    renderedElement,</div><div class=\"line\">    hostParent,</div><div class=\"line\">    hostContainerInfo,</div><div class=\"line\">    transaction,</div><div class=\"line\">    context,</div><div class=\"line\">  ) &#123;</div><div class=\"line\">    <span class=\"comment\">// If not a stateless component, we now render</span></div><div class=\"line\">    <span class=\"keyword\">if</span> (renderedElement === <span class=\"literal\">undefined</span>) &#123;</div><div class=\"line\">      renderedElement = <span class=\"keyword\">this</span>._renderValidatedComponent();</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">var</span> nodeType = ReactNodeTypes.getType(renderedElement);</div><div class=\"line\">    <span class=\"keyword\">this</span>._renderedNodeType = nodeType;</div><div class=\"line\">    <span class=\"keyword\">var</span> child = <span class=\"keyword\">this</span>._instantiateReactComponent(</div><div class=\"line\">      renderedElement,</div><div class=\"line\">      nodeType !== ReactNodeTypes.EMPTY <span class=\"comment\">/* shouldHaveDebugID */</span>,</div><div class=\"line\">    );</div><div class=\"line\">    <span class=\"keyword\">this</span>._renderedComponent = child;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">var</span> debugID = <span class=\"number\">0</span>;</div><div class=\"line\">    <span class=\"keyword\">if</span> (__DEV__) &#123;</div><div class=\"line\">      debugID = <span class=\"keyword\">this</span>._debugID;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">var</span> markup = ReactReconciler.mountComponent(</div><div class=\"line\">      child,</div><div class=\"line\">      transaction,</div><div class=\"line\">      hostParent,</div><div class=\"line\">      hostContainerInfo,</div><div class=\"line\">      <span class=\"keyword\">this</span>._processChildContext(context),</div><div class=\"line\">      debugID,</div><div class=\"line\">    );</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">if</span> (__DEV__) &#123;</div><div class=\"line\">      <span class=\"keyword\">if</span> (debugID !== <span class=\"number\">0</span>) &#123;</div><div class=\"line\">        <span class=\"keyword\">var</span> childDebugIDs = child._debugID !== <span class=\"number\">0</span> ? [child._debugID] : [];</div><div class=\"line\">        ReactInstrumentation.debugTool.onSetChildren(debugID, childDebugIDs);</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">return</span> markup;</div><div class=\"line\">  &#125;</div></pre></td></tr></table></figure></p>\n<p>这段代码可以说是相当顶层的调用，所以不用太深入去看（因为我们正在一个 call stack 的追踪当中），记住我们的目的是要找到 _renderedComponent 的赋值语句，发现是：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">if</span> (renderedElement === <span class=\"literal\">undefined</span>) &#123;</div><div class=\"line\">      renderedElement = <span class=\"keyword\">this</span>._renderValidatedComponent();</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> nodeType = ReactNodeTypes.getType(renderedElement);</div><div class=\"line\"><span class=\"keyword\">this</span>._renderedNodeType = nodeType;</div><div class=\"line\"><span class=\"keyword\">var</span> child = <span class=\"keyword\">this</span>._instantiateReactComponent(</div><div class=\"line\">    renderedElement,</div><div class=\"line\">    nodeType !== ReactNodeTypes.EMPTY <span class=\"comment\">/* shouldHaveDebugID */</span>,</div><div class=\"line\">);</div><div class=\"line\"><span class=\"keyword\">this</span>._renderedComponent = child;</div></pre></td></tr></table></figure>\n<p>（其实 renderedElement 是由 this 的 _constructComponent 函数生成的一个 ReactComponent Instance，所以之后用 this._instantiateReactComponent 生成出来的是 child，这个下面会仔细提到）<br>它存储了一个 ReactComponent 的 instance，但是我们要知道，先前的代码是存在一个<strong>链表</strong>结构的，所以要注意之后 child 还被执行了什么操作————还被使用 ReactReconciler.mountComponent 执行了一遍，而这个 method 是被分析过的，并且它是通过调用 ReactComponent 的 Instance 的 mountComponent 的方法来进行真正的 mount 工作。</p>\n<p>循环调用：<br>performInitialMount =&gt; ReactReconciler.mountComponent =&gt; Component.mountComponent<br>       ||                                                         ||<br>        \\======================================================== /</p>\n<p>为了搞清楚这块调用逻辑，我试图追踪 this._renderedComponent 的改动轨迹：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 在 ReactCompositeComponent 中</span></div><div class=\"line\">performInitialMount: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span></span></div><div class=\"line\">    renderedElement,</div><div class=\"line\">    hostParent,</div><div class=\"line\">    hostContainerInfo,</div><div class=\"line\">    transaction,</div><div class=\"line\">    context,</div><div class=\"line\">  ) &#123;</div><div class=\"line\">    <span class=\"comment\">// If not a stateless component, we now render</span></div><div class=\"line\">    <span class=\"keyword\">if</span> (renderedElement === <span class=\"literal\">undefined</span>) &#123;</div><div class=\"line\">      renderedElement = <span class=\"keyword\">this</span>._renderValidatedComponent();</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">var</span> nodeType = ReactNodeTypes.getType(renderedElement);</div><div class=\"line\">    <span class=\"keyword\">this</span>._renderedNodeType = nodeType;</div><div class=\"line\">    <span class=\"keyword\">var</span> child = <span class=\"keyword\">this</span>._instantiateReactComponent(</div><div class=\"line\">      renderedElement,</div><div class=\"line\">      nodeType !== ReactNodeTypes.EMPTY <span class=\"comment\">/* shouldHaveDebugID */</span>,</div><div class=\"line\">    );</div><div class=\"line\">    <span class=\"keyword\">this</span>._renderedComponent = child;</div><div class=\"line\">    <span class=\"comment\">//...</span></div><div class=\"line\">    <span class=\"keyword\">var</span> markup = ReactReconciler.mountComponent(</div><div class=\"line\">      child, <span class=\"comment\">// 这里被调用了</span></div><div class=\"line\">      transaction,</div><div class=\"line\">      hostParent,</div><div class=\"line\">      hostContainerInfo,</div><div class=\"line\">      <span class=\"keyword\">this</span>._processChildContext(context),</div><div class=\"line\">      debugID,</div><div class=\"line\">    );</div></pre></td></tr></table></figure></p>\n<p>这段代码中的 child 生成也是需要注意的，也就是说 this._instantiateReactComponent 这个 function 做的是什么事情呢？<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/**</span></div><div class=\"line\"> * Given a ReactNode, create an instance that will actually be mounted.</div><div class=\"line\"> *</div><div class=\"line\"> * @param &#123;ReactNode&#125; node</div><div class=\"line\"> * @param &#123;boolean&#125; shouldHaveDebugID</div><div class=\"line\"> * @return &#123;object&#125; A new instance of the element's constructor.</div><div class=\"line\"> * @protected</div><div class=\"line\"> */</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">instantiateReactComponent</span>(<span class=\"params\">node, shouldHaveDebugID</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">var</span> instance;</div><div class=\"line\">  <span class=\"comment\">//...</span></div></pre></td></tr></table></figure></p>\n<p>不深入这段代码可以发现这是一段根据 ReactNode（关于 ReactNode 的定义需要仔细研究）来 instance 一个 ReactComponent 的 instance 的方法。</p>\n<p>那么我们在深入到 ReactReconciler 的代码中看一下这个 child（ReactComponent 的 instance）究竟被用来做什么了。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/**</span></div><div class=\"line\">   * Initializes the component, renders markup, and registers event listeners.</div><div class=\"line\">   *</div><div class=\"line\">   * @param &#123;ReactComponent&#125; internalInstance</div><div class=\"line\">   * @param &#123;ReactReconcileTransaction|ReactServerRenderingTransaction&#125; transaction</div><div class=\"line\">   * @param &#123;?object&#125; the containing host component instance</div><div class=\"line\">   * @param &#123;?object&#125; info about the host container</div><div class=\"line\">   * @return &#123;?string&#125; Rendered markup to be inserted into the DOM.</div><div class=\"line\">   * @final</div><div class=\"line\">   * @internal</div><div class=\"line\">   */</div><div class=\"line\">  mountComponent: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span></span></div><div class=\"line\">    internalInstance,</div><div class=\"line\">    transaction,</div><div class=\"line\">    hostParent,</div><div class=\"line\">    hostContainerInfo,</div><div class=\"line\">    context,</div><div class=\"line\">    parentDebugID, <span class=\"regexp\">//</span> <span class=\"number\">0</span> in production and for roots</div><div class=\"line\">  ) &#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (__DEV__) &#123;</div><div class=\"line\">      <span class=\"keyword\">if</span> (internalInstance._debugID !== <span class=\"number\">0</span>) &#123;</div><div class=\"line\">        ReactInstrumentation.debugTool.onBeforeMountComponent(</div><div class=\"line\">          internalInstance._debugID,</div><div class=\"line\">          internalInstance._currentElement,</div><div class=\"line\">          parentDebugID,</div><div class=\"line\">        );</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">var</span> markup = internalInstance.mountComponent(<span class=\"comment\">// 直接又调用了 ReactComponent 的mountComponent 的方法</span></div><div class=\"line\">      transaction,</div><div class=\"line\">      hostParent,</div><div class=\"line\">      hostContainerInfo,</div><div class=\"line\">      context,</div><div class=\"line\">      parentDebugID,</div><div class=\"line\">    );</div><div class=\"line\"><span class=\"comment\">//...</span></div></pre></td></tr></table></figure></p>\n<p>这里需要注意的是， 这个 internalInstance 是之前的 child，但是这个 child 不一定是 ReactCompositeComponent 类型的 Instance，也有可能是其他类型的 Component 的 Instance，不过我们可以先看，如果是 ReactCompositeComponent 类型的 Instance 的话，怎么处理？<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// ReactCompositeComponent.js</span></div><div class=\"line\"><span class=\"comment\">/**</span></div><div class=\"line\">   * Initializes the component, renders markup, and registers event listeners.</div><div class=\"line\">   *</div><div class=\"line\">   * @param &#123;ReactReconcileTransaction|ReactServerRenderingTransaction&#125; transaction</div><div class=\"line\">   * @param &#123;?object&#125; hostParent</div><div class=\"line\">   * @param &#123;?object&#125; hostContainerInfo</div><div class=\"line\">   * @param &#123;?object&#125; context</div><div class=\"line\">   * @return &#123;?string&#125; Rendered markup to be inserted into the DOM.</div><div class=\"line\">   * @final</div><div class=\"line\">   * @internal</div><div class=\"line\">   */</div><div class=\"line\">  mountComponent: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span></span></div><div class=\"line\">    transaction,</div><div class=\"line\">    hostParent,</div><div class=\"line\">    hostContainerInfo,</div><div class=\"line\">    context,</div><div class=\"line\">  ) &#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>._context = context;</div><div class=\"line\">    <span class=\"keyword\">this</span>._mountOrder = nextMountID++;</div><div class=\"line\">    <span class=\"keyword\">this</span>._hostParent = hostParent;</div><div class=\"line\">    <span class=\"keyword\">this</span>._hostContainerInfo = hostContainerInfo;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">var</span> publicProps = <span class=\"keyword\">this</span>._currentElement.props;</div><div class=\"line\">    <span class=\"keyword\">var</span> publicContext = <span class=\"keyword\">this</span>._processContext(context);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">var</span> Component = <span class=\"keyword\">this</span>._currentElement.type;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">var</span> updateQueue = transaction.getUpdateQueue();</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// Initialize the public class</span></div><div class=\"line\">    <span class=\"keyword\">var</span> doConstruct = shouldConstruct(Component);</div><div class=\"line\">    <span class=\"keyword\">var</span> inst = <span class=\"keyword\">this</span>._constructComponent(</div><div class=\"line\">      doConstruct,</div><div class=\"line\">      publicProps,</div><div class=\"line\">      publicContext,</div><div class=\"line\">      updateQueue,</div><div class=\"line\">    );</div><div class=\"line\">    <span class=\"keyword\">var</span> renderedElement; <span class=\"comment\">// 注意这个 renderedElement</span></div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// Support functional components</span></div><div class=\"line\">    <span class=\"keyword\">if</span> (!doConstruct &amp;&amp; (inst == <span class=\"literal\">null</span> || inst.render == <span class=\"literal\">null</span>)) &#123;</div><div class=\"line\">      renderedElement = inst; <span class=\"comment\">// 同时当 doConstruct 和 inst 为空的时候，持有一份 inst，应该其实就是空</span></div><div class=\"line\">      <span class=\"keyword\">if</span> (__DEV__) &#123;</div><div class=\"line\">        warning(</div><div class=\"line\">          !Component.childContextTypes,</div><div class=\"line\">          <span class=\"string\">'%s(...): childContextTypes cannot be defined on a functional component.'</span>,</div><div class=\"line\">          Component.displayName || Component.name || <span class=\"string\">'Component'</span>,</div><div class=\"line\">        );</div><div class=\"line\">      &#125;</div><div class=\"line\"><span class=\"comment\">//...</span></div><div class=\"line\">    <span class=\"keyword\">var</span> markup;</div><div class=\"line\">    <span class=\"keyword\">if</span> (inst.unstable_handleError) &#123;</div><div class=\"line\">      markup = <span class=\"keyword\">this</span>.performInitialMountWithErrorHandling(</div><div class=\"line\">        renderedElement,  </div><div class=\"line\">        hostParent,</div><div class=\"line\">        hostContainerInfo,</div><div class=\"line\">        transaction,</div><div class=\"line\">        context,</div><div class=\"line\">      );</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">      markup = <span class=\"keyword\">this</span>.performInitialMount(</div><div class=\"line\">        renderedElement,</div><div class=\"line\">        hostParent,</div><div class=\"line\">        hostContainerInfo,</div><div class=\"line\">        transaction,</div><div class=\"line\">        context,</div><div class=\"line\">      );</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure></p>\n<p>需要注意的是，这里的 this 其实就是之前的 child，所以这里会很奇怪，取了 child 的属性，然后又调用 _constructrComponent 方法来进行:<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div></pre></td><td class=\"code\"><pre><div class=\"line\">_constructComponent: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span></span></div><div class=\"line\">    doConstruct,</div><div class=\"line\">    publicProps,</div><div class=\"line\">    publicContext,</div><div class=\"line\">    updateQueue,</div><div class=\"line\">  ) &#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (__DEV__) &#123;</div><div class=\"line\">      ReactCurrentOwner.current = <span class=\"keyword\">this</span>;</div><div class=\"line\">      <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>._constructComponentWithoutOwner(</div><div class=\"line\">          doConstruct,</div><div class=\"line\">          publicProps,</div><div class=\"line\">          publicContext,</div><div class=\"line\">          updateQueue,</div><div class=\"line\">        );</div><div class=\"line\">      &#125; <span class=\"keyword\">finally</span> &#123;</div><div class=\"line\">        ReactCurrentOwner.current = <span class=\"literal\">null</span>;</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>._constructComponentWithoutOwner(</div><div class=\"line\">        doConstruct,</div><div class=\"line\">        publicProps,</div><div class=\"line\">        publicContext,</div><div class=\"line\">        updateQueue,</div><div class=\"line\">      );</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;,</div><div class=\"line\"></div><div class=\"line\"><span class=\"attr\">_constructComponentWithoutOwner</span>: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span></span></div><div class=\"line\">    doConstruct,</div><div class=\"line\">    publicProps,</div><div class=\"line\">    publicContext,</div><div class=\"line\">    updateQueue,</div><div class=\"line\">  ) &#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> Component = <span class=\"keyword\">this</span>._currentElement.type; <span class=\"comment\">// 注意这里</span></div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">if</span> (doConstruct) &#123;</div><div class=\"line\">      <span class=\"keyword\">if</span> (__DEV__) &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> measureLifeCyclePerf(</div><div class=\"line\">          <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> <span class=\"keyword\">new</span> Component(publicProps, publicContext, updateQueue),</div><div class=\"line\">          <span class=\"keyword\">this</span>._debugID,</div><div class=\"line\">          <span class=\"string\">'ctor'</span>,</div><div class=\"line\">        );</div><div class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Component(publicProps, publicContext, updateQueue);</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\"><span class=\"comment\">//...</span></div></pre></td></tr></table></figure></p>\n<p>最终 又新建了一个 Component 的 instance，我们来从一开始追溯到这里，看看 <code>var Component = this._currentElement.type</code> 这句里面的 Component 究竟和 child 是什么关系:<br><code>var Component = child._currentElement.type;</code> （因为这里的 this 就是 child）<br>所以这里返回的又是和 child 本身类型相同的 Instance（也许这里类型不一致），非常古怪。</p>\n<p>然后在回到之前的代码，我们发现，performInitialMount method 又被调用了，并且传入 this 就是 child 和 renderedElement 就是 null 或者是上面提到的用 child 的 _currentElement.type 构造出来的 Instance。</p>\n<p>这个时候，我们发现原来：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">performInitialMount: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span></span></div><div class=\"line\">    renderedElement,</div><div class=\"line\">    hostParent,</div><div class=\"line\">    hostContainerInfo,</div><div class=\"line\">    transaction,</div><div class=\"line\">    context,</div><div class=\"line\">  ) &#123;</div><div class=\"line\">    <span class=\"comment\">// If not a stateless component, we now render</span></div><div class=\"line\">    <span class=\"keyword\">if</span> (renderedElement === <span class=\"literal\">undefined</span>) &#123;</div><div class=\"line\">      renderedElement = <span class=\"keyword\">this</span>._renderValidatedComponent();</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">var</span> nodeType = ReactNodeTypes.getType(renderedElement);</div><div class=\"line\">    <span class=\"keyword\">this</span>._renderedNodeType = nodeType;</div><div class=\"line\">    <span class=\"keyword\">var</span> child = <span class=\"keyword\">this</span>._instantiateReactComponent(</div><div class=\"line\">      renderedElement,</div><div class=\"line\">      nodeType !== ReactNodeTypes.EMPTY <span class=\"comment\">/* shouldHaveDebugID */</span>,</div><div class=\"line\">    );</div><div class=\"line\">    <span class=\"keyword\">this</span>._renderedComponent = child;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//...</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">/**</span></div><div class=\"line\">   * @private</div><div class=\"line\">   */</div><div class=\"line\">  _renderValidatedComponent: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> renderedElement;</div><div class=\"line\">    <span class=\"keyword\">if</span> (</div><div class=\"line\">      __DEV__ ||</div><div class=\"line\">      <span class=\"keyword\">this</span>._compositeType !== ReactCompositeComponentTypes.StatelessFunctional</div><div class=\"line\">    ) &#123;</div><div class=\"line\">      ReactCurrentOwner.current = <span class=\"keyword\">this</span>;</div><div class=\"line\">      <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">        renderedElement = <span class=\"keyword\">this</span>._renderValidatedComponentWithoutOwnerOrContext();</div><div class=\"line\">      &#125; <span class=\"keyword\">finally</span> &#123;</div><div class=\"line\">        ReactCurrentOwner.current = <span class=\"literal\">null</span>;</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">      renderedElement = <span class=\"keyword\">this</span>._renderValidatedComponentWithoutOwnerOrContext();</div><div class=\"line\">    &#125;</div><div class=\"line\">    invariant(</div><div class=\"line\">      <span class=\"comment\">// <span class=\"doctag\">TODO:</span> An `isValidNode` function would probably be more appropriate</span></div><div class=\"line\">      renderedElement === <span class=\"literal\">null</span> ||</div><div class=\"line\">        renderedElement === <span class=\"literal\">false</span> ||</div><div class=\"line\">        React.isValidElement(renderedElement),</div><div class=\"line\">      <span class=\"string\">'%s.render(): A valid React element (or null) must be returned. You may have '</span> +</div><div class=\"line\">        <span class=\"string\">'returned undefined, an array or some other invalid object.'</span>,</div><div class=\"line\">      <span class=\"keyword\">this</span>.getName() || <span class=\"string\">'ReactCompositeComponent'</span>,</div><div class=\"line\">    );</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">return</span> renderedElement;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//...</span></div><div class=\"line\"></div><div class=\"line\"> _renderValidatedComponentWithoutOwnerOrContext: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> inst = <span class=\"keyword\">this</span>._instance;</div><div class=\"line\">    <span class=\"keyword\">var</span> renderedElement;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">if</span> (__DEV__) &#123;</div><div class=\"line\">      renderedElement = measureLifeCyclePerf(</div><div class=\"line\">        <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> inst.render(),</div><div class=\"line\">        <span class=\"keyword\">this</span>._debugID,</div><div class=\"line\">        <span class=\"string\">'render'</span>,</div><div class=\"line\">      );</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">      renderedElement = inst.render();</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">if</span> (__DEV__) &#123;</div><div class=\"line\">      <span class=\"comment\">// We allow auto-mocks to proceed as if they're returning null.</span></div><div class=\"line\">      <span class=\"keyword\">if</span> (renderedElement === <span class=\"literal\">undefined</span> &amp;&amp; inst.render._isMockFunction) &#123;</div><div class=\"line\">        <span class=\"comment\">// This is probably bad practice. Consider warning here and</span></div><div class=\"line\">        <span class=\"comment\">// deprecating this convenience.</span></div><div class=\"line\">        renderedElement = <span class=\"literal\">null</span>;</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">return</span> renderedElement;</div><div class=\"line\">  &#125;</div></pre></td></tr></table></figure></p>\n<p>观察这三个方法，发现这个 链表 结构原来是如此搭建起来的，所以 precacheNode 做的遍历实际上就是找到最终的子节点，用一个 随机生成的 key 来存储。</p>\n<p><strong>false</strong>：<br>就不会进行上面的这一段处理，也就是说不会重用以前的 markup，而是直接生成将 markup 插入到响应的 dom node 里面去。</p>\n","excerpt":"","more":"<h2 id=\"Mount-一个-Component\"><a href=\"#Mount-一个-Component\" class=\"headerlink\" title=\"Mount 一个 Component\"></a>Mount 一个 Component</h2><h3 id=\"callstack\"><a href=\"#callstack\" class=\"headerlink\" title=\"callstack\"></a>callstack</h3><p>ReactDomStackEntry =&gt; ReactMount =&gt; InstantiateReactComponent =&gt; CompositeComponent</p>\n<h3 id=\"ReactMount\"><a href=\"#ReactMount\" class=\"headerlink\" title=\"ReactMount\"></a>ReactMount</h3><p>Interfaces:</p>\n<ol>\n<li>scrollMonitor</li>\n<li>renderSubtreeIntoContainer</li>\n<li>render</li>\n<li>unmountComponentAtNode</li>\n</ol>\n<h3 id=\"renderNewRootComponent\"><a href=\"#renderNewRootComponent\" class=\"headerlink\" title=\"_renderNewRootComponent\"></a>_renderNewRootComponent</h3><ol>\n<li>检查</li>\n<li>call instantiateReactComponent 得到 componentInstance</li>\n<li>call ReactUpdates.batchedUpdates</li>\n</ol>\n<p>然后 ReactUpdates.batchedUpdates 会 call batchingStrategy.batchedUpdates，而这个实际上是在 call 一个在 ReactUpdates.injection 中注入 batchingStrategy，而实际上注入的是 ReactDefaultBatchingStragety，里面实际就是一个 transaction，并且除了一些特殊的初始化工作，就是调用了传给 ReactUpdates.bacthedUpdates 的 callback<br>而这个 callback 是：batchedMountComponentIntoNode</p>\n<h3 id=\"batchedMountComponentIntoNode\"><a href=\"#batchedMountComponentIntoNode\" class=\"headerlink\" title=\"batchedMountComponentIntoNode\"></a>batchedMountComponentIntoNode</h3><ol>\n<li>实例化一个 ReactUpdates.ReactReconcileTransaction</li>\n<li>然后 perform mountComponentIntoNode, 会传入 transcaction 和 instance</li>\n</ol>\n<p>这里需要了解一下 ReactUpdates.ReactReconcileTransaction, 这个变量和 ReactUpdates.batchUpdates 一样都是动态注入（其实我不明白为什么要这样做），默认的注入是在 ReactDomStackInjection 里面做的，里面做了大量的 transaction 必要的注入，此外还使用 pooledClass wrappert 一下来提升性能。</p>\n<p>和 batchingStrategy 一样，主要其实还是调用 callback。</p>\n<p>不过这个 transaction 的调用是这样的：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">transaction.perform(</div><div class=\"line\">    mountComponentIntoNode,</div><div class=\"line\">    <span class=\"literal\">null</span>,</div><div class=\"line\">    componentInstance,</div><div class=\"line\">    container,</div><div class=\"line\">    transaction,</div><div class=\"line\">    shouldReuseMarkup,</div><div class=\"line\">    context,</div><div class=\"line\">  );</div></pre></td></tr></table></figure>\n<p>也就是说把自己作为参数传给了 mountComponentIntoNode</p>\n<h3 id=\"mountComponentIntoNode\"><a href=\"#mountComponentIntoNode\" class=\"headerlink\" title=\"mountComponentIntoNode\"></a>mountComponentIntoNode</h3><ol>\n<li>call ReactReconciler.mountComponent 产生 markup</li>\n<li>设置 <code>wrapperInstance._renderedComponent._topLevelWrapper = wrapperInstance</code></li>\n<li>call _mountImageIntoNode 传入产生的 markup</li>\n</ol>\n<p>这里需要知道 ReactReconciler.mountComponent 是做什么的。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div></pre></td><td class=\"code\"><pre><div class=\"line\">mountComponent: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></div><div class=\"line\">    internalInstance,</div><div class=\"line\">    transaction,</div><div class=\"line\">    hostParent,</div><div class=\"line\">    hostContainerInfo,</div><div class=\"line\">    context,</div><div class=\"line\">    parentDebugID, <span class=\"regexp\">//</span> <span class=\"number\">0</span> in production and for roots</div><div class=\"line\">  </span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (__DEV__) &#123;</div><div class=\"line\">      <span class=\"keyword\">if</span> (internalInstance._debugID !== <span class=\"number\">0</span>) &#123;</div><div class=\"line\">        ReactInstrumentation.debugTool.onBeforeMountComponent(</div><div class=\"line\">          internalInstance._debugID,</div><div class=\"line\">          internalInstance._currentElement,</div><div class=\"line\">          parentDebugID,</div><div class=\"line\">        );</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">var</span> markup = internalInstance.mountComponent(</div><div class=\"line\">      transaction,</div><div class=\"line\">      hostParent,</div><div class=\"line\">      hostContainerInfo,</div><div class=\"line\">      context,</div><div class=\"line\">      parentDebugID,</div><div class=\"line\">    );</div><div class=\"line\">    <span class=\"keyword\">if</span> (</div><div class=\"line\">      internalInstance._currentElement &amp;&amp;</div><div class=\"line\">      internalInstance._currentElement.ref != <span class=\"literal\">null</span></div><div class=\"line\">    ) &#123;</div><div class=\"line\">      transaction.getReactMountReady().enqueue(attachRefs, internalInstance);</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">if</span> (__DEV__) &#123;</div><div class=\"line\">      <span class=\"keyword\">if</span> (internalInstance._debugID !== <span class=\"number\">0</span>) &#123;</div><div class=\"line\">        ReactInstrumentation.debugTool.onMountComponent(</div><div class=\"line\">          internalInstance._debugID,</div><div class=\"line\">        );</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> markup;</div><div class=\"line\">  &#125;</div></pre></td></tr></table></figure></p>\n<p>这里可以看到是把 mount 的工作 delegate 给了 internalInstance.mountComponent, 所以我们还得去看 ReactComponent.mountCompoent 方法, 然而 react 内部其实没有 ReactComponent 这个类，看着它的 type 定义发现 ReactBaseClasses 是 React.Component, 但是又发现这个类，并没有什么 mountCompnent 定义，并且很多函数的定义都是 dummy 的（这里有点不明白），于是我想这应该是一个基类定义吧，然后我又找到了 ReactDOMComponent，这个似乎才是真正会使用到的 ReactComponent。</p>\n<p>在 mountComponent 中做了很多具体的工作，总结来说就是产生具体的 html element:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">if</span> (!tagContent &amp;&amp; omittedCloseTags[<span class=\"keyword\">this</span>._tag]) &#123;</div><div class=\"line\">        mountImage = tagOpen + <span class=\"string\">'/&gt;'</span>;</div><div class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">        mountImage = tagOpen + <span class=\"string\">'&gt;'</span> + tagContent + <span class=\"string\">'&lt;/'</span> + type + <span class=\"string\">'&gt;'</span>;</div><div class=\"line\">      &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>值得一提的是，这个 mountImage 的含义是 html 内容的意思，并且还是 string 类型的，然后:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/**</div><div class=\"line\">   * Generates root tag markup then recurses. This method has side effects and</div><div class=\"line\">   * is not idempotent.</div><div class=\"line\">   *</div><div class=\"line\">   * @internal</div><div class=\"line\">   * @param &#123;ReactReconcileTransaction|ReactServerRenderingTransaction&#125; transaction</div><div class=\"line\">   * @param &#123;?ReactDOMComponent&#125; the parent component instance</div><div class=\"line\">   * @param &#123;?object&#125; info about the host container</div><div class=\"line\">   * @param &#123;object&#125; context</div><div class=\"line\">   * @return &#123;string&#125; The computed markup.</div><div class=\"line\">   */</span></div><div class=\"line\">  mountComponent: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></div><div class=\"line\">    transaction,</div><div class=\"line\">    hostParent,</div><div class=\"line\">    hostContainerInfo,</div><div class=\"line\">    context,</div><div class=\"line\">  </span>) </span>&#123;</div><div class=\"line\">      <span class=\"comment\">//...</span></div><div class=\"line\">  &#125;</div></pre></td></tr></table></figure>\n<p>注释里面表明 markup 也是类似的含义。</p>\n<h3 id=\"mountImageIntoNode\"><a href=\"#mountImageIntoNode\" class=\"headerlink\" title=\"_mountImageIntoNode\"></a>_mountImageIntoNode</h3><p>会根据 shouldReuseMarkup，<br><strong>true</strong>：<br>获取 rootElement，call ReactMarkupChecksum 传入 markup， rootElement，如果返回 true，意味着可以使用 <code>ReactDOMComponentTree.precacheNode(instance, rootElement)</code> 来做到快速 mount，然后直接返回，所用的工作就算完成了。</p>\n<p>这里需要知道 React.MarkupChecksum.canReuseMarkup 的实现：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/**</div><div class=\"line\">   * @param &#123;string&#125; markup to use</div><div class=\"line\">   * @param &#123;DOMElement&#125; element root React element</div><div class=\"line\">   * @returns &#123;boolean&#125; whether or not the markup is the same</div><div class=\"line\">   */</span></div><div class=\"line\">  canReuseMarkup: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">markup, element</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> existingChecksum = element.getAttribute(</div><div class=\"line\">      ReactMarkupChecksum.CHECKSUM_ATTR_NAME,</div><div class=\"line\">    );</div><div class=\"line\">    existingChecksum = existingChecksum &amp;&amp; <span class=\"built_in\">parseInt</span>(existingChecksum, <span class=\"number\">10</span>);</div><div class=\"line\">    <span class=\"keyword\">var</span> markupChecksum = adler32(markup);</div><div class=\"line\">    <span class=\"keyword\">return</span> markupChecksum === existingChecksum;</div><div class=\"line\">  &#125;</div></pre></td></tr></table></figure></p>\n<p>这里一目了然，对于react render 出来的 element 肯定会把一个 checksum 存到  ReactMarkupChecksum.CHECKSUM_ATTR_NAME 中去。</p>\n<p>这里还需要知道 ReactDOMComponentTree.precachedNode 的具体实现：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/**</div><div class=\"line\"> * Drill down (through composites and empty components) until we get a host or</div><div class=\"line\"> * host text component.</div><div class=\"line\"> *</div><div class=\"line\"> * This is pretty polymorphic but unavoidable with the current structure we have</div><div class=\"line\"> * for `_renderedChildren`.</div><div class=\"line\"> */</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getRenderedHostOrTextFromComponent</span>(<span class=\"params\">component</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">var</span> rendered;</div><div class=\"line\">  <span class=\"keyword\">while</span> ((rendered = component._renderedComponent)) &#123;</div><div class=\"line\">    component = rendered;</div><div class=\"line\">  &#125;</div><div class=\"line\">  <span class=\"keyword\">return</span> component;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//...</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">/**</div><div class=\"line\"> * Populate `_hostNode` on the rendered host/text component with the given</div><div class=\"line\"> * DOM node. The passed `inst` can be a composite.</div><div class=\"line\"> */</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">precacheNode</span>(<span class=\"params\">inst, node</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">var</span> hostInst = getRenderedHostOrTextFromComponent(inst);</div><div class=\"line\">  hostInst._hostNode = node;</div><div class=\"line\">  node[internalInstanceKey] = hostInst;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这里非常需要知道 inst._renderedComponent 是什么。<br>我找来找去发现，一个 instance 的 _renderedComponent 是在 ReactCompositeComponent 中赋值的：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div></pre></td><td class=\"code\"><pre><div class=\"line\">performInitialMount: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></div><div class=\"line\">    renderedElement,</div><div class=\"line\">    hostParent,</div><div class=\"line\">    hostContainerInfo,</div><div class=\"line\">    transaction,</div><div class=\"line\">    context,</div><div class=\"line\">  </span>) </span>&#123;</div><div class=\"line\">    <span class=\"comment\">// If not a stateless component, we now render</span></div><div class=\"line\">    <span class=\"keyword\">if</span> (renderedElement === <span class=\"literal\">undefined</span>) &#123;</div><div class=\"line\">      renderedElement = <span class=\"keyword\">this</span>._renderValidatedComponent();</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">var</span> nodeType = ReactNodeTypes.getType(renderedElement);</div><div class=\"line\">    <span class=\"keyword\">this</span>._renderedNodeType = nodeType;</div><div class=\"line\">    <span class=\"keyword\">var</span> child = <span class=\"keyword\">this</span>._instantiateReactComponent(</div><div class=\"line\">      renderedElement,</div><div class=\"line\">      nodeType !== ReactNodeTypes.EMPTY <span class=\"comment\">/* shouldHaveDebugID */</span>,</div><div class=\"line\">    );</div><div class=\"line\">    <span class=\"keyword\">this</span>._renderedComponent = child;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">var</span> debugID = <span class=\"number\">0</span>;</div><div class=\"line\">    <span class=\"keyword\">if</span> (__DEV__) &#123;</div><div class=\"line\">      debugID = <span class=\"keyword\">this</span>._debugID;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">var</span> markup = ReactReconciler.mountComponent(</div><div class=\"line\">      child,</div><div class=\"line\">      transaction,</div><div class=\"line\">      hostParent,</div><div class=\"line\">      hostContainerInfo,</div><div class=\"line\">      <span class=\"keyword\">this</span>._processChildContext(context),</div><div class=\"line\">      debugID,</div><div class=\"line\">    );</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">if</span> (__DEV__) &#123;</div><div class=\"line\">      <span class=\"keyword\">if</span> (debugID !== <span class=\"number\">0</span>) &#123;</div><div class=\"line\">        <span class=\"keyword\">var</span> childDebugIDs = child._debugID !== <span class=\"number\">0</span> ? [child._debugID] : [];</div><div class=\"line\">        ReactInstrumentation.debugTool.onSetChildren(debugID, childDebugIDs);</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">return</span> markup;</div><div class=\"line\">  &#125;</div></pre></td></tr></table></figure></p>\n<p>这段代码可以说是相当顶层的调用，所以不用太深入去看（因为我们正在一个 call stack 的追踪当中），记住我们的目的是要找到 _renderedComponent 的赋值语句，发现是：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">if</span> (renderedElement === <span class=\"literal\">undefined</span>) &#123;</div><div class=\"line\">      renderedElement = <span class=\"keyword\">this</span>._renderValidatedComponent();</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> nodeType = ReactNodeTypes.getType(renderedElement);</div><div class=\"line\"><span class=\"keyword\">this</span>._renderedNodeType = nodeType;</div><div class=\"line\"><span class=\"keyword\">var</span> child = <span class=\"keyword\">this</span>._instantiateReactComponent(</div><div class=\"line\">    renderedElement,</div><div class=\"line\">    nodeType !== ReactNodeTypes.EMPTY <span class=\"comment\">/* shouldHaveDebugID */</span>,</div><div class=\"line\">);</div><div class=\"line\"><span class=\"keyword\">this</span>._renderedComponent = child;</div></pre></td></tr></table></figure>\n<p>（其实 renderedElement 是由 this 的 _constructComponent 函数生成的一个 ReactComponent Instance，所以之后用 this._instantiateReactComponent 生成出来的是 child，这个下面会仔细提到）<br>它存储了一个 ReactComponent 的 instance，但是我们要知道，先前的代码是存在一个<strong>链表</strong>结构的，所以要注意之后 child 还被执行了什么操作————还被使用 ReactReconciler.mountComponent 执行了一遍，而这个 method 是被分析过的，并且它是通过调用 ReactComponent 的 Instance 的 mountComponent 的方法来进行真正的 mount 工作。</p>\n<p>循环调用：<br>performInitialMount =&gt; ReactReconciler.mountComponent =&gt; Component.mountComponent<br>       ||                                                         ||<br>        \\======================================================== /</p>\n<p>为了搞清楚这块调用逻辑，我试图追踪 this._renderedComponent 的改动轨迹：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 在 ReactCompositeComponent 中</span></div><div class=\"line\">performInitialMount: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></div><div class=\"line\">    renderedElement,</div><div class=\"line\">    hostParent,</div><div class=\"line\">    hostContainerInfo,</div><div class=\"line\">    transaction,</div><div class=\"line\">    context,</div><div class=\"line\">  </span>) </span>&#123;</div><div class=\"line\">    <span class=\"comment\">// If not a stateless component, we now render</span></div><div class=\"line\">    <span class=\"keyword\">if</span> (renderedElement === <span class=\"literal\">undefined</span>) &#123;</div><div class=\"line\">      renderedElement = <span class=\"keyword\">this</span>._renderValidatedComponent();</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">var</span> nodeType = ReactNodeTypes.getType(renderedElement);</div><div class=\"line\">    <span class=\"keyword\">this</span>._renderedNodeType = nodeType;</div><div class=\"line\">    <span class=\"keyword\">var</span> child = <span class=\"keyword\">this</span>._instantiateReactComponent(</div><div class=\"line\">      renderedElement,</div><div class=\"line\">      nodeType !== ReactNodeTypes.EMPTY <span class=\"comment\">/* shouldHaveDebugID */</span>,</div><div class=\"line\">    );</div><div class=\"line\">    <span class=\"keyword\">this</span>._renderedComponent = child;</div><div class=\"line\">    <span class=\"comment\">//...</span></div><div class=\"line\">    <span class=\"keyword\">var</span> markup = ReactReconciler.mountComponent(</div><div class=\"line\">      child, <span class=\"comment\">// 这里被调用了</span></div><div class=\"line\">      transaction,</div><div class=\"line\">      hostParent,</div><div class=\"line\">      hostContainerInfo,</div><div class=\"line\">      <span class=\"keyword\">this</span>._processChildContext(context),</div><div class=\"line\">      debugID,</div><div class=\"line\">    );</div></pre></td></tr></table></figure></p>\n<p>这段代码中的 child 生成也是需要注意的，也就是说 this._instantiateReactComponent 这个 function 做的是什么事情呢？<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/**</div><div class=\"line\"> * Given a ReactNode, create an instance that will actually be mounted.</div><div class=\"line\"> *</div><div class=\"line\"> * @param &#123;ReactNode&#125; node</div><div class=\"line\"> * @param &#123;boolean&#125; shouldHaveDebugID</div><div class=\"line\"> * @return &#123;object&#125; A new instance of the element's constructor.</div><div class=\"line\"> * @protected</div><div class=\"line\"> */</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">instantiateReactComponent</span>(<span class=\"params\">node, shouldHaveDebugID</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">var</span> instance;</div><div class=\"line\">  <span class=\"comment\">//...</span></div></pre></td></tr></table></figure></p>\n<p>不深入这段代码可以发现这是一段根据 ReactNode（关于 ReactNode 的定义需要仔细研究）来 instance 一个 ReactComponent 的 instance 的方法。</p>\n<p>那么我们在深入到 ReactReconciler 的代码中看一下这个 child（ReactComponent 的 instance）究竟被用来做什么了。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/**</div><div class=\"line\">   * Initializes the component, renders markup, and registers event listeners.</div><div class=\"line\">   *</div><div class=\"line\">   * @param &#123;ReactComponent&#125; internalInstance</div><div class=\"line\">   * @param &#123;ReactReconcileTransaction|ReactServerRenderingTransaction&#125; transaction</div><div class=\"line\">   * @param &#123;?object&#125; the containing host component instance</div><div class=\"line\">   * @param &#123;?object&#125; info about the host container</div><div class=\"line\">   * @return &#123;?string&#125; Rendered markup to be inserted into the DOM.</div><div class=\"line\">   * @final</div><div class=\"line\">   * @internal</div><div class=\"line\">   */</span></div><div class=\"line\">  mountComponent: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></div><div class=\"line\">    internalInstance,</div><div class=\"line\">    transaction,</div><div class=\"line\">    hostParent,</div><div class=\"line\">    hostContainerInfo,</div><div class=\"line\">    context,</div><div class=\"line\">    parentDebugID, <span class=\"regexp\">//</span> <span class=\"number\">0</span> in production and for roots</div><div class=\"line\">  </span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (__DEV__) &#123;</div><div class=\"line\">      <span class=\"keyword\">if</span> (internalInstance._debugID !== <span class=\"number\">0</span>) &#123;</div><div class=\"line\">        ReactInstrumentation.debugTool.onBeforeMountComponent(</div><div class=\"line\">          internalInstance._debugID,</div><div class=\"line\">          internalInstance._currentElement,</div><div class=\"line\">          parentDebugID,</div><div class=\"line\">        );</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">var</span> markup = internalInstance.mountComponent(<span class=\"comment\">// 直接又调用了 ReactComponent 的mountComponent 的方法</span></div><div class=\"line\">      transaction,</div><div class=\"line\">      hostParent,</div><div class=\"line\">      hostContainerInfo,</div><div class=\"line\">      context,</div><div class=\"line\">      parentDebugID,</div><div class=\"line\">    );</div><div class=\"line\"><span class=\"comment\">//...</span></div></pre></td></tr></table></figure></p>\n<p>这里需要注意的是， 这个 internalInstance 是之前的 child，但是这个 child 不一定是 ReactCompositeComponent 类型的 Instance，也有可能是其他类型的 Component 的 Instance，不过我们可以先看，如果是 ReactCompositeComponent 类型的 Instance 的话，怎么处理？<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// ReactCompositeComponent.js</span></div><div class=\"line\"><span class=\"comment\">/**</div><div class=\"line\">   * Initializes the component, renders markup, and registers event listeners.</div><div class=\"line\">   *</div><div class=\"line\">   * @param &#123;ReactReconcileTransaction|ReactServerRenderingTransaction&#125; transaction</div><div class=\"line\">   * @param &#123;?object&#125; hostParent</div><div class=\"line\">   * @param &#123;?object&#125; hostContainerInfo</div><div class=\"line\">   * @param &#123;?object&#125; context</div><div class=\"line\">   * @return &#123;?string&#125; Rendered markup to be inserted into the DOM.</div><div class=\"line\">   * @final</div><div class=\"line\">   * @internal</div><div class=\"line\">   */</span></div><div class=\"line\">  mountComponent: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></div><div class=\"line\">    transaction,</div><div class=\"line\">    hostParent,</div><div class=\"line\">    hostContainerInfo,</div><div class=\"line\">    context,</div><div class=\"line\">  </span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>._context = context;</div><div class=\"line\">    <span class=\"keyword\">this</span>._mountOrder = nextMountID++;</div><div class=\"line\">    <span class=\"keyword\">this</span>._hostParent = hostParent;</div><div class=\"line\">    <span class=\"keyword\">this</span>._hostContainerInfo = hostContainerInfo;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">var</span> publicProps = <span class=\"keyword\">this</span>._currentElement.props;</div><div class=\"line\">    <span class=\"keyword\">var</span> publicContext = <span class=\"keyword\">this</span>._processContext(context);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">var</span> Component = <span class=\"keyword\">this</span>._currentElement.type;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">var</span> updateQueue = transaction.getUpdateQueue();</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// Initialize the public class</span></div><div class=\"line\">    <span class=\"keyword\">var</span> doConstruct = shouldConstruct(Component);</div><div class=\"line\">    <span class=\"keyword\">var</span> inst = <span class=\"keyword\">this</span>._constructComponent(</div><div class=\"line\">      doConstruct,</div><div class=\"line\">      publicProps,</div><div class=\"line\">      publicContext,</div><div class=\"line\">      updateQueue,</div><div class=\"line\">    );</div><div class=\"line\">    <span class=\"keyword\">var</span> renderedElement; <span class=\"comment\">// 注意这个 renderedElement</span></div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// Support functional components</span></div><div class=\"line\">    <span class=\"keyword\">if</span> (!doConstruct &amp;&amp; (inst == <span class=\"literal\">null</span> || inst.render == <span class=\"literal\">null</span>)) &#123;</div><div class=\"line\">      renderedElement = inst; <span class=\"comment\">// 同时当 doConstruct 和 inst 为空的时候，持有一份 inst，应该其实就是空</span></div><div class=\"line\">      <span class=\"keyword\">if</span> (__DEV__) &#123;</div><div class=\"line\">        warning(</div><div class=\"line\">          !Component.childContextTypes,</div><div class=\"line\">          <span class=\"string\">'%s(...): childContextTypes cannot be defined on a functional component.'</span>,</div><div class=\"line\">          Component.displayName || Component.name || <span class=\"string\">'Component'</span>,</div><div class=\"line\">        );</div><div class=\"line\">      &#125;</div><div class=\"line\"><span class=\"comment\">//...</span></div><div class=\"line\">    <span class=\"keyword\">var</span> markup;</div><div class=\"line\">    <span class=\"keyword\">if</span> (inst.unstable_handleError) &#123;</div><div class=\"line\">      markup = <span class=\"keyword\">this</span>.performInitialMountWithErrorHandling(</div><div class=\"line\">        renderedElement,  </div><div class=\"line\">        hostParent,</div><div class=\"line\">        hostContainerInfo,</div><div class=\"line\">        transaction,</div><div class=\"line\">        context,</div><div class=\"line\">      );</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">      markup = <span class=\"keyword\">this</span>.performInitialMount(</div><div class=\"line\">        renderedElement,</div><div class=\"line\">        hostParent,</div><div class=\"line\">        hostContainerInfo,</div><div class=\"line\">        transaction,</div><div class=\"line\">        context,</div><div class=\"line\">      );</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure></p>\n<p>需要注意的是，这里的 this 其实就是之前的 child，所以这里会很奇怪，取了 child 的属性，然后又调用 _constructrComponent 方法来进行:<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div></pre></td><td class=\"code\"><pre><div class=\"line\">_constructComponent: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></div><div class=\"line\">    doConstruct,</div><div class=\"line\">    publicProps,</div><div class=\"line\">    publicContext,</div><div class=\"line\">    updateQueue,</div><div class=\"line\">  </span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (__DEV__) &#123;</div><div class=\"line\">      ReactCurrentOwner.current = <span class=\"keyword\">this</span>;</div><div class=\"line\">      <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>._constructComponentWithoutOwner(</div><div class=\"line\">          doConstruct,</div><div class=\"line\">          publicProps,</div><div class=\"line\">          publicContext,</div><div class=\"line\">          updateQueue,</div><div class=\"line\">        );</div><div class=\"line\">      &#125; <span class=\"keyword\">finally</span> &#123;</div><div class=\"line\">        ReactCurrentOwner.current = <span class=\"literal\">null</span>;</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>._constructComponentWithoutOwner(</div><div class=\"line\">        doConstruct,</div><div class=\"line\">        publicProps,</div><div class=\"line\">        publicContext,</div><div class=\"line\">        updateQueue,</div><div class=\"line\">      );</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;,</div><div class=\"line\"></div><div class=\"line\"><span class=\"attr\">_constructComponentWithoutOwner</span>: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></div><div class=\"line\">    doConstruct,</div><div class=\"line\">    publicProps,</div><div class=\"line\">    publicContext,</div><div class=\"line\">    updateQueue,</div><div class=\"line\">  </span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> Component = <span class=\"keyword\">this</span>._currentElement.type; <span class=\"comment\">// 注意这里</span></div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">if</span> (doConstruct) &#123;</div><div class=\"line\">      <span class=\"keyword\">if</span> (__DEV__) &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> measureLifeCyclePerf(</div><div class=\"line\">          <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> <span class=\"keyword\">new</span> Component(publicProps, publicContext, updateQueue),</div><div class=\"line\">          <span class=\"keyword\">this</span>._debugID,</div><div class=\"line\">          <span class=\"string\">'ctor'</span>,</div><div class=\"line\">        );</div><div class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Component(publicProps, publicContext, updateQueue);</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\"><span class=\"comment\">//...</span></div></pre></td></tr></table></figure></p>\n<p>最终 又新建了一个 Component 的 instance，我们来从一开始追溯到这里，看看 <code>var Component = this._currentElement.type</code> 这句里面的 Component 究竟和 child 是什么关系:<br><code>var Component = child._currentElement.type;</code> （因为这里的 this 就是 child）<br>所以这里返回的又是和 child 本身类型相同的 Instance（也许这里类型不一致），非常古怪。</p>\n<p>然后在回到之前的代码，我们发现，performInitialMount method 又被调用了，并且传入 this 就是 child 和 renderedElement 就是 null 或者是上面提到的用 child 的 _currentElement.type 构造出来的 Instance。</p>\n<p>这个时候，我们发现原来：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">performInitialMount: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></div><div class=\"line\">    renderedElement,</div><div class=\"line\">    hostParent,</div><div class=\"line\">    hostContainerInfo,</div><div class=\"line\">    transaction,</div><div class=\"line\">    context,</div><div class=\"line\">  </span>) </span>&#123;</div><div class=\"line\">    <span class=\"comment\">// If not a stateless component, we now render</span></div><div class=\"line\">    <span class=\"keyword\">if</span> (renderedElement === <span class=\"literal\">undefined</span>) &#123;</div><div class=\"line\">      renderedElement = <span class=\"keyword\">this</span>._renderValidatedComponent();</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">var</span> nodeType = ReactNodeTypes.getType(renderedElement);</div><div class=\"line\">    <span class=\"keyword\">this</span>._renderedNodeType = nodeType;</div><div class=\"line\">    <span class=\"keyword\">var</span> child = <span class=\"keyword\">this</span>._instantiateReactComponent(</div><div class=\"line\">      renderedElement,</div><div class=\"line\">      nodeType !== ReactNodeTypes.EMPTY <span class=\"comment\">/* shouldHaveDebugID */</span>,</div><div class=\"line\">    );</div><div class=\"line\">    <span class=\"keyword\">this</span>._renderedComponent = child;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//...</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">/**</div><div class=\"line\">   * @private</div><div class=\"line\">   */</span></div><div class=\"line\">  _renderValidatedComponent: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> renderedElement;</div><div class=\"line\">    <span class=\"keyword\">if</span> (</div><div class=\"line\">      __DEV__ ||</div><div class=\"line\">      <span class=\"keyword\">this</span>._compositeType !== ReactCompositeComponentTypes.StatelessFunctional</div><div class=\"line\">    ) &#123;</div><div class=\"line\">      ReactCurrentOwner.current = <span class=\"keyword\">this</span>;</div><div class=\"line\">      <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">        renderedElement = <span class=\"keyword\">this</span>._renderValidatedComponentWithoutOwnerOrContext();</div><div class=\"line\">      &#125; <span class=\"keyword\">finally</span> &#123;</div><div class=\"line\">        ReactCurrentOwner.current = <span class=\"literal\">null</span>;</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">      renderedElement = <span class=\"keyword\">this</span>._renderValidatedComponentWithoutOwnerOrContext();</div><div class=\"line\">    &#125;</div><div class=\"line\">    invariant(</div><div class=\"line\">      <span class=\"comment\">// <span class=\"doctag\">TODO:</span> An `isValidNode` function would probably be more appropriate</span></div><div class=\"line\">      renderedElement === <span class=\"literal\">null</span> ||</div><div class=\"line\">        renderedElement === <span class=\"literal\">false</span> ||</div><div class=\"line\">        React.isValidElement(renderedElement),</div><div class=\"line\">      <span class=\"string\">'%s.render(): A valid React element (or null) must be returned. You may have '</span> +</div><div class=\"line\">        <span class=\"string\">'returned undefined, an array or some other invalid object.'</span>,</div><div class=\"line\">      <span class=\"keyword\">this</span>.getName() || <span class=\"string\">'ReactCompositeComponent'</span>,</div><div class=\"line\">    );</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">return</span> renderedElement;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//...</span></div><div class=\"line\"></div><div class=\"line\"> _renderValidatedComponentWithoutOwnerOrContext: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> inst = <span class=\"keyword\">this</span>._instance;</div><div class=\"line\">    <span class=\"keyword\">var</span> renderedElement;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">if</span> (__DEV__) &#123;</div><div class=\"line\">      renderedElement = measureLifeCyclePerf(</div><div class=\"line\">        <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> inst.render(),</div><div class=\"line\">        <span class=\"keyword\">this</span>._debugID,</div><div class=\"line\">        <span class=\"string\">'render'</span>,</div><div class=\"line\">      );</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">      renderedElement = inst.render();</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">if</span> (__DEV__) &#123;</div><div class=\"line\">      <span class=\"comment\">// We allow auto-mocks to proceed as if they're returning null.</span></div><div class=\"line\">      <span class=\"keyword\">if</span> (renderedElement === <span class=\"literal\">undefined</span> &amp;&amp; inst.render._isMockFunction) &#123;</div><div class=\"line\">        <span class=\"comment\">// This is probably bad practice. Consider warning here and</span></div><div class=\"line\">        <span class=\"comment\">// deprecating this convenience.</span></div><div class=\"line\">        renderedElement = <span class=\"literal\">null</span>;</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">return</span> renderedElement;</div><div class=\"line\">  &#125;</div></pre></td></tr></table></figure></p>\n<p>观察这三个方法，发现这个 链表 结构原来是如此搭建起来的，所以 precacheNode 做的遍历实际上就是找到最终的子节点，用一个 随机生成的 key 来存储。</p>\n<p><strong>false</strong>：<br>就不会进行上面的这一段处理，也就是说不会重用以前的 markup，而是直接生成将 markup 插入到响应的 dom node 里面去。</p>\n"},{"title":"可读性好的代码","date":"2017-05-20T17:19:57.000Z","_content":"\n# 写在前面\n我本周最大的收获便是读完了 \"the art of readable code\", 这本书由 Dustin Boswell，Travor Foucher 合作完成，主要讲述一些利于提升代码可读性的总结性技巧，看完收获颇多，写下这边 post 来总结一下自己所学到的东西。\n\n# Name\n1.命名要具体\n\n最常见的例子便是 get* 的使用，比如从服务器端拉取数据，很喜欢使用 get，但实际上并不是向 get 描述的那样，很简单就拉取到了，这里使用 fetch 是更好的选择。\n\n2.避免使用没意义的名字\n\n如 ret、result、tmp，除非这个变量只会出现在三行左右的地方\n\n3.添加更多信息到命名之中\n\n比如 size，size 时大小的含义，但是如果有单位区分的话，那么一个 size 很容易造成误解，可以加上 size_KB/size_kb\n\n4.属性、方法的命名传统（工作的时候遇到的）\n\n属性的话，一般是 名词／形容词\n方法的命名一般是 动词词组\n\n5.避免使用含义不清晰的词\n\n比如 filter、limit， 当你需要使用 limit 的时候，使用 max、min 来代替更好，filter 的情况使用 select／remove 更好\n\n# Comment\n1.comment 需要的判断法则\n> Anticipate which parts of your code will make readers say “Huh?” and comment those.\n\n2.对代码进行高层次的介绍\n\n很多时候从代码整体的结构给出的注释很有价值\n\n3.使用 example 来 comment\n\nexample 让人清晰明了\n\n# condition statement\n1.尽量减少 if 语句\n\n越少的 if 语句意味着代码可读性更好，代码更容易测试。\n\n2.先处理简单的条件\n\n先处理简单的条件会让人的思维更加清晰\n\n3.避免出现嵌套的 if 语句\n\n这样的代码看着就感觉很乱，如果能避免一定要避免\n\n# break down giant code block\n如果能讲一块集中的代码很好的抽象成 mehtod 自然是更好的\n\n# 变量管理\n1.消除不必要的变量\n\n比如像是连续出现的两次相同的变量名，完全没必要出现\n\n2.缩小变量的 scope\n\n这一点会让代码可读性好上不少，基本上可以让读代码的人少了许多记忆的压力\n\n3.多使用 常量（只赋值一次的变量）\n\n如果一个变量的类型是常量，那么自然对于测试、读方便很多，尤其是和第二点结合起来\n\n# method／function\n最重要的原则 one task at a time\n\n# test\n1.为 input output 写产生函数\n\n没有必要每次都手动生成 input、output\n\n2.减少对外部的依赖\n\n写测试最麻烦的地方在于被测试的模块对外部以来比较高，因此如果能减少外部的依赖，那么 test 的工作量将会减少","source":"_posts/可读性好的代码.md","raw":"---\ntitle: 可读性好的代码\ndate: 2017-05-21 01:19:57\ntags: code techniques\n---\n\n# 写在前面\n我本周最大的收获便是读完了 \"the art of readable code\", 这本书由 Dustin Boswell，Travor Foucher 合作完成，主要讲述一些利于提升代码可读性的总结性技巧，看完收获颇多，写下这边 post 来总结一下自己所学到的东西。\n\n# Name\n1.命名要具体\n\n最常见的例子便是 get* 的使用，比如从服务器端拉取数据，很喜欢使用 get，但实际上并不是向 get 描述的那样，很简单就拉取到了，这里使用 fetch 是更好的选择。\n\n2.避免使用没意义的名字\n\n如 ret、result、tmp，除非这个变量只会出现在三行左右的地方\n\n3.添加更多信息到命名之中\n\n比如 size，size 时大小的含义，但是如果有单位区分的话，那么一个 size 很容易造成误解，可以加上 size_KB/size_kb\n\n4.属性、方法的命名传统（工作的时候遇到的）\n\n属性的话，一般是 名词／形容词\n方法的命名一般是 动词词组\n\n5.避免使用含义不清晰的词\n\n比如 filter、limit， 当你需要使用 limit 的时候，使用 max、min 来代替更好，filter 的情况使用 select／remove 更好\n\n# Comment\n1.comment 需要的判断法则\n> Anticipate which parts of your code will make readers say “Huh?” and comment those.\n\n2.对代码进行高层次的介绍\n\n很多时候从代码整体的结构给出的注释很有价值\n\n3.使用 example 来 comment\n\nexample 让人清晰明了\n\n# condition statement\n1.尽量减少 if 语句\n\n越少的 if 语句意味着代码可读性更好，代码更容易测试。\n\n2.先处理简单的条件\n\n先处理简单的条件会让人的思维更加清晰\n\n3.避免出现嵌套的 if 语句\n\n这样的代码看着就感觉很乱，如果能避免一定要避免\n\n# break down giant code block\n如果能讲一块集中的代码很好的抽象成 mehtod 自然是更好的\n\n# 变量管理\n1.消除不必要的变量\n\n比如像是连续出现的两次相同的变量名，完全没必要出现\n\n2.缩小变量的 scope\n\n这一点会让代码可读性好上不少，基本上可以让读代码的人少了许多记忆的压力\n\n3.多使用 常量（只赋值一次的变量）\n\n如果一个变量的类型是常量，那么自然对于测试、读方便很多，尤其是和第二点结合起来\n\n# method／function\n最重要的原则 one task at a time\n\n# test\n1.为 input output 写产生函数\n\n没有必要每次都手动生成 input、output\n\n2.减少对外部的依赖\n\n写测试最麻烦的地方在于被测试的模块对外部以来比较高，因此如果能减少外部的依赖，那么 test 的工作量将会减少","slug":"可读性好的代码","published":1,"updated":"2017-05-21T04:06:22.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjbdyo31q000snf8jud30y9au","content":"<h1 id=\"写在前面\"><a href=\"#写在前面\" class=\"headerlink\" title=\"写在前面\"></a>写在前面</h1><p>我本周最大的收获便是读完了 “the art of readable code”, 这本书由 Dustin Boswell，Travor Foucher 合作完成，主要讲述一些利于提升代码可读性的总结性技巧，看完收获颇多，写下这边 post 来总结一下自己所学到的东西。</p>\n<h1 id=\"Name\"><a href=\"#Name\" class=\"headerlink\" title=\"Name\"></a>Name</h1><p>1.命名要具体</p>\n<p>最常见的例子便是 get* 的使用，比如从服务器端拉取数据，很喜欢使用 get，但实际上并不是向 get 描述的那样，很简单就拉取到了，这里使用 fetch 是更好的选择。</p>\n<p>2.避免使用没意义的名字</p>\n<p>如 ret、result、tmp，除非这个变量只会出现在三行左右的地方</p>\n<p>3.添加更多信息到命名之中</p>\n<p>比如 size，size 时大小的含义，但是如果有单位区分的话，那么一个 size 很容易造成误解，可以加上 size_KB/size_kb</p>\n<p>4.属性、方法的命名传统（工作的时候遇到的）</p>\n<p>属性的话，一般是 名词／形容词<br>方法的命名一般是 动词词组</p>\n<p>5.避免使用含义不清晰的词</p>\n<p>比如 filter、limit， 当你需要使用 limit 的时候，使用 max、min 来代替更好，filter 的情况使用 select／remove 更好</p>\n<h1 id=\"Comment\"><a href=\"#Comment\" class=\"headerlink\" title=\"Comment\"></a>Comment</h1><p>1.comment 需要的判断法则</p>\n<blockquote>\n<p>Anticipate which parts of your code will make readers say “Huh?” and comment those.</p>\n</blockquote>\n<p>2.对代码进行高层次的介绍</p>\n<p>很多时候从代码整体的结构给出的注释很有价值</p>\n<p>3.使用 example 来 comment</p>\n<p>example 让人清晰明了</p>\n<h1 id=\"condition-statement\"><a href=\"#condition-statement\" class=\"headerlink\" title=\"condition statement\"></a>condition statement</h1><p>1.尽量减少 if 语句</p>\n<p>越少的 if 语句意味着代码可读性更好，代码更容易测试。</p>\n<p>2.先处理简单的条件</p>\n<p>先处理简单的条件会让人的思维更加清晰</p>\n<p>3.避免出现嵌套的 if 语句</p>\n<p>这样的代码看着就感觉很乱，如果能避免一定要避免</p>\n<h1 id=\"break-down-giant-code-block\"><a href=\"#break-down-giant-code-block\" class=\"headerlink\" title=\"break down giant code block\"></a>break down giant code block</h1><p>如果能讲一块集中的代码很好的抽象成 mehtod 自然是更好的</p>\n<h1 id=\"变量管理\"><a href=\"#变量管理\" class=\"headerlink\" title=\"变量管理\"></a>变量管理</h1><p>1.消除不必要的变量</p>\n<p>比如像是连续出现的两次相同的变量名，完全没必要出现</p>\n<p>2.缩小变量的 scope</p>\n<p>这一点会让代码可读性好上不少，基本上可以让读代码的人少了许多记忆的压力</p>\n<p>3.多使用 常量（只赋值一次的变量）</p>\n<p>如果一个变量的类型是常量，那么自然对于测试、读方便很多，尤其是和第二点结合起来</p>\n<h1 id=\"method／function\"><a href=\"#method／function\" class=\"headerlink\" title=\"method／function\"></a>method／function</h1><p>最重要的原则 one task at a time</p>\n<h1 id=\"test\"><a href=\"#test\" class=\"headerlink\" title=\"test\"></a>test</h1><p>1.为 input output 写产生函数</p>\n<p>没有必要每次都手动生成 input、output</p>\n<p>2.减少对外部的依赖</p>\n<p>写测试最麻烦的地方在于被测试的模块对外部以来比较高，因此如果能减少外部的依赖，那么 test 的工作量将会减少</p>\n","excerpt":"","more":"<h1 id=\"写在前面\"><a href=\"#写在前面\" class=\"headerlink\" title=\"写在前面\"></a>写在前面</h1><p>我本周最大的收获便是读完了 “the art of readable code”, 这本书由 Dustin Boswell，Travor Foucher 合作完成，主要讲述一些利于提升代码可读性的总结性技巧，看完收获颇多，写下这边 post 来总结一下自己所学到的东西。</p>\n<h1 id=\"Name\"><a href=\"#Name\" class=\"headerlink\" title=\"Name\"></a>Name</h1><p>1.命名要具体</p>\n<p>最常见的例子便是 get* 的使用，比如从服务器端拉取数据，很喜欢使用 get，但实际上并不是向 get 描述的那样，很简单就拉取到了，这里使用 fetch 是更好的选择。</p>\n<p>2.避免使用没意义的名字</p>\n<p>如 ret、result、tmp，除非这个变量只会出现在三行左右的地方</p>\n<p>3.添加更多信息到命名之中</p>\n<p>比如 size，size 时大小的含义，但是如果有单位区分的话，那么一个 size 很容易造成误解，可以加上 size_KB/size_kb</p>\n<p>4.属性、方法的命名传统（工作的时候遇到的）</p>\n<p>属性的话，一般是 名词／形容词<br>方法的命名一般是 动词词组</p>\n<p>5.避免使用含义不清晰的词</p>\n<p>比如 filter、limit， 当你需要使用 limit 的时候，使用 max、min 来代替更好，filter 的情况使用 select／remove 更好</p>\n<h1 id=\"Comment\"><a href=\"#Comment\" class=\"headerlink\" title=\"Comment\"></a>Comment</h1><p>1.comment 需要的判断法则</p>\n<blockquote>\n<p>Anticipate which parts of your code will make readers say “Huh?” and comment those.</p>\n</blockquote>\n<p>2.对代码进行高层次的介绍</p>\n<p>很多时候从代码整体的结构给出的注释很有价值</p>\n<p>3.使用 example 来 comment</p>\n<p>example 让人清晰明了</p>\n<h1 id=\"condition-statement\"><a href=\"#condition-statement\" class=\"headerlink\" title=\"condition statement\"></a>condition statement</h1><p>1.尽量减少 if 语句</p>\n<p>越少的 if 语句意味着代码可读性更好，代码更容易测试。</p>\n<p>2.先处理简单的条件</p>\n<p>先处理简单的条件会让人的思维更加清晰</p>\n<p>3.避免出现嵌套的 if 语句</p>\n<p>这样的代码看着就感觉很乱，如果能避免一定要避免</p>\n<h1 id=\"break-down-giant-code-block\"><a href=\"#break-down-giant-code-block\" class=\"headerlink\" title=\"break down giant code block\"></a>break down giant code block</h1><p>如果能讲一块集中的代码很好的抽象成 mehtod 自然是更好的</p>\n<h1 id=\"变量管理\"><a href=\"#变量管理\" class=\"headerlink\" title=\"变量管理\"></a>变量管理</h1><p>1.消除不必要的变量</p>\n<p>比如像是连续出现的两次相同的变量名，完全没必要出现</p>\n<p>2.缩小变量的 scope</p>\n<p>这一点会让代码可读性好上不少，基本上可以让读代码的人少了许多记忆的压力</p>\n<p>3.多使用 常量（只赋值一次的变量）</p>\n<p>如果一个变量的类型是常量，那么自然对于测试、读方便很多，尤其是和第二点结合起来</p>\n<h1 id=\"method／function\"><a href=\"#method／function\" class=\"headerlink\" title=\"method／function\"></a>method／function</h1><p>最重要的原则 one task at a time</p>\n<h1 id=\"test\"><a href=\"#test\" class=\"headerlink\" title=\"test\"></a>test</h1><p>1.为 input output 写产生函数</p>\n<p>没有必要每次都手动生成 input、output</p>\n<p>2.减少对外部的依赖</p>\n<p>写测试最麻烦的地方在于被测试的模块对外部以来比较高，因此如果能减少外部的依赖，那么 test 的工作量将会减少</p>\n"},{"title":"值得记录的一些小问题","date":"2017-05-21T12:12:25.000Z","_content":"## 概要\n本篇 post，是为了记录一些工作学习中遇到的小问题，所谓小问题是指没有必要去深入系统的了解，但是如果不记录下来又会在之后忘记掉的问题。\n\n# ES6 循环 import\nES6 中如果出现循环 import 是不会报错的，但是目前实际使用时我们使用的是 webpack 对其进行打包，因此其实是存在一些问题的：\n\n```javascript\n// a.js\nimport B from './b';\nconsole.log(B);\nconst A = 'A';\nexport default A;\n\n//b.js\nimport A from './a';\nconsole.log(A);\nconst B = 'B';\nexport default B;\n\n//main.js\nimport A from './a';\nimport B from './b';\nconsole.log(A);\nconsole.log(B);\n...\n```\n\n这几个文件使用 webpack 打包后运行会导致输出结果是：\n```javascript\nundefined\nB\nA\nB\n```\n\n这是因为 ES\b6 的 import 得到是一个 reference，而这个 reference 在使用的时候如果还没有被\b初始化，自然会是出现 undefined。\n\n这里的输出之所以会是这样，是因为 main\b.js 中先 import 了 A， 而在 a.js 中又会立即 import B，这样\b最先执行的一个 console.log 实际上是 b.js 中的 console.log(A)，而这时 A 又是没有初始化的，自然是 undefined。\n\n但是理论上讲这应该算是 webpack 的一个 bug，见这个 [link](https://github.com/webpack/webpack/issues/1788)。","source":"_posts/值得记录的一些小问题.md","raw":"---\ntitle: 值得记录的一些小问题\ndate: 2017-05-21 20:12:25\ntags: javascript\n---\n## 概要\n本篇 post，是为了记录一些工作学习中遇到的小问题，所谓小问题是指没有必要去深入系统的了解，但是如果不记录下来又会在之后忘记掉的问题。\n\n# ES6 循环 import\nES6 中如果出现循环 import 是不会报错的，但是目前实际使用时我们使用的是 webpack 对其进行打包，因此其实是存在一些问题的：\n\n```javascript\n// a.js\nimport B from './b';\nconsole.log(B);\nconst A = 'A';\nexport default A;\n\n//b.js\nimport A from './a';\nconsole.log(A);\nconst B = 'B';\nexport default B;\n\n//main.js\nimport A from './a';\nimport B from './b';\nconsole.log(A);\nconsole.log(B);\n...\n```\n\n这几个文件使用 webpack 打包后运行会导致输出结果是：\n```javascript\nundefined\nB\nA\nB\n```\n\n这是因为 ES\b6 的 import 得到是一个 reference，而这个 reference 在使用的时候如果还没有被\b初始化，自然会是出现 undefined。\n\n这里的输出之所以会是这样，是因为 main\b.js 中先 import 了 A， 而在 a.js 中又会立即 import B，这样\b最先执行的一个 console.log 实际上是 b.js 中的 console.log(A)，而这时 A 又是没有初始化的，自然是 undefined。\n\n但是理论上讲这应该算是 webpack 的一个 bug，见这个 [link](https://github.com/webpack/webpack/issues/1788)。","slug":"值得记录的一些小问题","published":1,"updated":"2017-05-21T13:31:14.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjbdyo31v000unf8jmeb6px4d","content":"<h2 id=\"概要\"><a href=\"#概要\" class=\"headerlink\" title=\"概要\"></a>概要</h2><p>本篇 post，是为了记录一些工作学习中遇到的小问题，所谓小问题是指没有必要去深入系统的了解，但是如果不记录下来又会在之后忘记掉的问题。</p>\n<h1 id=\"ES6-循环-import\"><a href=\"#ES6-循环-import\" class=\"headerlink\" title=\"ES6 循环 import\"></a>ES6 循环 import</h1><p>ES6 中如果出现循环 import 是不会报错的，但是目前实际使用时我们使用的是 webpack 对其进行打包，因此其实是存在一些问题的：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// a.js</span></div><div class=\"line\"><span class=\"keyword\">import</span> B <span class=\"keyword\">from</span> <span class=\"string\">'./b'</span>;</div><div class=\"line\"><span class=\"built_in\">console</span>.log(B);</div><div class=\"line\"><span class=\"keyword\">const</span> A = <span class=\"string\">'A'</span>;</div><div class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> A;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//b.js</span></div><div class=\"line\"><span class=\"keyword\">import</span> A <span class=\"keyword\">from</span> <span class=\"string\">'./a'</span>;</div><div class=\"line\"><span class=\"built_in\">console</span>.log(A);</div><div class=\"line\"><span class=\"keyword\">const</span> B = <span class=\"string\">'B'</span>;</div><div class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> B;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//main.js</span></div><div class=\"line\"><span class=\"keyword\">import</span> A <span class=\"keyword\">from</span> <span class=\"string\">'./a'</span>;</div><div class=\"line\"><span class=\"keyword\">import</span> B <span class=\"keyword\">from</span> <span class=\"string\">'./b'</span>;</div><div class=\"line\"><span class=\"built_in\">console</span>.log(A);</div><div class=\"line\"><span class=\"built_in\">console</span>.log(B);</div><div class=\"line\">...</div></pre></td></tr></table></figure>\n<p>这几个文件使用 webpack 打包后运行会导致输出结果是：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"literal\">undefined</span></div><div class=\"line\">B</div><div class=\"line\">A</div><div class=\"line\">B</div></pre></td></tr></table></figure></p>\n<p>这是因为 ES\b6 的 import 得到是一个 reference，而这个 reference 在使用的时候如果还没有被\b初始化，自然会是出现 undefined。</p>\n<p>这里的输出之所以会是这样，是因为 main\b.js 中先 import 了 A， 而在 a.js 中又会立即 import B，这样\b最先执行的一个 console.log 实际上是 b.js 中的 console.log(A)，而这时 A 又是没有初始化的，自然是 undefined。</p>\n<p>但是理论上讲这应该算是 webpack 的一个 bug，见这个 <a href=\"https://github.com/webpack/webpack/issues/1788\" target=\"_blank\" rel=\"external\">link</a>。</p>\n","excerpt":"","more":"<h2 id=\"概要\"><a href=\"#概要\" class=\"headerlink\" title=\"概要\"></a>概要</h2><p>本篇 post，是为了记录一些工作学习中遇到的小问题，所谓小问题是指没有必要去深入系统的了解，但是如果不记录下来又会在之后忘记掉的问题。</p>\n<h1 id=\"ES6-循环-import\"><a href=\"#ES6-循环-import\" class=\"headerlink\" title=\"ES6 循环 import\"></a>ES6 循环 import</h1><p>ES6 中如果出现循环 import 是不会报错的，但是目前实际使用时我们使用的是 webpack 对其进行打包，因此其实是存在一些问题的：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// a.js</span></div><div class=\"line\"><span class=\"keyword\">import</span> B <span class=\"keyword\">from</span> <span class=\"string\">'./b'</span>;</div><div class=\"line\"><span class=\"built_in\">console</span>.log(B);</div><div class=\"line\"><span class=\"keyword\">const</span> A = <span class=\"string\">'A'</span>;</div><div class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> A;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//b.js</span></div><div class=\"line\"><span class=\"keyword\">import</span> A <span class=\"keyword\">from</span> <span class=\"string\">'./a'</span>;</div><div class=\"line\"><span class=\"built_in\">console</span>.log(A);</div><div class=\"line\"><span class=\"keyword\">const</span> B = <span class=\"string\">'B'</span>;</div><div class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> B;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//main.js</span></div><div class=\"line\"><span class=\"keyword\">import</span> A <span class=\"keyword\">from</span> <span class=\"string\">'./a'</span>;</div><div class=\"line\"><span class=\"keyword\">import</span> B <span class=\"keyword\">from</span> <span class=\"string\">'./b'</span>;</div><div class=\"line\"><span class=\"built_in\">console</span>.log(A);</div><div class=\"line\"><span class=\"built_in\">console</span>.log(B);</div><div class=\"line\">...</div></pre></td></tr></table></figure>\n<p>这几个文件使用 webpack 打包后运行会导致输出结果是：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"literal\">undefined</span></div><div class=\"line\">B</div><div class=\"line\">A</div><div class=\"line\">B</div></pre></td></tr></table></figure></p>\n<p>这是因为 ES\b6 的 import 得到是一个 reference，而这个 reference 在使用的时候如果还没有被\b初始化，自然会是出现 undefined。</p>\n<p>这里的输出之所以会是这样，是因为 main\b.js 中先 import 了 A， 而在 a.js 中又会立即 import B，这样\b最先执行的一个 console.log 实际上是 b.js 中的 console.log(A)，而这时 A 又是没有初始化的，自然是 undefined。</p>\n<p>但是理论上讲这应该算是 webpack 的一个 bug，见这个 <a href=\"https://github.com/webpack/webpack/issues/1788\">link</a>。</p>\n"},{"title":"前端面试方法","date":"2017-07-09T23:35:47.000Z","_content":"## 一面\n### 基本知识\n1. 设计一个基本的组件，如 dialog，popup，modal。（提供什么接口，实现过程中需要注意哪些关键的问题，调用过程中可能会出现哪些边界情况？）\n2. 框架类的题目，挑他最熟悉的框架，问一个稍微深入的问题，以检测是否深入学习框架，如果这个问题答不出，直接问其该框架有哪些深入研究过的点？\n\n### 项目相关\n1. 做过最满意的项目是什么？\n2. 你在其中担任什么角色？\n3. 遇到的最困难的问题是什么以及是如何解决的？\n4. 可有哪些可以改善的地方？\n\n### 代码测试\n目前使用 leetcode 上面 easy 难度的题，就是检测是否适合写代码，难度由简单开始，能做出第一题即可，然后如何可以引导其是否可以优化。","source":"_posts/前端面试方法.md","raw":"---\ntitle: 前端面试方法\ndate: 2017-07-10 07:35:47\ntags: 面试\n---\n## 一面\n### 基本知识\n1. 设计一个基本的组件，如 dialog，popup，modal。（提供什么接口，实现过程中需要注意哪些关键的问题，调用过程中可能会出现哪些边界情况？）\n2. 框架类的题目，挑他最熟悉的框架，问一个稍微深入的问题，以检测是否深入学习框架，如果这个问题答不出，直接问其该框架有哪些深入研究过的点？\n\n### 项目相关\n1. 做过最满意的项目是什么？\n2. 你在其中担任什么角色？\n3. 遇到的最困难的问题是什么以及是如何解决的？\n4. 可有哪些可以改善的地方？\n\n### 代码测试\n目前使用 leetcode 上面 easy 难度的题，就是检测是否适合写代码，难度由简单开始，能做出第一题即可，然后如何可以引导其是否可以优化。","slug":"前端面试方法","published":1,"updated":"2017-07-09T23:49:35.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjbdyo31w000wnf8ja5zgy2w2","content":"<h2 id=\"一面\"><a href=\"#一面\" class=\"headerlink\" title=\"一面\"></a>一面</h2><h3 id=\"基本知识\"><a href=\"#基本知识\" class=\"headerlink\" title=\"基本知识\"></a>基本知识</h3><ol>\n<li>设计一个基本的组件，如 dialog，popup，modal。（提供什么接口，实现过程中需要注意哪些关键的问题，调用过程中可能会出现哪些边界情况？）</li>\n<li>框架类的题目，挑他最熟悉的框架，问一个稍微深入的问题，以检测是否深入学习框架，如果这个问题答不出，直接问其该框架有哪些深入研究过的点？</li>\n</ol>\n<h3 id=\"项目相关\"><a href=\"#项目相关\" class=\"headerlink\" title=\"项目相关\"></a>项目相关</h3><ol>\n<li>做过最满意的项目是什么？</li>\n<li>你在其中担任什么角色？</li>\n<li>遇到的最困难的问题是什么以及是如何解决的？</li>\n<li>可有哪些可以改善的地方？</li>\n</ol>\n<h3 id=\"代码测试\"><a href=\"#代码测试\" class=\"headerlink\" title=\"代码测试\"></a>代码测试</h3><p>目前使用 leetcode 上面 easy 难度的题，就是检测是否适合写代码，难度由简单开始，能做出第一题即可，然后如何可以引导其是否可以优化。</p>\n","excerpt":"","more":"<h2 id=\"一面\"><a href=\"#一面\" class=\"headerlink\" title=\"一面\"></a>一面</h2><h3 id=\"基本知识\"><a href=\"#基本知识\" class=\"headerlink\" title=\"基本知识\"></a>基本知识</h3><ol>\n<li>设计一个基本的组件，如 dialog，popup，modal。（提供什么接口，实现过程中需要注意哪些关键的问题，调用过程中可能会出现哪些边界情况？）</li>\n<li>框架类的题目，挑他最熟悉的框架，问一个稍微深入的问题，以检测是否深入学习框架，如果这个问题答不出，直接问其该框架有哪些深入研究过的点？</li>\n</ol>\n<h3 id=\"项目相关\"><a href=\"#项目相关\" class=\"headerlink\" title=\"项目相关\"></a>项目相关</h3><ol>\n<li>做过最满意的项目是什么？</li>\n<li>你在其中担任什么角色？</li>\n<li>遇到的最困难的问题是什么以及是如何解决的？</li>\n<li>可有哪些可以改善的地方？</li>\n</ol>\n<h3 id=\"代码测试\"><a href=\"#代码测试\" class=\"headerlink\" title=\"代码测试\"></a>代码测试</h3><p>目前使用 leetcode 上面 easy 难度的题，就是检测是否适合写代码，难度由简单开始，能做出第一题即可，然后如何可以引导其是否可以优化。</p>\n"},{"title":"Move Fast","date":"2017-04-23T14:14:52.000Z","_content":"\n我放弃读 PhD，孤身来到杭州，想要在自己喜欢的领域作出一番成就，成为这个领域的专家，我始终抱有这样的幻想：\n我是很厉害的，我可以在我喜欢的事情上做得很顺利，我会理所当然地成为一个专家。\n\n然而事实却是：我和普通人一样。\n\n在我写下这篇随笔的时候，其实我在工作上很不顺利，并且我自己也选择了逃避，我每天害怕着站会，并且期待着下班，不再和之前一样，充满了热情，就连这个周末也是过得非常颓废。\n\n最终和往常一样，我的内疚感使我决定重新站立起来，我也真真切切地明白了这样的道理，没有人能够随随便便成功！如果这样想，我想自己也会变得更加坚强吧。\n\n我想自己接下来的两个月里，要努力地在前端这方面进行更深入地探索与练习，一定要多写代码。\n\n此外，我这周的工作让我发现自己的工作效率非常低下，我总结了一下原因：\n写代码时会出现神思游离，导致出现很难发现的 bug（比如变量名写错了）\n解决方案：\na. 模块化实现功能（在纸上列举出需要的步骤，一步步完成）\nb. 在写代码的时候，一定要有意识地意识到自己在写不能出现低级错误、style 正确（使用各种 lint 工具）的code\n\n最近，一个前辈负责写数据逻辑部分的代码，我看到他的写法，第一次感觉自己是太渺小了，我觉得自己要变得更厉害，要比他还厉害。\n\n我现在的情况很是纠结，工作的事情多，自己又想看与语言无关的知识，同时又想看工作中使用的框架的源码。","source":"_posts/痛苦的反思.md","raw":"title: Move Fast\ndate: 2017-04-23 22:14:52\ntags: 随笔\n---\n\n我放弃读 PhD，孤身来到杭州，想要在自己喜欢的领域作出一番成就，成为这个领域的专家，我始终抱有这样的幻想：\n我是很厉害的，我可以在我喜欢的事情上做得很顺利，我会理所当然地成为一个专家。\n\n然而事实却是：我和普通人一样。\n\n在我写下这篇随笔的时候，其实我在工作上很不顺利，并且我自己也选择了逃避，我每天害怕着站会，并且期待着下班，不再和之前一样，充满了热情，就连这个周末也是过得非常颓废。\n\n最终和往常一样，我的内疚感使我决定重新站立起来，我也真真切切地明白了这样的道理，没有人能够随随便便成功！如果这样想，我想自己也会变得更加坚强吧。\n\n我想自己接下来的两个月里，要努力地在前端这方面进行更深入地探索与练习，一定要多写代码。\n\n此外，我这周的工作让我发现自己的工作效率非常低下，我总结了一下原因：\n写代码时会出现神思游离，导致出现很难发现的 bug（比如变量名写错了）\n解决方案：\na. 模块化实现功能（在纸上列举出需要的步骤，一步步完成）\nb. 在写代码的时候，一定要有意识地意识到自己在写不能出现低级错误、style 正确（使用各种 lint 工具）的code\n\n最近，一个前辈负责写数据逻辑部分的代码，我看到他的写法，第一次感觉自己是太渺小了，我觉得自己要变得更厉害，要比他还厉害。\n\n我现在的情况很是纠结，工作的事情多，自己又想看与语言无关的知识，同时又想看工作中使用的框架的源码。","slug":"痛苦的反思","published":1,"updated":"2017-05-11T14:57:36.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjbdyo31y000ynf8jxwwcf2il","content":"<p>我放弃读 PhD，孤身来到杭州，想要在自己喜欢的领域作出一番成就，成为这个领域的专家，我始终抱有这样的幻想：<br>我是很厉害的，我可以在我喜欢的事情上做得很顺利，我会理所当然地成为一个专家。</p>\n<p>然而事实却是：我和普通人一样。</p>\n<p>在我写下这篇随笔的时候，其实我在工作上很不顺利，并且我自己也选择了逃避，我每天害怕着站会，并且期待着下班，不再和之前一样，充满了热情，就连这个周末也是过得非常颓废。</p>\n<p>最终和往常一样，我的内疚感使我决定重新站立起来，我也真真切切地明白了这样的道理，没有人能够随随便便成功！如果这样想，我想自己也会变得更加坚强吧。</p>\n<p>我想自己接下来的两个月里，要努力地在前端这方面进行更深入地探索与练习，一定要多写代码。</p>\n<p>此外，我这周的工作让我发现自己的工作效率非常低下，我总结了一下原因：<br>写代码时会出现神思游离，导致出现很难发现的 bug（比如变量名写错了）<br>解决方案：<br>a. 模块化实现功能（在纸上列举出需要的步骤，一步步完成）<br>b. 在写代码的时候，一定要有意识地意识到自己在写不能出现低级错误、style 正确（使用各种 lint 工具）的code</p>\n<p>最近，一个前辈负责写数据逻辑部分的代码，我看到他的写法，第一次感觉自己是太渺小了，我觉得自己要变得更厉害，要比他还厉害。</p>\n<p>我现在的情况很是纠结，工作的事情多，自己又想看与语言无关的知识，同时又想看工作中使用的框架的源码。</p>\n","excerpt":"","more":"<p>我放弃读 PhD，孤身来到杭州，想要在自己喜欢的领域作出一番成就，成为这个领域的专家，我始终抱有这样的幻想：<br>我是很厉害的，我可以在我喜欢的事情上做得很顺利，我会理所当然地成为一个专家。</p>\n<p>然而事实却是：我和普通人一样。</p>\n<p>在我写下这篇随笔的时候，其实我在工作上很不顺利，并且我自己也选择了逃避，我每天害怕着站会，并且期待着下班，不再和之前一样，充满了热情，就连这个周末也是过得非常颓废。</p>\n<p>最终和往常一样，我的内疚感使我决定重新站立起来，我也真真切切地明白了这样的道理，没有人能够随随便便成功！如果这样想，我想自己也会变得更加坚强吧。</p>\n<p>我想自己接下来的两个月里，要努力地在前端这方面进行更深入地探索与练习，一定要多写代码。</p>\n<p>此外，我这周的工作让我发现自己的工作效率非常低下，我总结了一下原因：<br>写代码时会出现神思游离，导致出现很难发现的 bug（比如变量名写错了）<br>解决方案：<br>a. 模块化实现功能（在纸上列举出需要的步骤，一步步完成）<br>b. 在写代码的时候，一定要有意识地意识到自己在写不能出现低级错误、style 正确（使用各种 lint 工具）的code</p>\n<p>最近，一个前辈负责写数据逻辑部分的代码，我看到他的写法，第一次感觉自己是太渺小了，我觉得自己要变得更厉害，要比他还厉害。</p>\n<p>我现在的情况很是纠结，工作的事情多，自己又想看与语言无关的知识，同时又想看工作中使用的框架的源码。</p>\n"},{"title":"React-源码阅读-Component-Update","date":"2017-07-06T17:55:38.000Z","_content":"# ReactComponent 的更新流程\n\n## 如何开始\n我是直接通过跑一个 react 的例子发现在 setState 操作出去的时候， performUpdateIfnecessary 开始了运行。\n\n我们就从 ReactCompositeComponent 的 performUpdateIfnecessary 看起：\n\n```javascript\n/**\n  * If any of `_pendingElement`, `_pendingStateQueue`, or `_pendingForceUpdate`\n  * is set, update the component.\n  *\n  * @param {ReactReconcileTransaction} transaction\n  * @internal\n  */\nperformUpdateIfNecessary: function(transaction) {\n  if (this._pendingElement != null) {\n    ReactReconciler.receiveComponent(\n      this,\n      this._pendingElement,\n      transaction,\n      this._context,\n    );\n  } else if (this._pendingStateQueue !== null || this._pendingForceUpdate) {\n    this.updateComponent(\n      transaction,\n      this._currentElement,\n      this._currentElement,\n      this._context,\n      this._context,\n    );\n  } else {\n    var callbacks = this._pendingCallbacks;\n    this._pendingCallbacks = null;\n    if (callbacks) {\n      for (var j = 0; j < callbacks.length; j++) {\n        transaction\n          .getReactMountReady()\n          .enqueue(callbacks[j], this.getPublicInstance());\n      }\n    }\n    this._updateBatchNumber = null;\n  }\n}\n```\n\n这个函数发现会有几种执行情况，如果 this._pendingElement 存在的话，会直接调用 ReactReconciler.receiveComponent 来更新，如果不存在但是 _pendingStateQueue 或者 强制更新 被 set 了，那么 updateComponent 便会被调用，最后如果上述条件都没有满足，那么只会去执行嵌入的  callback。\n\n我们先看使用 updateComponent 的情况\n首先记住 updateComponent 参数的意义：\n\n```javascript\nupdateComponent: function(\n  transaction,\n  prevParentElement,\n  nextParentElement,\n  prevUnmaskedContext,\n  nextUnmaskedContext,\n) {\n  //...\n  var prevProps = prevParentElement.props;\n  var nextProps = nextParentElement.props;\n  //...\n  var nextState = this._processPendingState(nextProps, nextContext);\n  //...\n  if (shouldUpdate) {\n    this._pendingForceUpdate = false;\n    // Will set `this.props`, `this.state` and `this.context`.\n    this._performComponentUpdate(\n      nextParentElement,\n      nextProps,\n      nextState,\n      nextContext,\n      transaction,\n      nextUnmaskedContext,\n    );\n  } else {\n    // If it's determined that a component should not update, we still want\n    // to set props and state but we shortcut the rest of the update.\n    this._currentElement = nextParentElement;\n    this._context = nextUnmaskedContext;\n    inst.props = nextProps;\n    inst.state = nextState;\n    inst.context = nextContext;\n  }\n\n  if (callbacks) {\n    for (var j = 0; j < callbacks.length; j++) {\n      transaction\n        .getReactMountReady()\n        .enqueue(callbacks[j], this.getPublicInstance());\n    }\n  }\n}\n```\n\n然后注意到传入的参数是当前的 element 和 context，因此这里只是做 state 的更新。\nthis._processPendingState 这个函数会用来计算 nextState：\n\n```javascript\n _processPendingState: function(props, context) {\n    var inst = this._instance;\n    var queue = this._pendingStateQueue;\n    var replace = this._pendingReplaceState;\n    this._pendingReplaceState = false;\n    this._pendingStateQueue = null;\n\n    if (!queue) {\n      return inst.state;\n    }\n\n    if (replace && queue.length === 1) {\n      return queue[0];\n    }\n\n    var nextState = replace ? queue[0] : inst.state;\n    var dontMutate = true;\n    for (var i = replace ? 1 : 0; i < queue.length; i++) {\n      var partial = queue[i];\n      let partialState = typeof partial === 'function'\n        ? partial.call(inst, nextState, props, context)\n        : partial;\n      if (partialState) {\n        if (dontMutate) {\n          dontMutate = false;\n          nextState = Object.assign({}, nextState, partialState);\n        } else {\n          Object.assign(nextState, partialState);\n        }\n      }\n    }\n\n    return nextState;\n  },\n```\n\n这个函数有趣的地方在于：\n1. 会把你所有的 setState 填入的状态融合起来，也就是说很有可能只有最后一次的 State 有效果\n2. state 也可以传入一个 function\n\n有了新的 state 之后，便会进入 this._performComponentUpdate 这个函数的调用：\n\n```javascript\n_performComponentUpdate: function(\n  nextElement,\n  nextProps,\n  nextState,\n  nextContext,\n  transaction,\n  unmaskedContext,\n) {\n  var inst = this._instance;\n  //...\n  if (inst.componentWillUpdate) {\n    if (__DEV__) {\n      measureLifeCyclePerf(\n        () => inst.componentWillUpdate(nextProps, nextState, nextContext),\n        this._debugID,\n        'componentWillUpdate',\n      );\n    } else {\n      inst.componentWillUpdate(nextProps, nextState, nextContext);\n    }\n  }\n  this._currentElement = nextElement;\n  this._context = unmaskedContext;\n  inst.props = nextProps;\n  inst.state = nextState;\n  inst.context = nextContext;\n\n  if (inst.unstable_handleError) {\n    this._updateRenderedComponentWithErrorHandling(\n      transaction,\n      unmaskedContext,\n    );\n  } else {\n    this._updateRenderedComponent(transaction, unmaskedContext);\n  }\n\n  //... ComponentDidUpdate\n}\n```\n\n这个函数在 componentWillUpdate 和 componentDidUpdate 之间调用了：\n\n```javascript\nthis._updateRenderedComponent(transaction, unmaskedContext);\n```\n\n我们继续看 _updateRenderedComponent:\n```javascript\n/**\n  * Call the component's `render` method and update the DOM accordingly.\n  *\n  * @param {ReactReconcileTransaction} transaction\n  * @internal\n  */\n_updateRenderedComponent: function(transaction, context) {\n  var nextRenderedElement = this._renderValidatedComponent();\n  this._updateRenderedComponentWithNextElement(\n    transaction,\n    context,\n    nextRenderedElement,\n    false /* safely */,\n  );\n},\n```\n\n this._renderValidatedComponent 里面表明要看 _updateRenderedComponentWithoutOwnerOrContext：\n\n```javascript\n/**\n  * @protected\n  */\n_renderValidatedComponentWithoutOwnerOrContext: function() {\n  var inst = this._instance;\n  var renderedElement;\n\n  if (__DEV__) {\n    renderedElement = measureLifeCyclePerf(\n      () => inst.render(),\n      this._debugID,\n      'render',\n    );\n  } else {\n    renderedElement = inst.render();\n  }\n\n  if (__DEV__) {\n    // We allow auto-mocks to proceed as if they're returning null.\n    if (renderedElement === undefined && inst.render._isMockFunction) {\n      // This is probably bad practice. Consider warning here and\n      // deprecating this convenience.\n      renderedElement = null;\n    }\n  }\n\n  return renderedElement;\n}\n```\n\n可以看出来这个会调用 render 方法，调用了 render 方法后就会返回 一个 新的 element。\n\n再回到 _updateRenderedComponent:\n\n```javascript\n/**\n  * Call the component's `render` method and update the DOM accordingly.\n  *\n  * @param {ReactReconcileTransaction} transaction\n  * @internal\n  */\n_updateRenderedComponent: function(transaction, context) {\n  var nextRenderedElement = this._renderValidatedComponent();\n  this._updateRenderedComponentWithNextElement(\n    transaction,\n    context,\n    nextRenderedElement,\n    false /* safely */,\n  );\n},\n```\n\n拿到了 render 出来的 element 就会调用 _updateRenderedComponentWithNextElement:\n\n```javascript\n/**\n  * Call the component's `render` method and update the DOM accordingly.\n  *\n  * @param {ReactReconcileTransaction} transaction\n  * @internal\n  */\n_updateRenderedComponentWithNextElement: function(\n  transaction,\n  context,\n  nextRenderedElement,\n  safely,\n) {\n  var prevComponentInstance = this._renderedComponent;\n  var prevRenderedElement = prevComponentInstance._currentElement;\n\n  //...\n\n  if (shouldUpdateReactComponent(prevRenderedElement, nextRenderedElement)) {\n    ReactReconciler.receiveComponent(\n      prevComponentInstance,\n      nextRenderedElement,\n      transaction,\n      this._processChildContext(context),\n    );\n  }\n  //...\n```\n\n到这里会发现 首先调用 shouldUpdateReactComponent，注意这个和生命周期里面的 shouldComponentUpdate 不同。\n如果返回 true，那么直接调用 ReactReconciler 的 receiveComponent 来进行更新。\n\n那么我们就先看一下 shoudlUpdateReactComponent:\n\n```javascript\n/**\n* Given a `prevElement` and `nextElement`, determines if the existing\n* instance should be updated as opposed to being destroyed or replaced by a new\n* instance. Both arguments are elements. This ensures that this logic can\n* operate on stateless trees without any backing instance.\n*\n* @param {?object} prevElement\n* @param {?object} nextElement\n* @return {boolean} True if the existing instance should be updated.\n* @protected\n*/\nfunction shouldUpdateReactComponent(prevElement, nextElement) {\n  var prevEmpty = prevElement === null || prevElement === false;\n  var nextEmpty = nextElement === null || nextElement === false;\n  if (prevEmpty || nextEmpty) {\n    return prevEmpty === nextEmpty;\n  }\n\n  var prevType = typeof prevElement;\n  var nextType = typeof nextElement;\n  if (prevType === 'string' || prevType === 'number') {\n    return nextType === 'string' || nextType === 'number';\n  } else {\n    return (\n      nextType === 'object' &&\n      prevElement.type === nextElement.type &&\n      prevElement.key === nextElement.key\n    );\n  }\n}\n```\n\n注意这段代码的注释部分，该函数返回 true 意味着更新当前的 instance，而不是直接 destroy 掉，若是返回 false，那么就是说当前的 instance 会被销毁加替代。\n为 true 的条件很简单：\n1. 如果是 string 或者 number 直接返回 true\n2. 如果是 object 必须保证 type 和 key 一致\n\n让我们在回到上层代码，考虑 shoudlUpdateReactComponent 结果为 true 的时候，ReactConciler.ReceiveComponent 的调用：\n\n```javascript\n//_updateRenderedComponentWithNextElement: function\nReactReconciler.receiveComponent(\n        prevComponentInstance,\n        nextRenderedElement,\n        transaction,\n        this._processChildContext(context),\n      );\n```\n\n这里有段 context 的处理，但是考虑到目前 context 的使用并不是很频繁，我们直接跳过。\n我们再看一下 ReactReconciler.receiveComponent 的实现：\n\n```javascript\n// ReactReconciler.receiveComponent\n/**\n  * Update a component using a new element.\n  *\n  * @param {ReactComponent} internalInstance\n  * @param {ReactElement} nextElement\n  * @param {ReactReconcileTransaction} transaction\n  * @param {object} context\n  * @internal\n  */\nreceiveComponent: function(\n  internalInstance,\n  nextElement,\n  transaction,\n  context,\n) {\n  var prevElement = internalInstance._currentElement;\n\n  if (nextElement === prevElement && context === internalInstance._context) {\n    // Since elements are immutable after the owner is rendered,\n    // we can do a cheap identity compare here to determine if this is a\n    // superfluous reconcile. It's possible for state to be mutable but such\n    // change should trigger an update of the owner which would recreate\n    // the element. We explicitly check for the existence of an owner since\n    // it's possible for an element created outside a composite to be\n    // deeply mutated and reused.\n\n    // TODO: Bailing out early is just a perf optimization right?\n    // TODO: Removing the return statement should affect correctness?\n    return;\n  }\n  //...\n  internalInstance.receiveComponent(nextElement, transaction, context);\n  //...\n},\n```\n\n这段代码这里省略了一些 ref 的处理，不过以后也可以详细谈。\n这里会做一次检查，会做一次 reference 的比较，如果相同，那么自然就没有必要去更新。\n然后在使用传入的 internalInstance.receiveComponent 去做真正的更新。\n\n那么我们直接看 ReactComponent 的 receiveComponent：\n\n```javascript\nreceiveComponent: function(nextElement, transaction, nextContext) {\n  var prevElement = this._currentElement;\n  var prevContext = this._context;\n\n  this._pendingElement = null;\n\n  this.updateComponent(\n    transaction,\n    prevElement,\n    nextElement,\n    prevContext,\n    nextContext,\n  );\n}\n```\n\n然后我们发现居然又回到了 updateComponent 这个函数，因此现在有两个问题：\n1. 上次调用和这次调用那里不同？\n2. 如果不同，是一种递归的话，在哪里停止？\n第一个问题是容易回答的，肯定不同，不同之处在于 this 发生了变化，其实这个 instance 是这样来的：\n\n```javascript\n/**\n  * Call the component's `render` method and update the DOM accordingly.\n  *\n  * @param {ReactReconcileTransaction} transaction\n  * @internal\n  */\n_updateRenderedComponentWithNextElement: function(\n  transaction,\n  context,\n  nextRenderedElement,\n  safely,\n) {\n  var prevComponentInstance = this._renderedComponent;\n  //...\n```\n\n而 this._renderedComponent 的唯一 assignment 是在 _updateRenderedComponentWithNextElement 的另一条条件分支里面，也就是说当需要替换 component 的时候，会将产生这个 assignment：\n\n```javascript\n_updateRenderedComponentWithNextElement: function(\n  transaction,\n  context,\n  nextRenderedElement,\n  safely,\n) {\n  var prevComponentInstance = this._renderedComponent;\n  var prevRenderedElement = prevComponentInstance._currentElement;\n\n  //...\n\nif (shouldUpdateReactComponent(prevRenderedElement, nextRenderedElement)) {\n  ReactReconciler.receiveComponent(\n    prevComponentInstance,\n    nextRenderedElement,\n    transaction,\n    this._processChildContext(context),\n  );\n} else {\n  var oldHostNode = ReactReconciler.getHostNode(prevComponentInstance);\n  var nodeType = ReactNodeTypes.getType(nextRenderedElement);\n  this._renderedNodeType = nodeType;\n  var child = this._instantiateReactComponent(\n    nextRenderedElement,\n    nodeType !== ReactNodeTypes.EMPTY /* shouldHaveDebugID */,\n  );\n  this._renderedComponent = child;\n  //...\n```\n\n这里试想如果是第一次进入这个函数，this.\\_renderedComponent 肯定是 undefined，而 nextRenderedElement 肯定不是空的，也就说一定会进入第二个分支，然后将新的 element 实例化成新的 this.\\_renderedComponent。\n因此所有的秘密都停留在了 this._instantiateReactComponent 里面了。\n\n```javascript\n/**\n * Given a ReactNode, create an instance that will actually be mounted.\n *\n * @param {ReactNode} node\n * @param {boolean} shouldHaveDebugID\n * @return {object} A new instance of the element's constructor.\n * @protected\n */\nfunction instantiateReactComponent(node, shouldHaveDebugID) {\n  var instance;\n\n  if (node === null || node === false) {\n    instance = ReactEmptyComponent.create(instantiateReactComponent);\n  } else if (typeof node === 'object') {\n    var element = node;\n    var type = element.type;\n    if (typeof type !== 'function' && typeof type !== 'string') {\n      var info = '';\n      if (__DEV__) {\n        if (\n          type === undefined ||\n          (typeof type === 'object' &&\n            type !== null &&\n            Object.keys(type).length === 0)\n        ) {\n          info +=\n            ' You likely forgot to export your component from the file ' +\n            \"it's defined in.\";\n        }\n      }\n      info += getDeclarationErrorAddendum(element._owner);\n      invariant(\n        false,\n        'Element type is invalid: expected a string (for built-in components) ' +\n          'or a class/function (for composite components) but got: %s.%s',\n        type == null ? type : typeof type,\n        info,\n      );\n    }\n\n    // Special case string values\n    if (typeof element.type === 'string') {\n      instance = ReactHostComponent.createInternalComponent(element);\n    } else if (isInternalComponentType(element.type)) {\n      // This is temporarily available for custom components that are not string\n      // representations. I.e. ART. Once those are updated to use the string\n      // representation, we can drop this code path.\n      instance = new element.type(element);\n\n      // We renamed this. Allow the old name for compat. :(\n      if (!instance.getHostNode) {\n        instance.getHostNode = instance.getNativeNode;\n      }\n    } else {\n      instance = new ReactCompositeComponentWrapper(element);\n    }\n  } else if (typeof node === 'string' || typeof node === 'number') {\n    instance = ReactHostComponent.createInstanceForText(node);\n  } else {\n    invariant(false, 'Encountered invalid React node of type %s', typeof node);\n  }\n\n  if (__DEV__) {\n    warning(\n      typeof instance.mountComponent === 'function' &&\n        typeof instance.receiveComponent === 'function' &&\n        typeof instance.getHostNode === 'function' &&\n        typeof instance.unmountComponent === 'function',\n      'Only React Components can be mounted.',\n    );\n  }\n\n  // These two fields are used by the DOM and ART diffing algorithms\n  // respectively. Instead of using expandos on components, we should be\n  // storing the state needed by the diffing algorithms elsewhere.\n  instance._mountIndex = 0;\n  instance._mountImage = null;\n\n  if (__DEV__) {\n    instance._debugID = shouldHaveDebugID ? nextDebugID++ : 0;\n  }\n\n  // Internal instances should fully constructed at this point, so they should\n  // not get any new fields added to them at this point.\n  if (__DEV__) {\n    if (Object.preventExtensions) {\n      Object.preventExtensions(instance);\n    }\n  }\n\n  return instance;\n}\n```\n\n这段代码其实简单的看来就是处理三种不同的 ReactElement：\n1. string, number => 直接使用 ReactHostComponent.createInstanceForText 来进行实例化\n\n```javascript\n//...\n else if (typeof node === 'string' || typeof node === 'number') {\n    instance = ReactHostComponent.createInstanceForText(node);\n//...\n```\n\n2. 是 object 并且其 type 字段又是 string，那么就会使用 ReactHostComponent.createInternalComponent 来进行实例化\n\n```javascript\n//...\n if (typeof element.type === 'string') {\n      instance = ReactHostComponent.createInternalComponent(element);\n    }\n//...\n```\n\n3. 是 CompositeElement，会使用 ReactCompositeComponentWrapper 来进行实例化，其中会做一次检查，检查是否是是自定义的 type（只要定义了 mountComponent 和 receiveComponent 就行了）\n\n因此在回到我们之前的问题：\n\n```javascript\n_updateRenderedComponentWithNextElement: function(\n  transaction,\n  context,\n  nextRenderedElement,\n  safely,\n) {\n  var prevComponentInstance = this._renderedComponent;\n  var prevRenderedElement = prevComponentInstance._currentElement;\n\n  //...\n\nif (shouldUpdateReactComponent(prevRenderedElement, nextRenderedElement)) {\n  ReactReconciler.receiveComponent(\n    prevComponentInstance,\n    nextRenderedElement,\n    transaction,\n    this._processChildContext(context),\n  );\n} else {\n  var oldHostNode = ReactReconciler.getHostNode(prevComponentInstance);\n  var nodeType = ReactNodeTypes.getType(nextRenderedElement);\n  this._renderedNodeType = nodeType;\n  var child = this._instantiateReactComponent(\n    nextRenderedElement,\n    nodeType !== ReactNodeTypes.EMPTY /* shouldHaveDebugID */,\n  );\n  this._renderedComponent = child;\n  //...\n```\n\n这个 child 实际上就是被实例化出来的一个新的 Component（注意为什么是 child，是因为 nextRenderedElement 是用当前 Component 的 render 函数形成的），所以 第一个问题解决了：\n>1. 上次调用和这次调用那里不同？\n>2. 如果不同，是一种递归的话，在哪里停止？\n\n那么第二个问题是怎么解决的呢？\n直观上看这个递归的结束很简单，就是最后没有了 child，所以这里就不深究了。\n\n```javascript\n//...\nelse if (isInternalComponentType(element.type)) {\n      // This is temporarily available for custom components that are not string\n      // representations. I.e. ART. Once those are updated to use the string\n      // representation, we can drop this code path.\n      instance = new element.type(element);\n\n      // We renamed this. Allow the old name for compat. :(\n      if (!instance.getHostNode) {\n        instance.getHostNode = instance.getNativeNode;\n      }\n    } else {\n      instance = new ReactCompositeComponentWrapper(element);\n    }\n//...\n```\n   \n再回到之前的 _updateRenderedComponentWithNextElement，把接下来的处理看掉：\n\n  ```javascript\n  // _updateRenderedComponentWithNextElement: function()\n  if (shouldUpdateReactComponent(prevRenderedElement, nextRenderedElement)) {\n    ReactReconciler.receiveComponent(\n      prevComponentInstance,\n      nextRenderedElement,\n      transaction,\n      this._processChildContext(context),\n    );\n  } \n  else {\n    var oldHostNode = ReactReconciler.getHostNode(prevComponentInstance);\n    var nodeType = ReactNodeTypes.getType(nextRenderedElement);\n    this._renderedNodeType = nodeType;\n    var child = this._instantiateReactComponent(\n      nextRenderedElement,\n      nodeType !== ReactNodeTypes.EMPTY /* shouldHaveDebugID */,\n    );\n    this._renderedComponent = child;\n\n    var nextMarkup = ReactReconciler.mountComponent(\n      child,\n      transaction,\n      this._hostParent,\n      this._hostContainerInfo,\n      this._processChildContext(context),\n      debugID,\n    );\n\n    ReactReconciler.unmountComponent(\n      prevComponentInstance,\n      safely,\n      false /* skipLifecycle */,\n    );\n\n    if (__DEV__) {\n      if (debugID !== 0) {\n        var childDebugIDs = child._debugID !== 0 ? [child._debugID] : [];\n        ReactInstrumentation.debugTool.onSetChildren(debugID, childDebugIDs);\n      }\n    }\n\n    this._replaceNodeWithMarkup(\n      oldHostNode,\n      nextMarkup,\n      prevComponentInstance,\n    );\n  }\n},\n```\n\n这块总的来说就是在 shouldUpdateReactComponent 返回 false 的时候：\n1. 保存老的 hostNode\n2. instantiate 新的 ReactComponent\n3. mount 这个新的 instance，拿到 markup\n4. unmount 旧的 instance\n5. 重新渲染 hostNode 下的 dom\n\n\n## ReactDOMComponent\n其实 ReactCompositeComponent 不会做具体的更新的。\n在 performUpdateIfNecessary 中的第一个条件表明，如果存在 pendingElement 那么会直接调用 ReactReconciler.receiveComponent。\n\n```javascript\n/**\n  * If any of `_pendingElement`, `_pendingStateQueue`, or `_pendingForceUpdate`\n  * is set, update the component.\n  *\n  * @param {ReactReconcileTransaction} transaction\n  * @internal\n  */\nperformUpdateIfNecessary: function(transaction) {\n  if (this._pendingElement != null) {\n    ReactReconciler.receiveComponent(\n      this,\n      this._pendingElement,\n      transaction,\n      this._context,\n    );\n  }\n```\n\n而 ReactReconciler.receiveComponent 中的具体做法是：\n\n```javascript\n// ReactReconciler.receiveComponent\n/**\n  * Update a component using a new element.\n  *\n  * @param {ReactComponent} internalInstance\n  * @param {ReactElement} nextElement\n  * @param {ReactReconcileTransaction} transaction\n  * @param {object} context\n  * @internal\n  */\nreceiveComponent: function(\n  internalInstance,\n  nextElement,\n  transaction,\n  context,\n) {\n  var prevElement = internalInstance._currentElement;\n\n  if (nextElement === prevElement && context === internalInstance._context) {\n    // Since elements are immutable after the owner is rendered,\n    // we can do a cheap identity compare here to determine if this is a\n    // superfluous reconcile. It's possible for state to be mutable but such\n    // change should trigger an update of the owner which would recreate\n    // the element. We explicitly check for the existence of an owner since\n    // it's possible for an element created outside a composite to be\n    // deeply mutated and reused.\n\n    // TODO: Bailing out early is just a perf optimization right?\n    // TODO: Removing the return statement should affect correctness?\n    return;\n  }\n  //...\n  internalInstance.receiveComponent(nextElement, transaction, context);\n  //...\n},\n```\n\n又把 receiveComponent delegate 给了这个 Component 的 instance，我们再看 ReactCompositeComponent.receiveComponent：\n\n```javascript\n  receiveComponent: function(nextElement, transaction, nextContext) {\n    var prevElement = this._currentElement;\n    var prevContext = this._context;\n\n    this._pendingElement = null;\n\n    this.updateComponent(\n      transaction,\n      prevElement,\n      nextElement,\n      prevContext,\n      nextContext,\n    );\n  },\n```\n\n再看 updateComponent：\n\n```javascript\n/**\n   * Perform an update to a mounted component. The componentWillReceiveProps and\n   * shouldComponentUpdate methods are called, then (assuming the update isn't\n   * skipped) the remaining update lifecycle methods are called and the DOM\n   * representation is updated.\n   *\n   * By default, this implements React's rendering and reconciliation algorithm.\n   * Sophisticated clients may wish to override this.\n   *\n   * @param {ReactReconcileTransaction} transaction\n   * @param {ReactElement} prevParentElement\n   * @param {ReactElement} nextParentElement\n   * @internal\n   * @overridable\n   */\n  updateComponent: function(\n    transaction,\n    prevParentElement,\n    nextParentElement,\n    prevUnmaskedContext,\n    nextUnmaskedContext,\n  ) {\n    if (shouldUpdate) {\n      this._pendingForceUpdate = false;\n      // Will set `this.props`, `this.state` and `this.context`.\n      this._performComponentUpdate(\n        nextParentElement,\n        nextProps,\n        nextState,\n        nextContext,\n        transaction,\n        nextUnmaskedContext,\n      );\n    } else {\n    //...\n```\n\n再看 _performComponentUpdate:\n\n```javascript\n/**\n   * Merges new props and state, notifies delegate methods of update and\n   * performs update.\n   *\n   * @param {ReactElement} nextElement Next element\n   * @param {object} nextProps Next public object to set as properties.\n   * @param {?object} nextState Next object to set as state.\n   * @param {?object} nextContext Next public object to set as context.\n   * @param {ReactReconcileTransaction} transaction\n   * @param {?object} unmaskedContext\n   * @private\n   */\n  _performComponentUpdate: function(\n    nextElement,\n    nextProps,\n    nextState,\n    nextContext,\n    transaction,\n    unmaskedContext,\n  ) {\n    var inst = this._instance;\n\n    var hasComponentDidUpdate = !!inst.componentDidUpdate;\n    var prevProps;\n    var prevState;\n    if (hasComponentDidUpdate) {\n      prevProps = inst.props;\n      prevState = inst.state;\n    }\n    //...\n    this._currentElement = nextElement;\n    this._context = unmaskedContext;\n    inst.props = nextProps;\n    inst.state = nextState;\n    inst.context = nextContext;\n\n    if (inst.unstable_handleError) {\n      this._updateRenderedComponentWithErrorHandling(\n        transaction,\n        unmaskedContext,\n      );\n    } else {\n      this._updateRenderedComponent(transaction, unmaskedContext);\n    }\n    //...\n```\n\n因此我们又要看 _updateRenderedComponent:\n\n```javascript\n  /**\n   * Call the component's `render` method and update the DOM accordingly.\n   *\n   * @param {ReactReconcileTransaction} transaction\n   * @internal\n   */\n  _updateRenderedComponent: function(transaction, context) {\n    var nextRenderedElement = this._renderValidatedComponent();\n    this._updateRenderedComponentWithNextElement(\n      transaction,\n      context,\n      nextRenderedElement,\n      false /* safely */,\n    );\n  },\n```\n\n进入 _updateRenderedComponentWithNextElement:\n\n```javascript\n/**\n   * Call the component's `render` method and update the DOM accordingly.\n   *\n   * @param {ReactReconcileTransaction} transaction\n   * @internal\n   */\n  _updateRenderedComponentWithNextElement: function(\n    transaction,\n    context,\n    nextRenderedElement,\n    safely,\n  ) {\n    var prevComponentInstance = this._renderedComponent;\n    var prevRenderedElement = prevComponentInstance._currentElement;\n\n    var debugID = 0;\n    if (__DEV__) {\n      debugID = this._debugID;\n    }\n\n    if (shouldUpdateReactComponent(prevRenderedElement, nextRenderedElement)) {\n      ReactReconciler.receiveComponent(\n        prevComponentInstance,\n        nextRenderedElement,\n        transaction,\n        this._processChildContext(context),\n      );\n    } else {\n      var oldHostNode = ReactReconciler.getHostNode(prevComponentInstance);\n      var nodeType = ReactNodeTypes.getType(nextRenderedElement);\n      this._renderedNodeType = nodeType;\n      var child = this._instantiateReactComponent(\n        nextRenderedElement,\n        nodeType !== ReactNodeTypes.EMPTY /* shouldHaveDebugID */,\n      );\n      this._renderedComponent = child;\n\n      var nextMarkup = ReactReconciler.mountComponent(\n        child,\n        transaction,\n        this._hostParent,\n        this._hostContainerInfo,\n        this._processChildContext(context),\n        debugID,\n      );\n\n      ReactReconciler.unmountComponent(\n        prevComponentInstance,\n        safely,\n        false /* skipLifecycle */,\n      );\n\n      if (__DEV__) {\n        if (debugID !== 0) {\n          var childDebugIDs = child._debugID !== 0 ? [child._debugID] : [];\n          ReactInstrumentation.debugTool.onSetChildren(debugID, childDebugIDs);\n        }\n      }\n\n      this._replaceNodeWithMarkup(\n        oldHostNode,\n        nextMarkup,\n        prevComponentInstance,\n      );\n    }\n  },\n```\n\n这里注意，根据我们之前的说明：\n\n```javascript\n/**\n   * Call the component's `render` method and update the DOM accordingly.\n   *\n   * @param {ReactReconcileTransaction} transaction\n   * @internal\n   */\n  _updateRenderedComponentWithNextElement: function(\n    transaction,\n    context,\n    nextRenderedElement,\n    safely,\n  ) {\n    var prevComponentInstance = this._renderedComponent;\n    var prevRenderedElement = prevComponentInstance._currentElement;\n\n    var debugID = 0;\n    if (__DEV__) {\n      debugID = this._debugID;\n    }\n\n    if (shouldUpdateReactComponent(prevRenderedElement, nextRenderedElement)) {\n      ReactReconciler.receiveComponent(\n        prevComponentInstance,\n        nextRenderedElement,\n        transaction,\n        this._processChildContext(context),\n      );\n    } else {\n```\n\n这里的 prevComponentInstance 实际上是 this（这个也是一个 ComponentInstance）的 render 函数返回的 ReactElement 的 Component Instance，然后 nextRenderedElement 是当前的被更新了的 ReactElement，如果我们假设这个 prevComponentInstance 是一个 ReactDOMComponent 的话，那么一切就会进入 ReactDOMComponent 的 receiveComponent，并且接受的参数就是 nextRenderedElement，我们看一下：\n\n```javascript\n/**\n   * Receives a next element and updates the component.\n   *\n   * @internal\n   * @param {ReactElement} nextElement\n   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction\n   * @param {object} context\n   */\n  receiveComponent: function(nextElement, transaction, context) {\n    var prevElement = this._currentElement;\n    this._currentElement = nextElement;\n    this.updateComponent(transaction, prevElement, nextElement, context);\n  },\n```\n\n在看 updateComponent：\n\n```javascript\n  /**\n   * Updates a DOM component after it has already been allocated and\n   * attached to the DOM. Reconciles the root DOM node, then recurses.\n   *\n   * @param {ReactReconcileTransaction} transaction\n   * @param {ReactElement} prevElement\n   * @param {ReactElement} nextElement\n   * @internal\n   * @overridable\n   */\n  updateComponent: function(transaction, prevElement, nextElement, context) {\n    var lastProps = prevElement.props;\n    var nextProps = this._currentElement.props;\n\n    switch (this._tag) {\n      case 'input':\n        lastProps = ReactDOMInput.getHostProps(this, lastProps);\n        nextProps = ReactDOMInput.getHostProps(this, nextProps);\n        break;\n      case 'option':\n        lastProps = ReactDOMOption.getHostProps(this, lastProps);\n        nextProps = ReactDOMOption.getHostProps(this, nextProps);\n        break;\n      case 'select':\n        lastProps = ReactDOMSelect.getHostProps(this, lastProps);\n        nextProps = ReactDOMSelect.getHostProps(this, nextProps);\n        break;\n      case 'textarea':\n        lastProps = ReactDOMTextarea.getHostProps(this, lastProps);\n        nextProps = ReactDOMTextarea.getHostProps(this, nextProps);\n        break;\n      default:\n        if (\n          typeof lastProps.onClick !== 'function' &&\n          typeof nextProps.onClick === 'function'\n        ) {\n          transaction\n            .getReactMountReady()\n            .enqueue(trapClickOnNonInteractiveElement, this);\n        }\n        break;\n    }\n\n    assertValidProps(this, nextProps);\n    var isCustomComponentTag = isCustomComponent(this._tag, nextProps);\n    this._updateDOMProperties(\n      lastProps,\n      nextProps,\n      transaction,\n      isCustomComponentTag,\n    );\n    this._updateDOMChildren(lastProps, nextProps, transaction, context);\n\n    switch (this._tag) {\n      case 'input':\n        // Update the wrapper around inputs *after* updating props. This has to\n        // happen after `_updateDOMProperties`. Otherwise HTML5 input validations\n        // raise warnings and prevent the new value from being assigned.\n        ReactDOMInput.updateWrapper(this);\n        break;\n      case 'textarea':\n        ReactDOMTextarea.updateWrapper(this);\n        break;\n      case 'select':\n        // <select> value update needs to occur after <option> children\n        // reconciliation\n        transaction.getReactMountReady().enqueue(postUpdateSelectWrapper, this);\n        break;\n    }\n  },\n```\n\n这段代码真的比较简单，唯一值得看的是 this._updateDOMChildren 这个函数:\n```javascript\n/**\n   * Reconciles the children with the various properties that affect the\n   * children content.\n   *\n   * @param {object} lastProps\n   * @param {object} nextProps\n   * @param {ReactReconcileTransaction} transaction\n   * @param {object} context\n   */\n  _updateDOMChildren: function(lastProps, nextProps, transaction, context) {\n    var lastContent = CONTENT_TYPES[typeof lastProps.children]\n      ? lastProps.children\n      : null;\n    var nextContent = CONTENT_TYPES[typeof nextProps.children]\n      ? nextProps.children\n      : null;\n\n    var lastHtml =\n      lastProps.dangerouslySetInnerHTML &&\n      lastProps.dangerouslySetInnerHTML.__html;\n    var nextHtml =\n      nextProps.dangerouslySetInnerHTML &&\n      nextProps.dangerouslySetInnerHTML.__html;\n\n    // Note the use of `!=` which checks for null or undefined.\n    var lastChildren = lastContent != null ? null : lastProps.children;\n    var nextChildren = nextContent != null ? null : nextProps.children;\n\n    // If we're switching from children to content/html or vice versa, remove\n    // the old content\n    var lastHasContentOrHtml = lastContent != null || lastHtml != null;\n    var nextHasContentOrHtml = nextContent != null || nextHtml != null;\n    if (lastChildren != null && nextChildren == null) {\n      this.updateChildren(null, transaction, context);\n    } else if (lastHasContentOrHtml && !nextHasContentOrHtml) {\n      this.updateTextContent('');\n      if (__DEV__) {\n        ReactInstrumentation.debugTool.onSetChildren(this._debugID, []);\n      }\n    }\n\n    if (nextContent != null) {\n      if (lastContent !== nextContent) {\n        this.updateTextContent('' + nextContent);\n        if (__DEV__) {\n          setAndValidateContentChildDev.call(this, nextContent);\n        }\n      }\n    } else if (nextHtml != null) {\n      if (lastHtml !== nextHtml) {\n        this.updateMarkup('' + nextHtml);\n      }\n      if (__DEV__) {\n        ReactInstrumentation.debugTool.onSetChildren(this._debugID, []);\n      }\n    } else if (nextChildren != null) {\n      if (__DEV__) {\n        setAndValidateContentChildDev.call(this, null);\n      }\n\n      this.updateChildren(nextChildren, transaction, context);\n    }\n  },\n```\n\n这段代码告诉我得看 updateChildren 这个函数，而这个函数是来自于其它类，最终在 ReactMultiChild 中找到：\n```javascript\n/**\n   * @param {?object} nextNestedChildrenElements Nested child element maps.\n   * @param {ReactReconcileTransaction} transaction\n   * @final\n   * @protected\n   */\n  _updateChildren: function(nextNestedChildrenElements, transaction, context) {\n    var prevChildren = this._renderedChildren;\n    var removedNodes = {};\n    var mountImages = [];\n    var nextChildren = this._reconcilerUpdateChildren(\n      prevChildren,\n      nextNestedChildrenElements,\n      mountImages,\n      removedNodes,\n      transaction,\n      context,\n    );\n    if (!nextChildren && !prevChildren) {\n      return;\n    }\n    var updates = null;\n    var name;\n    // `nextIndex` will increment for each child in `nextChildren`, but\n    // `lastIndex` will be the last index visited in `prevChildren`.\n    var nextIndex = 0;\n    var lastIndex = 0;\n    // `nextMountIndex` will increment for each newly mounted child.\n    var nextMountIndex = 0;\n    var lastPlacedNode = null;\n    for (name in nextChildren) {\n      if (!nextChildren.hasOwnProperty(name)) {\n        continue;\n      }\n      var prevChild = prevChildren && prevChildren[name];\n      var nextChild = nextChildren[name];\n      if (prevChild === nextChild) {\n        updates = enqueue(\n          updates,\n          this.moveChild(prevChild, lastPlacedNode, nextIndex, lastIndex),\n        );\n        lastIndex = Math.max(prevChild._mountIndex, lastIndex);\n        prevChild._mountIndex = nextIndex;\n      } else {\n        if (prevChild) {\n          // Update `lastIndex` before `_mountIndex` gets unset by unmounting.\n          lastIndex = Math.max(prevChild._mountIndex, lastIndex);\n          // The `removedNodes` loop below will actually remove the child.\n        }\n        // The child must be instantiated before it's mounted.\n        updates = enqueue(\n          updates,\n          this._mountChildAtIndex(\n            nextChild,\n            mountImages[nextMountIndex],\n            lastPlacedNode,\n            nextIndex,\n            transaction,\n            context,\n          ),\n        );\n        nextMountIndex++;\n      }\n      nextIndex++;\n      lastPlacedNode = ReactReconciler.getHostNode(nextChild);\n    }\n    // Remove children that are no longer present.\n    for (name in removedNodes) {\n      if (removedNodes.hasOwnProperty(name)) {\n        updates = enqueue(\n          updates,\n          this._unmountChild(prevChildren[name], removedNodes[name]),\n        );\n      }\n    }\n    if (updates) {\n      processQueue(this, updates);\n    }\n    this._renderedChildren = nextChildren;\n\n    if (__DEV__) {\n      setChildrenForInstrumentation.call(this, nextChildren);\n    }\n  },\n```\n\n还得看 this._reconcilerUpdateChildren 这个函数：\n\n```javascript\n_reconcilerUpdateChildren: function(\n    prevChildren,\n    nextNestedChildrenElements,\n    mountImages,\n    removedNodes,\n    transaction,\n    context,\n  ) {\n    var nextChildren;\n    var selfDebugID = 0;\n    if (__DEV__) {\n      selfDebugID = getDebugID(this);\n      if (this._currentElement) {\n        try {\n          ReactCurrentOwner.current = this._currentElement._owner;\n          nextChildren = flattenStackChildren(\n            nextNestedChildrenElements,\n            selfDebugID,\n          );\n        } finally {\n          ReactCurrentOwner.current = null;\n        }\n        ReactChildReconciler.updateChildren(\n          prevChildren,\n          nextChildren,\n          mountImages,\n          removedNodes,\n          transaction,\n          this,\n          this._hostContainerInfo,\n          context,\n          selfDebugID,\n        );\n        return nextChildren;\n      }\n    }\n    nextChildren = flattenStackChildren(\n      nextNestedChildrenElements,\n      selfDebugID,\n    );\n    ReactChildReconciler.updateChildren(\n      prevChildren,\n      nextChildren,\n      mountImages,\n      removedNodes,\n      transaction,\n      this,\n      this._hostContainerInfo,\n      context,\n      selfDebugID,\n    );\n    return nextChildren;\n  },\n```\n\n又得看 ReactChildReconciler.updateChildren 这个函数：\n```javascript\n/**\n   * Updates the rendered children and returns a new set of children.\n   *\n   * @param {?object} prevChildren Previously initialized set of children.\n   * @param {?object} nextChildren Flat child element maps.\n   * @param {ReactReconcileTransaction} transaction\n   * @param {object} context\n   * @return {?object} A new set of child instances.\n   * @internal\n   */\n  updateChildren: function(\n    prevChildren,\n    nextChildren,\n    mountImages,\n    removedNodes,\n    transaction,\n    hostParent,\n    hostContainerInfo,\n    context,\n    selfDebugID, // 0 in production and for roots\n  ) {\n    // We currently don't have a way to track moves here but if we use iterators\n    // instead of for..in we can zip the iterators and check if an item has\n    // moved.\n    // TODO: If nothing has changed, return the prevChildren object so that we\n    // can quickly bailout if nothing has changed.\n    if (!nextChildren && !prevChildren) {\n      return;\n    }\n    var name;\n    var prevChild;\n    for (name in nextChildren) {\n      if (!nextChildren.hasOwnProperty(name)) {\n        continue;\n      }\n      prevChild = prevChildren && prevChildren[name];\n      var prevElement = prevChild && prevChild._currentElement;\n      var nextElement = nextChildren[name];\n      if (\n        prevChild != null &&\n        shouldUpdateReactComponent(prevElement, nextElement)\n      ) {\n        ReactReconciler.receiveComponent(\n          prevChild,\n          nextElement,\n          transaction,\n          context,\n        );\n        nextChildren[name] = prevChild;\n      } else {\n        // The child must be instantiated before it's mounted.\n        var nextChildInstance = instantiateReactComponent(nextElement, true);\n        nextChildren[name] = nextChildInstance;\n        // Creating mount image now ensures refs are resolved in right order\n        // (see https://github.com/facebook/react/pull/7101 for explanation).\n        var nextChildMountImage = ReactReconciler.mountComponent(\n          nextChildInstance,\n          transaction,\n          hostParent,\n          hostContainerInfo,\n          context,\n          selfDebugID,\n        );\n        mountImages.push(nextChildMountImage);\n        if (prevChild) {\n          removedNodes[name] = ReactReconciler.getHostNode(prevChild);\n          ReactReconciler.unmountComponent(\n            prevChild,\n            false /* safely */,\n            false /* skipLifecycle */,\n          );\n        }\n      }\n    }\n    // Unmount children that are no longer present.\n    for (name in prevChildren) {\n      if (\n        prevChildren.hasOwnProperty(name) &&\n        !(nextChildren && nextChildren.hasOwnProperty(name))\n      ) {\n        prevChild = prevChildren[name];\n        removedNodes[name] = ReactReconciler.getHostNode(prevChild);\n        ReactReconciler.unmountComponent(\n          prevChild,\n          false /* safely */,\n          false /* skipLifecycle */,\n        );\n      }\n    }\n  },\n```\n\n到这里基本上结束了，这个函数会遍历所有 children，然后对其调用 ReactReconciler.receiveComponent（如果只是更新的话）或者 直接走 mount 新节点／unmount 旧节点的流程。\n\n## 更新触发起点\n现在有一个重要的问题其实还没解决，那就是哪里是更新触发的起点，即究竟是通过哪一个函数触发了更新（也就是说调用了 performUpdateIfnecessary 这个函数）:\n\n```javascript\nfunction runBatchedUpdates(transaction) {\n  var len = transaction.dirtyComponentsLength;\n  invariant(\n    len === dirtyComponents.length,\n    \"Expected flush transaction's stored dirty-components length (%s) to \" +\n      'match dirty-components array length (%s).',\n    len,\n    dirtyComponents.length,\n  );\n\n  // Since reconciling a component higher in the owner hierarchy usually (not\n  // always -- see shouldComponentUpdate()) will reconcile children, reconcile\n  // them before their children by sorting the array.\n  dirtyComponents.sort(mountOrderComparator);\n\n  // Any updates enqueued while reconciling must be performed after this entire\n  // batch. Otherwise, if dirtyComponents is [A, B] where A has children B and\n  // C, B could update twice in a single batch if C's render enqueues an update\n  // to B (since B would have already updated, we should skip it, and the only\n  // way we can know to do so is by checking the batch counter).\n  updateBatchNumber++;\n\n  for (var i = 0; i < len; i++) {\n    // If a component is unmounted before pending changes apply, it will still\n    // be here, but we assume that it has cleared its _pendingCallbacks and\n    // that performUpdateIfNecessary is a noop.\n    var component = dirtyComponents[i];\n\n    ReactReconciler.performUpdateIfNecessary(\n      component,\n      transaction.reconcileTransaction,\n      updateBatchNumber,\n    );\n  }\n}\n```\n\n然后再向上追溯:\n```javascript\nvar flushBatchedUpdates = function() {\n  // ReactUpdatesFlushTransaction's wrappers will clear the dirtyComponents\n  // array and perform any updates enqueued by mount-ready handlers (i.e.,\n  // componentDidUpdate) but we need to check here too in order to catch\n  // updates enqueued by setState callbacks.\n  while (dirtyComponents.length) {\n    var transaction = ReactUpdatesFlushTransaction.getPooled();\n    transaction.perform(runBatchedUpdates, null, transaction);\n    ReactUpdatesFlushTransaction.release(transaction);\n  }\n```\n\n发现在 ReactDefaultBatchingStrategy 这个文件中:\n\n```javascript\nvar RESET_BATCHED_UPDATES = {\n  initialize: emptyFunction,\n  close: function() {\n    ReactDefaultBatchingStrategy.isBatchingUpdates = false;\n  },\n};\n\nvar FLUSH_BATCHED_UPDATES = {\n  initialize: emptyFunction,\n  close: ReactUpdates.flushBatchedUpdates.bind(ReactUpdates),\n};\n\nvar TRANSACTION_WRAPPERS = [FLUSH_BATCHED_UPDATES, RESET_BATCHED_UPDATES];\n\nfunction ReactDefaultBatchingStrategyTransaction() {\n  this.reinitializeTransaction();\n}\n\nObject.assign(ReactDefaultBatchingStrategyTransaction.prototype, Transaction, {\n  getTransactionWrappers: function() {\n    return TRANSACTION_WRAPPERS;\n  },\n});\n\nvar transaction = new ReactDefaultBatchingStrategyTransaction();\n\nvar ReactDefaultBatchingStrategy = {\n  isBatchingUpdates: false,\n\n  /**\n   * Call the provided function in a context within which calls to `setState`\n   * and friends are batched such that components aren't updated unnecessarily.\n   */\n  batchedUpdates: function(callback, a, b, c, d, e) {\n    var alreadyBatchingUpdates = ReactDefaultBatchingStrategy.isBatchingUpdates;\n\n    ReactDefaultBatchingStrategy.isBatchingUpdates = true;\n\n    // The code is written this way to avoid extra allocations\n    if (alreadyBatchingUpdates) {\n      return callback(a, b, c, d, e);\n    } else {\n      return transaction.perform(callback, null, a, b, c, d, e);\n    }\n  },\n};\n\nmodule.exports = ReactDefaultBatchingStrategy;\n```\n\nreact 很经典的一个 transaction 处理，然后再去找 ReactDefaultBatchingStrategy 的使用，由于 DOM 和 Native 的应用场景不同，这个 Strategy 是动态插入的，我们可以看 DOM 的场景：\n\n```javascript\n// ReactDOMStackInjection.js\nvar alreadyInjected = false;\n\nfunction inject() {\n  if (alreadyInjected) {\n    // TODO: This is currently true because these injections are shared between\n    // the client and the server package. They should be built independently\n    // and not share any injection state. Then this problem will be solved.\n    return;\n  }\n  alreadyInjected = true;\n\n  ReactGenericBatching.injection.injectStackBatchedUpdates(\n    ReactUpdates.batchedUpdates,\n  );\n\n  ReactHostComponent.injection.injectGenericComponentClass(ReactDOMComponent);\n\n  ReactHostComponent.injection.injectTextComponentClass(ReactDOMTextComponent);\n\n  ReactEmptyComponent.injection.injectEmptyComponentFactory(function(\n    instantiate,\n  ) {\n    return new ReactDOMEmptyComponent(instantiate);\n  });\n\n  ReactUpdates.injection.injectReconcileTransaction(ReactReconcileTransaction);\n  /*********this-line*****************/\n  ReactUpdates.injection.injectBatchingStrategy(ReactDefaultBatchingStrategy);\n  /*********this-line*****************/\n\n  ReactComponentEnvironment.injection.injectEnvironment(\n    ReactComponentBrowserEnvironment,\n  );\n\n  findDOMNode._injectStack(function(inst) {\n    inst = getHostComponentFromComposite(inst);\n    return inst ? ReactDOMComponentTree.getNodeFromInstance(inst) : null;\n  });\n}\n\nmodule.exports = {\n  inject: inject,\n};\n```\n\n然后就去看 ReactUpdates 的 injection:\n\n```javascript\nvar ReactUpdatesInjection = {\n  injectReconcileTransaction: function(ReconcileTransaction) {\n    invariant(\n      ReconcileTransaction,\n      'ReactUpdates: must provide a reconcile transaction class',\n    );\n    ReactUpdates.ReactReconcileTransaction = ReconcileTransaction;\n  },\n\n  injectBatchingStrategy: function(_batchingStrategy) {\n    invariant(\n      _batchingStrategy,\n      'ReactUpdates: must provide a batching strategy',\n    );\n    invariant(\n      typeof _batchingStrategy.batchedUpdates === 'function',\n      'ReactUpdates: must provide a batchedUpdates() function',\n    );\n    invariant(\n      typeof _batchingStrategy.isBatchingUpdates === 'boolean',\n      'ReactUpdates: must provide an isBatchingUpdates boolean attribute',\n    );\n    batchingStrategy = _batchingStrategy;\n  },\n\n  getBatchingStrategy: function() {\n    return batchingStrategy;\n  },\n};\n\n//...\nvar ReactUpdates = {\n  /**\n   * React references `ReactReconcileTransaction` using this property in order\n   * to allow dependency injection.\n   *\n   * @internal\n   */\n  ReactReconcileTransaction: null,\n\n  batchedUpdates: batchedUpdates,\n  enqueueUpdate: enqueueUpdate,\n  flushBatchedUpdates: flushBatchedUpdates,\n  injection: ReactUpdatesInjection,\n};\n\n```\n\n这个时候，需要把调用栈反过来看一下：\nReactUpdates.injection inject 了 ReactDefaultBatchingUpdates， 而 ReactDefaultBatchingUpdates 是一个 transaction，在其中一个 tansaction_wrapper 中，调用了 ReactUpdates.flushBatchedUpdates，然后在 flushBatchedUpdates 中又调用了 runBatchedUpdates 这个函数，而这个函数直接调用了 ReactReconciler 的 performUpdateIfNecessary，这个函数又把 performUpdateIfNecessary 的具体任务 delegate 到具体的 instance。\n\n那么接下来应该如何继续探究下去呢？继续往上追溯，ReactUpdatesInjection 中提供了一个接口 getBatchingStrategy，就顺着它就行了。但是没发现有用的信息。\n\n这个时候，我们在从 setState 开始看起:\n```javascript\nReactComponent.prototype.setState = function(partialState, callback) {\n  invariant(\n    typeof partialState === 'object' ||\n      typeof partialState === 'function' ||\n      partialState == null,\n    'setState(...): takes an object of state variables to update or a ' +\n      'function which returns an object of state variables.',\n  );\n  this.updater.enqueueSetState(this, partialState, callback, 'setState');\n};\n```\n\n这个是 ReactBaseClasses，老实说不是很清楚这个 class 有什么作用，基本上函数都是空的，不过如果这个 updater 用的不是默认值呢？我们可以从 enqueueSetState 这个方法入手，有这么几个类 ReactPartialRenderer 和 ReactUpdateQueue，但是 ReactPartialRenderer 是 server rendering，所以只看 ReactUpdateQueue 即可:\n```javascript\n/**\n   * Sets a subset of the state. This only exists because _pendingState is\n   * internal. This provides a merging strategy that is not available to deep\n   * properties which is confusing. TODO: Expose pendingState or don't use it\n   * during the merge.\n   *\n   * @param {ReactClass} publicInstance The instance that should rerender.\n   * @param {object} partialState Next partial state to be merged with state.\n   * @param {?function} callback Called after state is updated.\n   * @param {?string} Name of the calling function in the public API.\n   * @internal\n   */\n  enqueueSetState: function(\n    publicInstance,\n    partialState,\n    callback,\n    callerName,\n  ) {\n    if (__DEV__) {\n      ReactInstrumentation.debugTool.onSetState();\n      warning(\n        partialState != null,\n        'setState(...): You passed an undefined or null state object; ' +\n          'instead, use forceUpdate().',\n      );\n    }\n\n    var internalInstance = getInternalInstanceReadyForUpdate(publicInstance);\n\n    if (!internalInstance) {\n      return;\n    }\n\n    var queue =\n      internalInstance._pendingStateQueue ||\n      (internalInstance._pendingStateQueue = []);\n    queue.push(partialState);\n\n    callback = callback === undefined ? null : callback;\n    if (callback !== null) {\n      if (__DEV__) {\n        warnOnInvalidCallback(callback, callerName);\n      }\n      if (internalInstance._pendingCallbacks) {\n        internalInstance._pendingCallbacks.push(callback);\n      } else {\n        internalInstance._pendingCallbacks = [callback];\n      }\n    }\n\n    enqueueUpdate(internalInstance);\n  },\n```\n\n这个函数表明 partialState 会被存在 internalInstance._pendingStateQueue 中，然后会调用 enquereUpdate，这个函数实际上来自 ReactUpdates.js 中:\n\n```javascript\n/**\n * Mark a component as needing a rerender, adding an optional callback to a\n * list of functions which will be executed once the rerender occurs.\n */\nfunction enqueueUpdate(component) {\n  ensureInjected();\n\n  // Various parts of our code (such as ReactCompositeComponent's\n  // _renderValidatedComponent) assume that calls to render aren't nested;\n  // verify that that's the case. (This is called by each top-level update\n  // function, like setState, forceUpdate, etc.; creation and\n  // destruction of top-level components is guarded in ReactMount.)\n\n  if (!batchingStrategy.isBatchingUpdates) {\n    batchingStrategy.batchedUpdates(enqueueUpdate, component);\n    return;\n  }\n\n  dirtyComponents.push(component);\n  if (component._updateBatchNumber == null) {\n    component._updateBatchNumber = updateBatchNumber + 1;\n  }\n}\n```\n\n这个 batchedUpdates 其实就是上面提供的 ReactDefaultBatchingStrategy:\n\n```javascript\nvar ReactDefaultBatchingStrategy = {\n  isBatchingUpdates: false,\n\n  /**\n   * Call the provided function in a context within which calls to `setState`\n   * and friends are batched such that components aren't updated unnecessarily.\n   */\n  batchedUpdates: function(callback, a, b, c, d, e) {\n    var alreadyBatchingUpdates = ReactDefaultBatchingStrategy.isBatchingUpdates;\n\n    ReactDefaultBatchingStrategy.isBatchingUpdates = true;\n\n    // The code is written this way to avoid extra allocations\n    if (alreadyBatchingUpdates) {\n      return callback(a, b, c, d, e);\n    } else {\n      return transaction.perform(callback, null, a, b, c, d, e);\n    }\n  },\n};\n```\n\n结合两段代码来看实际上是有两种情况，一种是正在 batching，还有一种是还没开始 batching，很容易理解，但是到目前为止似乎这个 BatchingStrategy 并没有做到 batching 这个功能，暂时先不管，继续往下看，在 transaction 的 perform 完成后，肯定是要调用 其创建时定义的 wrapper，我们也即是之前提到的:\n\n```javascript\nvar RESET_BATCHED_UPDATES = {\n  initialize: emptyFunction,\n  close: function() {\n    ReactDefaultBatchingStrategy.isBatchingUpdates = false;\n  },\n};\n\nvar FLUSH_BATCHED_UPDATES = {\n  initialize: emptyFunction,\n  close: ReactUpdates.flushBatchedUpdates.bind(ReactUpdates),\n};\n```\nReactUpdates.flushBatchedUpdates 被调用了，如果再深入下去，就可以回到我们开头的部分了。\n\n目前总体看来还有一个问题，就是 setState 似乎完全不是 enqueue 的机制，但是它函数名还这么写，我们看到的是立即更新，并没有停一下再更新。\n真的是这样吗？\n看到这样一篇[文章](https://www.bennadel.com/blog/2893-setstate-state-mutation-operation-may-be-synchronous-in-reactjs.htm)，文中指只有在 onClick 的实践处理中 setState 是 equeue 机制的，在 event not managed by react 中又是同步的。\n\n后来我进行断点调试，一步一步地进行两种情况的执行顺序，然后我发现，如果是通过 props 定义的事件响应，那么当使用 setState 的时候，触发的 enqueueUpdate:\n\n```javascript\n\n/**\n * Mark a component as needing a rerender, adding an optional callback to a\n * list of functions which will be executed once the rerender occurs.\n */\nfunction enqueueUpdate(component) {\n  ensureInjected();\n\n  // Various parts of our code (such as ReactCompositeComponent's\n  // _renderValidatedComponent) assume that calls to render aren't nested;\n  // verify that that's the case. (This is called by each top-level update\n  // function, like setState, forceUpdate, etc.; creation and\n  // destruction of top-level components is guarded in ReactMount.)\n\n  if (!batchingStrategy.isBatchingUpdates) {\n    batchingStrategy.batchedUpdates(enqueueUpdate, component);\n    return;\n  }\n\n  dirtyComponents.push(component);\n  if (component._updateBatchNumber == null) {\n    component._updateBatchNumber = updateBatchNumber + 1;\n  }\n}\n```\n\n中的 batchingStrategy.isBatchingUpdates 是 true 的，也就是说 setState 本身是处于一个 update 的 transaction 中的，所以 batchingStrategy.batchedUpdates 是不会调用的，因此如果不断的 setState 就会产生 state 本身不更新，并且将传入的 partialstate 逐步 batching，最终在触发 React 的 onClick 事件中引发的外层 update transaction 的 close 函数中进行最终的 update。\n","source":"_posts/React-源码阅读-Component-Update.md","raw":"---\ntitle: React-源码阅读-Component-Update\ndate: 2017-07-07 01:55:38\ntags: react 源码 Component setState\n---\n# ReactComponent 的更新流程\n\n## 如何开始\n我是直接通过跑一个 react 的例子发现在 setState 操作出去的时候， performUpdateIfnecessary 开始了运行。\n\n我们就从 ReactCompositeComponent 的 performUpdateIfnecessary 看起：\n\n```javascript\n/**\n  * If any of `_pendingElement`, `_pendingStateQueue`, or `_pendingForceUpdate`\n  * is set, update the component.\n  *\n  * @param {ReactReconcileTransaction} transaction\n  * @internal\n  */\nperformUpdateIfNecessary: function(transaction) {\n  if (this._pendingElement != null) {\n    ReactReconciler.receiveComponent(\n      this,\n      this._pendingElement,\n      transaction,\n      this._context,\n    );\n  } else if (this._pendingStateQueue !== null || this._pendingForceUpdate) {\n    this.updateComponent(\n      transaction,\n      this._currentElement,\n      this._currentElement,\n      this._context,\n      this._context,\n    );\n  } else {\n    var callbacks = this._pendingCallbacks;\n    this._pendingCallbacks = null;\n    if (callbacks) {\n      for (var j = 0; j < callbacks.length; j++) {\n        transaction\n          .getReactMountReady()\n          .enqueue(callbacks[j], this.getPublicInstance());\n      }\n    }\n    this._updateBatchNumber = null;\n  }\n}\n```\n\n这个函数发现会有几种执行情况，如果 this._pendingElement 存在的话，会直接调用 ReactReconciler.receiveComponent 来更新，如果不存在但是 _pendingStateQueue 或者 强制更新 被 set 了，那么 updateComponent 便会被调用，最后如果上述条件都没有满足，那么只会去执行嵌入的  callback。\n\n我们先看使用 updateComponent 的情况\n首先记住 updateComponent 参数的意义：\n\n```javascript\nupdateComponent: function(\n  transaction,\n  prevParentElement,\n  nextParentElement,\n  prevUnmaskedContext,\n  nextUnmaskedContext,\n) {\n  //...\n  var prevProps = prevParentElement.props;\n  var nextProps = nextParentElement.props;\n  //...\n  var nextState = this._processPendingState(nextProps, nextContext);\n  //...\n  if (shouldUpdate) {\n    this._pendingForceUpdate = false;\n    // Will set `this.props`, `this.state` and `this.context`.\n    this._performComponentUpdate(\n      nextParentElement,\n      nextProps,\n      nextState,\n      nextContext,\n      transaction,\n      nextUnmaskedContext,\n    );\n  } else {\n    // If it's determined that a component should not update, we still want\n    // to set props and state but we shortcut the rest of the update.\n    this._currentElement = nextParentElement;\n    this._context = nextUnmaskedContext;\n    inst.props = nextProps;\n    inst.state = nextState;\n    inst.context = nextContext;\n  }\n\n  if (callbacks) {\n    for (var j = 0; j < callbacks.length; j++) {\n      transaction\n        .getReactMountReady()\n        .enqueue(callbacks[j], this.getPublicInstance());\n    }\n  }\n}\n```\n\n然后注意到传入的参数是当前的 element 和 context，因此这里只是做 state 的更新。\nthis._processPendingState 这个函数会用来计算 nextState：\n\n```javascript\n _processPendingState: function(props, context) {\n    var inst = this._instance;\n    var queue = this._pendingStateQueue;\n    var replace = this._pendingReplaceState;\n    this._pendingReplaceState = false;\n    this._pendingStateQueue = null;\n\n    if (!queue) {\n      return inst.state;\n    }\n\n    if (replace && queue.length === 1) {\n      return queue[0];\n    }\n\n    var nextState = replace ? queue[0] : inst.state;\n    var dontMutate = true;\n    for (var i = replace ? 1 : 0; i < queue.length; i++) {\n      var partial = queue[i];\n      let partialState = typeof partial === 'function'\n        ? partial.call(inst, nextState, props, context)\n        : partial;\n      if (partialState) {\n        if (dontMutate) {\n          dontMutate = false;\n          nextState = Object.assign({}, nextState, partialState);\n        } else {\n          Object.assign(nextState, partialState);\n        }\n      }\n    }\n\n    return nextState;\n  },\n```\n\n这个函数有趣的地方在于：\n1. 会把你所有的 setState 填入的状态融合起来，也就是说很有可能只有最后一次的 State 有效果\n2. state 也可以传入一个 function\n\n有了新的 state 之后，便会进入 this._performComponentUpdate 这个函数的调用：\n\n```javascript\n_performComponentUpdate: function(\n  nextElement,\n  nextProps,\n  nextState,\n  nextContext,\n  transaction,\n  unmaskedContext,\n) {\n  var inst = this._instance;\n  //...\n  if (inst.componentWillUpdate) {\n    if (__DEV__) {\n      measureLifeCyclePerf(\n        () => inst.componentWillUpdate(nextProps, nextState, nextContext),\n        this._debugID,\n        'componentWillUpdate',\n      );\n    } else {\n      inst.componentWillUpdate(nextProps, nextState, nextContext);\n    }\n  }\n  this._currentElement = nextElement;\n  this._context = unmaskedContext;\n  inst.props = nextProps;\n  inst.state = nextState;\n  inst.context = nextContext;\n\n  if (inst.unstable_handleError) {\n    this._updateRenderedComponentWithErrorHandling(\n      transaction,\n      unmaskedContext,\n    );\n  } else {\n    this._updateRenderedComponent(transaction, unmaskedContext);\n  }\n\n  //... ComponentDidUpdate\n}\n```\n\n这个函数在 componentWillUpdate 和 componentDidUpdate 之间调用了：\n\n```javascript\nthis._updateRenderedComponent(transaction, unmaskedContext);\n```\n\n我们继续看 _updateRenderedComponent:\n```javascript\n/**\n  * Call the component's `render` method and update the DOM accordingly.\n  *\n  * @param {ReactReconcileTransaction} transaction\n  * @internal\n  */\n_updateRenderedComponent: function(transaction, context) {\n  var nextRenderedElement = this._renderValidatedComponent();\n  this._updateRenderedComponentWithNextElement(\n    transaction,\n    context,\n    nextRenderedElement,\n    false /* safely */,\n  );\n},\n```\n\n this._renderValidatedComponent 里面表明要看 _updateRenderedComponentWithoutOwnerOrContext：\n\n```javascript\n/**\n  * @protected\n  */\n_renderValidatedComponentWithoutOwnerOrContext: function() {\n  var inst = this._instance;\n  var renderedElement;\n\n  if (__DEV__) {\n    renderedElement = measureLifeCyclePerf(\n      () => inst.render(),\n      this._debugID,\n      'render',\n    );\n  } else {\n    renderedElement = inst.render();\n  }\n\n  if (__DEV__) {\n    // We allow auto-mocks to proceed as if they're returning null.\n    if (renderedElement === undefined && inst.render._isMockFunction) {\n      // This is probably bad practice. Consider warning here and\n      // deprecating this convenience.\n      renderedElement = null;\n    }\n  }\n\n  return renderedElement;\n}\n```\n\n可以看出来这个会调用 render 方法，调用了 render 方法后就会返回 一个 新的 element。\n\n再回到 _updateRenderedComponent:\n\n```javascript\n/**\n  * Call the component's `render` method and update the DOM accordingly.\n  *\n  * @param {ReactReconcileTransaction} transaction\n  * @internal\n  */\n_updateRenderedComponent: function(transaction, context) {\n  var nextRenderedElement = this._renderValidatedComponent();\n  this._updateRenderedComponentWithNextElement(\n    transaction,\n    context,\n    nextRenderedElement,\n    false /* safely */,\n  );\n},\n```\n\n拿到了 render 出来的 element 就会调用 _updateRenderedComponentWithNextElement:\n\n```javascript\n/**\n  * Call the component's `render` method and update the DOM accordingly.\n  *\n  * @param {ReactReconcileTransaction} transaction\n  * @internal\n  */\n_updateRenderedComponentWithNextElement: function(\n  transaction,\n  context,\n  nextRenderedElement,\n  safely,\n) {\n  var prevComponentInstance = this._renderedComponent;\n  var prevRenderedElement = prevComponentInstance._currentElement;\n\n  //...\n\n  if (shouldUpdateReactComponent(prevRenderedElement, nextRenderedElement)) {\n    ReactReconciler.receiveComponent(\n      prevComponentInstance,\n      nextRenderedElement,\n      transaction,\n      this._processChildContext(context),\n    );\n  }\n  //...\n```\n\n到这里会发现 首先调用 shouldUpdateReactComponent，注意这个和生命周期里面的 shouldComponentUpdate 不同。\n如果返回 true，那么直接调用 ReactReconciler 的 receiveComponent 来进行更新。\n\n那么我们就先看一下 shoudlUpdateReactComponent:\n\n```javascript\n/**\n* Given a `prevElement` and `nextElement`, determines if the existing\n* instance should be updated as opposed to being destroyed or replaced by a new\n* instance. Both arguments are elements. This ensures that this logic can\n* operate on stateless trees without any backing instance.\n*\n* @param {?object} prevElement\n* @param {?object} nextElement\n* @return {boolean} True if the existing instance should be updated.\n* @protected\n*/\nfunction shouldUpdateReactComponent(prevElement, nextElement) {\n  var prevEmpty = prevElement === null || prevElement === false;\n  var nextEmpty = nextElement === null || nextElement === false;\n  if (prevEmpty || nextEmpty) {\n    return prevEmpty === nextEmpty;\n  }\n\n  var prevType = typeof prevElement;\n  var nextType = typeof nextElement;\n  if (prevType === 'string' || prevType === 'number') {\n    return nextType === 'string' || nextType === 'number';\n  } else {\n    return (\n      nextType === 'object' &&\n      prevElement.type === nextElement.type &&\n      prevElement.key === nextElement.key\n    );\n  }\n}\n```\n\n注意这段代码的注释部分，该函数返回 true 意味着更新当前的 instance，而不是直接 destroy 掉，若是返回 false，那么就是说当前的 instance 会被销毁加替代。\n为 true 的条件很简单：\n1. 如果是 string 或者 number 直接返回 true\n2. 如果是 object 必须保证 type 和 key 一致\n\n让我们在回到上层代码，考虑 shoudlUpdateReactComponent 结果为 true 的时候，ReactConciler.ReceiveComponent 的调用：\n\n```javascript\n//_updateRenderedComponentWithNextElement: function\nReactReconciler.receiveComponent(\n        prevComponentInstance,\n        nextRenderedElement,\n        transaction,\n        this._processChildContext(context),\n      );\n```\n\n这里有段 context 的处理，但是考虑到目前 context 的使用并不是很频繁，我们直接跳过。\n我们再看一下 ReactReconciler.receiveComponent 的实现：\n\n```javascript\n// ReactReconciler.receiveComponent\n/**\n  * Update a component using a new element.\n  *\n  * @param {ReactComponent} internalInstance\n  * @param {ReactElement} nextElement\n  * @param {ReactReconcileTransaction} transaction\n  * @param {object} context\n  * @internal\n  */\nreceiveComponent: function(\n  internalInstance,\n  nextElement,\n  transaction,\n  context,\n) {\n  var prevElement = internalInstance._currentElement;\n\n  if (nextElement === prevElement && context === internalInstance._context) {\n    // Since elements are immutable after the owner is rendered,\n    // we can do a cheap identity compare here to determine if this is a\n    // superfluous reconcile. It's possible for state to be mutable but such\n    // change should trigger an update of the owner which would recreate\n    // the element. We explicitly check for the existence of an owner since\n    // it's possible for an element created outside a composite to be\n    // deeply mutated and reused.\n\n    // TODO: Bailing out early is just a perf optimization right?\n    // TODO: Removing the return statement should affect correctness?\n    return;\n  }\n  //...\n  internalInstance.receiveComponent(nextElement, transaction, context);\n  //...\n},\n```\n\n这段代码这里省略了一些 ref 的处理，不过以后也可以详细谈。\n这里会做一次检查，会做一次 reference 的比较，如果相同，那么自然就没有必要去更新。\n然后在使用传入的 internalInstance.receiveComponent 去做真正的更新。\n\n那么我们直接看 ReactComponent 的 receiveComponent：\n\n```javascript\nreceiveComponent: function(nextElement, transaction, nextContext) {\n  var prevElement = this._currentElement;\n  var prevContext = this._context;\n\n  this._pendingElement = null;\n\n  this.updateComponent(\n    transaction,\n    prevElement,\n    nextElement,\n    prevContext,\n    nextContext,\n  );\n}\n```\n\n然后我们发现居然又回到了 updateComponent 这个函数，因此现在有两个问题：\n1. 上次调用和这次调用那里不同？\n2. 如果不同，是一种递归的话，在哪里停止？\n第一个问题是容易回答的，肯定不同，不同之处在于 this 发生了变化，其实这个 instance 是这样来的：\n\n```javascript\n/**\n  * Call the component's `render` method and update the DOM accordingly.\n  *\n  * @param {ReactReconcileTransaction} transaction\n  * @internal\n  */\n_updateRenderedComponentWithNextElement: function(\n  transaction,\n  context,\n  nextRenderedElement,\n  safely,\n) {\n  var prevComponentInstance = this._renderedComponent;\n  //...\n```\n\n而 this._renderedComponent 的唯一 assignment 是在 _updateRenderedComponentWithNextElement 的另一条条件分支里面，也就是说当需要替换 component 的时候，会将产生这个 assignment：\n\n```javascript\n_updateRenderedComponentWithNextElement: function(\n  transaction,\n  context,\n  nextRenderedElement,\n  safely,\n) {\n  var prevComponentInstance = this._renderedComponent;\n  var prevRenderedElement = prevComponentInstance._currentElement;\n\n  //...\n\nif (shouldUpdateReactComponent(prevRenderedElement, nextRenderedElement)) {\n  ReactReconciler.receiveComponent(\n    prevComponentInstance,\n    nextRenderedElement,\n    transaction,\n    this._processChildContext(context),\n  );\n} else {\n  var oldHostNode = ReactReconciler.getHostNode(prevComponentInstance);\n  var nodeType = ReactNodeTypes.getType(nextRenderedElement);\n  this._renderedNodeType = nodeType;\n  var child = this._instantiateReactComponent(\n    nextRenderedElement,\n    nodeType !== ReactNodeTypes.EMPTY /* shouldHaveDebugID */,\n  );\n  this._renderedComponent = child;\n  //...\n```\n\n这里试想如果是第一次进入这个函数，this.\\_renderedComponent 肯定是 undefined，而 nextRenderedElement 肯定不是空的，也就说一定会进入第二个分支，然后将新的 element 实例化成新的 this.\\_renderedComponent。\n因此所有的秘密都停留在了 this._instantiateReactComponent 里面了。\n\n```javascript\n/**\n * Given a ReactNode, create an instance that will actually be mounted.\n *\n * @param {ReactNode} node\n * @param {boolean} shouldHaveDebugID\n * @return {object} A new instance of the element's constructor.\n * @protected\n */\nfunction instantiateReactComponent(node, shouldHaveDebugID) {\n  var instance;\n\n  if (node === null || node === false) {\n    instance = ReactEmptyComponent.create(instantiateReactComponent);\n  } else if (typeof node === 'object') {\n    var element = node;\n    var type = element.type;\n    if (typeof type !== 'function' && typeof type !== 'string') {\n      var info = '';\n      if (__DEV__) {\n        if (\n          type === undefined ||\n          (typeof type === 'object' &&\n            type !== null &&\n            Object.keys(type).length === 0)\n        ) {\n          info +=\n            ' You likely forgot to export your component from the file ' +\n            \"it's defined in.\";\n        }\n      }\n      info += getDeclarationErrorAddendum(element._owner);\n      invariant(\n        false,\n        'Element type is invalid: expected a string (for built-in components) ' +\n          'or a class/function (for composite components) but got: %s.%s',\n        type == null ? type : typeof type,\n        info,\n      );\n    }\n\n    // Special case string values\n    if (typeof element.type === 'string') {\n      instance = ReactHostComponent.createInternalComponent(element);\n    } else if (isInternalComponentType(element.type)) {\n      // This is temporarily available for custom components that are not string\n      // representations. I.e. ART. Once those are updated to use the string\n      // representation, we can drop this code path.\n      instance = new element.type(element);\n\n      // We renamed this. Allow the old name for compat. :(\n      if (!instance.getHostNode) {\n        instance.getHostNode = instance.getNativeNode;\n      }\n    } else {\n      instance = new ReactCompositeComponentWrapper(element);\n    }\n  } else if (typeof node === 'string' || typeof node === 'number') {\n    instance = ReactHostComponent.createInstanceForText(node);\n  } else {\n    invariant(false, 'Encountered invalid React node of type %s', typeof node);\n  }\n\n  if (__DEV__) {\n    warning(\n      typeof instance.mountComponent === 'function' &&\n        typeof instance.receiveComponent === 'function' &&\n        typeof instance.getHostNode === 'function' &&\n        typeof instance.unmountComponent === 'function',\n      'Only React Components can be mounted.',\n    );\n  }\n\n  // These two fields are used by the DOM and ART diffing algorithms\n  // respectively. Instead of using expandos on components, we should be\n  // storing the state needed by the diffing algorithms elsewhere.\n  instance._mountIndex = 0;\n  instance._mountImage = null;\n\n  if (__DEV__) {\n    instance._debugID = shouldHaveDebugID ? nextDebugID++ : 0;\n  }\n\n  // Internal instances should fully constructed at this point, so they should\n  // not get any new fields added to them at this point.\n  if (__DEV__) {\n    if (Object.preventExtensions) {\n      Object.preventExtensions(instance);\n    }\n  }\n\n  return instance;\n}\n```\n\n这段代码其实简单的看来就是处理三种不同的 ReactElement：\n1. string, number => 直接使用 ReactHostComponent.createInstanceForText 来进行实例化\n\n```javascript\n//...\n else if (typeof node === 'string' || typeof node === 'number') {\n    instance = ReactHostComponent.createInstanceForText(node);\n//...\n```\n\n2. 是 object 并且其 type 字段又是 string，那么就会使用 ReactHostComponent.createInternalComponent 来进行实例化\n\n```javascript\n//...\n if (typeof element.type === 'string') {\n      instance = ReactHostComponent.createInternalComponent(element);\n    }\n//...\n```\n\n3. 是 CompositeElement，会使用 ReactCompositeComponentWrapper 来进行实例化，其中会做一次检查，检查是否是是自定义的 type（只要定义了 mountComponent 和 receiveComponent 就行了）\n\n因此在回到我们之前的问题：\n\n```javascript\n_updateRenderedComponentWithNextElement: function(\n  transaction,\n  context,\n  nextRenderedElement,\n  safely,\n) {\n  var prevComponentInstance = this._renderedComponent;\n  var prevRenderedElement = prevComponentInstance._currentElement;\n\n  //...\n\nif (shouldUpdateReactComponent(prevRenderedElement, nextRenderedElement)) {\n  ReactReconciler.receiveComponent(\n    prevComponentInstance,\n    nextRenderedElement,\n    transaction,\n    this._processChildContext(context),\n  );\n} else {\n  var oldHostNode = ReactReconciler.getHostNode(prevComponentInstance);\n  var nodeType = ReactNodeTypes.getType(nextRenderedElement);\n  this._renderedNodeType = nodeType;\n  var child = this._instantiateReactComponent(\n    nextRenderedElement,\n    nodeType !== ReactNodeTypes.EMPTY /* shouldHaveDebugID */,\n  );\n  this._renderedComponent = child;\n  //...\n```\n\n这个 child 实际上就是被实例化出来的一个新的 Component（注意为什么是 child，是因为 nextRenderedElement 是用当前 Component 的 render 函数形成的），所以 第一个问题解决了：\n>1. 上次调用和这次调用那里不同？\n>2. 如果不同，是一种递归的话，在哪里停止？\n\n那么第二个问题是怎么解决的呢？\n直观上看这个递归的结束很简单，就是最后没有了 child，所以这里就不深究了。\n\n```javascript\n//...\nelse if (isInternalComponentType(element.type)) {\n      // This is temporarily available for custom components that are not string\n      // representations. I.e. ART. Once those are updated to use the string\n      // representation, we can drop this code path.\n      instance = new element.type(element);\n\n      // We renamed this. Allow the old name for compat. :(\n      if (!instance.getHostNode) {\n        instance.getHostNode = instance.getNativeNode;\n      }\n    } else {\n      instance = new ReactCompositeComponentWrapper(element);\n    }\n//...\n```\n   \n再回到之前的 _updateRenderedComponentWithNextElement，把接下来的处理看掉：\n\n  ```javascript\n  // _updateRenderedComponentWithNextElement: function()\n  if (shouldUpdateReactComponent(prevRenderedElement, nextRenderedElement)) {\n    ReactReconciler.receiveComponent(\n      prevComponentInstance,\n      nextRenderedElement,\n      transaction,\n      this._processChildContext(context),\n    );\n  } \n  else {\n    var oldHostNode = ReactReconciler.getHostNode(prevComponentInstance);\n    var nodeType = ReactNodeTypes.getType(nextRenderedElement);\n    this._renderedNodeType = nodeType;\n    var child = this._instantiateReactComponent(\n      nextRenderedElement,\n      nodeType !== ReactNodeTypes.EMPTY /* shouldHaveDebugID */,\n    );\n    this._renderedComponent = child;\n\n    var nextMarkup = ReactReconciler.mountComponent(\n      child,\n      transaction,\n      this._hostParent,\n      this._hostContainerInfo,\n      this._processChildContext(context),\n      debugID,\n    );\n\n    ReactReconciler.unmountComponent(\n      prevComponentInstance,\n      safely,\n      false /* skipLifecycle */,\n    );\n\n    if (__DEV__) {\n      if (debugID !== 0) {\n        var childDebugIDs = child._debugID !== 0 ? [child._debugID] : [];\n        ReactInstrumentation.debugTool.onSetChildren(debugID, childDebugIDs);\n      }\n    }\n\n    this._replaceNodeWithMarkup(\n      oldHostNode,\n      nextMarkup,\n      prevComponentInstance,\n    );\n  }\n},\n```\n\n这块总的来说就是在 shouldUpdateReactComponent 返回 false 的时候：\n1. 保存老的 hostNode\n2. instantiate 新的 ReactComponent\n3. mount 这个新的 instance，拿到 markup\n4. unmount 旧的 instance\n5. 重新渲染 hostNode 下的 dom\n\n\n## ReactDOMComponent\n其实 ReactCompositeComponent 不会做具体的更新的。\n在 performUpdateIfNecessary 中的第一个条件表明，如果存在 pendingElement 那么会直接调用 ReactReconciler.receiveComponent。\n\n```javascript\n/**\n  * If any of `_pendingElement`, `_pendingStateQueue`, or `_pendingForceUpdate`\n  * is set, update the component.\n  *\n  * @param {ReactReconcileTransaction} transaction\n  * @internal\n  */\nperformUpdateIfNecessary: function(transaction) {\n  if (this._pendingElement != null) {\n    ReactReconciler.receiveComponent(\n      this,\n      this._pendingElement,\n      transaction,\n      this._context,\n    );\n  }\n```\n\n而 ReactReconciler.receiveComponent 中的具体做法是：\n\n```javascript\n// ReactReconciler.receiveComponent\n/**\n  * Update a component using a new element.\n  *\n  * @param {ReactComponent} internalInstance\n  * @param {ReactElement} nextElement\n  * @param {ReactReconcileTransaction} transaction\n  * @param {object} context\n  * @internal\n  */\nreceiveComponent: function(\n  internalInstance,\n  nextElement,\n  transaction,\n  context,\n) {\n  var prevElement = internalInstance._currentElement;\n\n  if (nextElement === prevElement && context === internalInstance._context) {\n    // Since elements are immutable after the owner is rendered,\n    // we can do a cheap identity compare here to determine if this is a\n    // superfluous reconcile. It's possible for state to be mutable but such\n    // change should trigger an update of the owner which would recreate\n    // the element. We explicitly check for the existence of an owner since\n    // it's possible for an element created outside a composite to be\n    // deeply mutated and reused.\n\n    // TODO: Bailing out early is just a perf optimization right?\n    // TODO: Removing the return statement should affect correctness?\n    return;\n  }\n  //...\n  internalInstance.receiveComponent(nextElement, transaction, context);\n  //...\n},\n```\n\n又把 receiveComponent delegate 给了这个 Component 的 instance，我们再看 ReactCompositeComponent.receiveComponent：\n\n```javascript\n  receiveComponent: function(nextElement, transaction, nextContext) {\n    var prevElement = this._currentElement;\n    var prevContext = this._context;\n\n    this._pendingElement = null;\n\n    this.updateComponent(\n      transaction,\n      prevElement,\n      nextElement,\n      prevContext,\n      nextContext,\n    );\n  },\n```\n\n再看 updateComponent：\n\n```javascript\n/**\n   * Perform an update to a mounted component. The componentWillReceiveProps and\n   * shouldComponentUpdate methods are called, then (assuming the update isn't\n   * skipped) the remaining update lifecycle methods are called and the DOM\n   * representation is updated.\n   *\n   * By default, this implements React's rendering and reconciliation algorithm.\n   * Sophisticated clients may wish to override this.\n   *\n   * @param {ReactReconcileTransaction} transaction\n   * @param {ReactElement} prevParentElement\n   * @param {ReactElement} nextParentElement\n   * @internal\n   * @overridable\n   */\n  updateComponent: function(\n    transaction,\n    prevParentElement,\n    nextParentElement,\n    prevUnmaskedContext,\n    nextUnmaskedContext,\n  ) {\n    if (shouldUpdate) {\n      this._pendingForceUpdate = false;\n      // Will set `this.props`, `this.state` and `this.context`.\n      this._performComponentUpdate(\n        nextParentElement,\n        nextProps,\n        nextState,\n        nextContext,\n        transaction,\n        nextUnmaskedContext,\n      );\n    } else {\n    //...\n```\n\n再看 _performComponentUpdate:\n\n```javascript\n/**\n   * Merges new props and state, notifies delegate methods of update and\n   * performs update.\n   *\n   * @param {ReactElement} nextElement Next element\n   * @param {object} nextProps Next public object to set as properties.\n   * @param {?object} nextState Next object to set as state.\n   * @param {?object} nextContext Next public object to set as context.\n   * @param {ReactReconcileTransaction} transaction\n   * @param {?object} unmaskedContext\n   * @private\n   */\n  _performComponentUpdate: function(\n    nextElement,\n    nextProps,\n    nextState,\n    nextContext,\n    transaction,\n    unmaskedContext,\n  ) {\n    var inst = this._instance;\n\n    var hasComponentDidUpdate = !!inst.componentDidUpdate;\n    var prevProps;\n    var prevState;\n    if (hasComponentDidUpdate) {\n      prevProps = inst.props;\n      prevState = inst.state;\n    }\n    //...\n    this._currentElement = nextElement;\n    this._context = unmaskedContext;\n    inst.props = nextProps;\n    inst.state = nextState;\n    inst.context = nextContext;\n\n    if (inst.unstable_handleError) {\n      this._updateRenderedComponentWithErrorHandling(\n        transaction,\n        unmaskedContext,\n      );\n    } else {\n      this._updateRenderedComponent(transaction, unmaskedContext);\n    }\n    //...\n```\n\n因此我们又要看 _updateRenderedComponent:\n\n```javascript\n  /**\n   * Call the component's `render` method and update the DOM accordingly.\n   *\n   * @param {ReactReconcileTransaction} transaction\n   * @internal\n   */\n  _updateRenderedComponent: function(transaction, context) {\n    var nextRenderedElement = this._renderValidatedComponent();\n    this._updateRenderedComponentWithNextElement(\n      transaction,\n      context,\n      nextRenderedElement,\n      false /* safely */,\n    );\n  },\n```\n\n进入 _updateRenderedComponentWithNextElement:\n\n```javascript\n/**\n   * Call the component's `render` method and update the DOM accordingly.\n   *\n   * @param {ReactReconcileTransaction} transaction\n   * @internal\n   */\n  _updateRenderedComponentWithNextElement: function(\n    transaction,\n    context,\n    nextRenderedElement,\n    safely,\n  ) {\n    var prevComponentInstance = this._renderedComponent;\n    var prevRenderedElement = prevComponentInstance._currentElement;\n\n    var debugID = 0;\n    if (__DEV__) {\n      debugID = this._debugID;\n    }\n\n    if (shouldUpdateReactComponent(prevRenderedElement, nextRenderedElement)) {\n      ReactReconciler.receiveComponent(\n        prevComponentInstance,\n        nextRenderedElement,\n        transaction,\n        this._processChildContext(context),\n      );\n    } else {\n      var oldHostNode = ReactReconciler.getHostNode(prevComponentInstance);\n      var nodeType = ReactNodeTypes.getType(nextRenderedElement);\n      this._renderedNodeType = nodeType;\n      var child = this._instantiateReactComponent(\n        nextRenderedElement,\n        nodeType !== ReactNodeTypes.EMPTY /* shouldHaveDebugID */,\n      );\n      this._renderedComponent = child;\n\n      var nextMarkup = ReactReconciler.mountComponent(\n        child,\n        transaction,\n        this._hostParent,\n        this._hostContainerInfo,\n        this._processChildContext(context),\n        debugID,\n      );\n\n      ReactReconciler.unmountComponent(\n        prevComponentInstance,\n        safely,\n        false /* skipLifecycle */,\n      );\n\n      if (__DEV__) {\n        if (debugID !== 0) {\n          var childDebugIDs = child._debugID !== 0 ? [child._debugID] : [];\n          ReactInstrumentation.debugTool.onSetChildren(debugID, childDebugIDs);\n        }\n      }\n\n      this._replaceNodeWithMarkup(\n        oldHostNode,\n        nextMarkup,\n        prevComponentInstance,\n      );\n    }\n  },\n```\n\n这里注意，根据我们之前的说明：\n\n```javascript\n/**\n   * Call the component's `render` method and update the DOM accordingly.\n   *\n   * @param {ReactReconcileTransaction} transaction\n   * @internal\n   */\n  _updateRenderedComponentWithNextElement: function(\n    transaction,\n    context,\n    nextRenderedElement,\n    safely,\n  ) {\n    var prevComponentInstance = this._renderedComponent;\n    var prevRenderedElement = prevComponentInstance._currentElement;\n\n    var debugID = 0;\n    if (__DEV__) {\n      debugID = this._debugID;\n    }\n\n    if (shouldUpdateReactComponent(prevRenderedElement, nextRenderedElement)) {\n      ReactReconciler.receiveComponent(\n        prevComponentInstance,\n        nextRenderedElement,\n        transaction,\n        this._processChildContext(context),\n      );\n    } else {\n```\n\n这里的 prevComponentInstance 实际上是 this（这个也是一个 ComponentInstance）的 render 函数返回的 ReactElement 的 Component Instance，然后 nextRenderedElement 是当前的被更新了的 ReactElement，如果我们假设这个 prevComponentInstance 是一个 ReactDOMComponent 的话，那么一切就会进入 ReactDOMComponent 的 receiveComponent，并且接受的参数就是 nextRenderedElement，我们看一下：\n\n```javascript\n/**\n   * Receives a next element and updates the component.\n   *\n   * @internal\n   * @param {ReactElement} nextElement\n   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction\n   * @param {object} context\n   */\n  receiveComponent: function(nextElement, transaction, context) {\n    var prevElement = this._currentElement;\n    this._currentElement = nextElement;\n    this.updateComponent(transaction, prevElement, nextElement, context);\n  },\n```\n\n在看 updateComponent：\n\n```javascript\n  /**\n   * Updates a DOM component after it has already been allocated and\n   * attached to the DOM. Reconciles the root DOM node, then recurses.\n   *\n   * @param {ReactReconcileTransaction} transaction\n   * @param {ReactElement} prevElement\n   * @param {ReactElement} nextElement\n   * @internal\n   * @overridable\n   */\n  updateComponent: function(transaction, prevElement, nextElement, context) {\n    var lastProps = prevElement.props;\n    var nextProps = this._currentElement.props;\n\n    switch (this._tag) {\n      case 'input':\n        lastProps = ReactDOMInput.getHostProps(this, lastProps);\n        nextProps = ReactDOMInput.getHostProps(this, nextProps);\n        break;\n      case 'option':\n        lastProps = ReactDOMOption.getHostProps(this, lastProps);\n        nextProps = ReactDOMOption.getHostProps(this, nextProps);\n        break;\n      case 'select':\n        lastProps = ReactDOMSelect.getHostProps(this, lastProps);\n        nextProps = ReactDOMSelect.getHostProps(this, nextProps);\n        break;\n      case 'textarea':\n        lastProps = ReactDOMTextarea.getHostProps(this, lastProps);\n        nextProps = ReactDOMTextarea.getHostProps(this, nextProps);\n        break;\n      default:\n        if (\n          typeof lastProps.onClick !== 'function' &&\n          typeof nextProps.onClick === 'function'\n        ) {\n          transaction\n            .getReactMountReady()\n            .enqueue(trapClickOnNonInteractiveElement, this);\n        }\n        break;\n    }\n\n    assertValidProps(this, nextProps);\n    var isCustomComponentTag = isCustomComponent(this._tag, nextProps);\n    this._updateDOMProperties(\n      lastProps,\n      nextProps,\n      transaction,\n      isCustomComponentTag,\n    );\n    this._updateDOMChildren(lastProps, nextProps, transaction, context);\n\n    switch (this._tag) {\n      case 'input':\n        // Update the wrapper around inputs *after* updating props. This has to\n        // happen after `_updateDOMProperties`. Otherwise HTML5 input validations\n        // raise warnings and prevent the new value from being assigned.\n        ReactDOMInput.updateWrapper(this);\n        break;\n      case 'textarea':\n        ReactDOMTextarea.updateWrapper(this);\n        break;\n      case 'select':\n        // <select> value update needs to occur after <option> children\n        // reconciliation\n        transaction.getReactMountReady().enqueue(postUpdateSelectWrapper, this);\n        break;\n    }\n  },\n```\n\n这段代码真的比较简单，唯一值得看的是 this._updateDOMChildren 这个函数:\n```javascript\n/**\n   * Reconciles the children with the various properties that affect the\n   * children content.\n   *\n   * @param {object} lastProps\n   * @param {object} nextProps\n   * @param {ReactReconcileTransaction} transaction\n   * @param {object} context\n   */\n  _updateDOMChildren: function(lastProps, nextProps, transaction, context) {\n    var lastContent = CONTENT_TYPES[typeof lastProps.children]\n      ? lastProps.children\n      : null;\n    var nextContent = CONTENT_TYPES[typeof nextProps.children]\n      ? nextProps.children\n      : null;\n\n    var lastHtml =\n      lastProps.dangerouslySetInnerHTML &&\n      lastProps.dangerouslySetInnerHTML.__html;\n    var nextHtml =\n      nextProps.dangerouslySetInnerHTML &&\n      nextProps.dangerouslySetInnerHTML.__html;\n\n    // Note the use of `!=` which checks for null or undefined.\n    var lastChildren = lastContent != null ? null : lastProps.children;\n    var nextChildren = nextContent != null ? null : nextProps.children;\n\n    // If we're switching from children to content/html or vice versa, remove\n    // the old content\n    var lastHasContentOrHtml = lastContent != null || lastHtml != null;\n    var nextHasContentOrHtml = nextContent != null || nextHtml != null;\n    if (lastChildren != null && nextChildren == null) {\n      this.updateChildren(null, transaction, context);\n    } else if (lastHasContentOrHtml && !nextHasContentOrHtml) {\n      this.updateTextContent('');\n      if (__DEV__) {\n        ReactInstrumentation.debugTool.onSetChildren(this._debugID, []);\n      }\n    }\n\n    if (nextContent != null) {\n      if (lastContent !== nextContent) {\n        this.updateTextContent('' + nextContent);\n        if (__DEV__) {\n          setAndValidateContentChildDev.call(this, nextContent);\n        }\n      }\n    } else if (nextHtml != null) {\n      if (lastHtml !== nextHtml) {\n        this.updateMarkup('' + nextHtml);\n      }\n      if (__DEV__) {\n        ReactInstrumentation.debugTool.onSetChildren(this._debugID, []);\n      }\n    } else if (nextChildren != null) {\n      if (__DEV__) {\n        setAndValidateContentChildDev.call(this, null);\n      }\n\n      this.updateChildren(nextChildren, transaction, context);\n    }\n  },\n```\n\n这段代码告诉我得看 updateChildren 这个函数，而这个函数是来自于其它类，最终在 ReactMultiChild 中找到：\n```javascript\n/**\n   * @param {?object} nextNestedChildrenElements Nested child element maps.\n   * @param {ReactReconcileTransaction} transaction\n   * @final\n   * @protected\n   */\n  _updateChildren: function(nextNestedChildrenElements, transaction, context) {\n    var prevChildren = this._renderedChildren;\n    var removedNodes = {};\n    var mountImages = [];\n    var nextChildren = this._reconcilerUpdateChildren(\n      prevChildren,\n      nextNestedChildrenElements,\n      mountImages,\n      removedNodes,\n      transaction,\n      context,\n    );\n    if (!nextChildren && !prevChildren) {\n      return;\n    }\n    var updates = null;\n    var name;\n    // `nextIndex` will increment for each child in `nextChildren`, but\n    // `lastIndex` will be the last index visited in `prevChildren`.\n    var nextIndex = 0;\n    var lastIndex = 0;\n    // `nextMountIndex` will increment for each newly mounted child.\n    var nextMountIndex = 0;\n    var lastPlacedNode = null;\n    for (name in nextChildren) {\n      if (!nextChildren.hasOwnProperty(name)) {\n        continue;\n      }\n      var prevChild = prevChildren && prevChildren[name];\n      var nextChild = nextChildren[name];\n      if (prevChild === nextChild) {\n        updates = enqueue(\n          updates,\n          this.moveChild(prevChild, lastPlacedNode, nextIndex, lastIndex),\n        );\n        lastIndex = Math.max(prevChild._mountIndex, lastIndex);\n        prevChild._mountIndex = nextIndex;\n      } else {\n        if (prevChild) {\n          // Update `lastIndex` before `_mountIndex` gets unset by unmounting.\n          lastIndex = Math.max(prevChild._mountIndex, lastIndex);\n          // The `removedNodes` loop below will actually remove the child.\n        }\n        // The child must be instantiated before it's mounted.\n        updates = enqueue(\n          updates,\n          this._mountChildAtIndex(\n            nextChild,\n            mountImages[nextMountIndex],\n            lastPlacedNode,\n            nextIndex,\n            transaction,\n            context,\n          ),\n        );\n        nextMountIndex++;\n      }\n      nextIndex++;\n      lastPlacedNode = ReactReconciler.getHostNode(nextChild);\n    }\n    // Remove children that are no longer present.\n    for (name in removedNodes) {\n      if (removedNodes.hasOwnProperty(name)) {\n        updates = enqueue(\n          updates,\n          this._unmountChild(prevChildren[name], removedNodes[name]),\n        );\n      }\n    }\n    if (updates) {\n      processQueue(this, updates);\n    }\n    this._renderedChildren = nextChildren;\n\n    if (__DEV__) {\n      setChildrenForInstrumentation.call(this, nextChildren);\n    }\n  },\n```\n\n还得看 this._reconcilerUpdateChildren 这个函数：\n\n```javascript\n_reconcilerUpdateChildren: function(\n    prevChildren,\n    nextNestedChildrenElements,\n    mountImages,\n    removedNodes,\n    transaction,\n    context,\n  ) {\n    var nextChildren;\n    var selfDebugID = 0;\n    if (__DEV__) {\n      selfDebugID = getDebugID(this);\n      if (this._currentElement) {\n        try {\n          ReactCurrentOwner.current = this._currentElement._owner;\n          nextChildren = flattenStackChildren(\n            nextNestedChildrenElements,\n            selfDebugID,\n          );\n        } finally {\n          ReactCurrentOwner.current = null;\n        }\n        ReactChildReconciler.updateChildren(\n          prevChildren,\n          nextChildren,\n          mountImages,\n          removedNodes,\n          transaction,\n          this,\n          this._hostContainerInfo,\n          context,\n          selfDebugID,\n        );\n        return nextChildren;\n      }\n    }\n    nextChildren = flattenStackChildren(\n      nextNestedChildrenElements,\n      selfDebugID,\n    );\n    ReactChildReconciler.updateChildren(\n      prevChildren,\n      nextChildren,\n      mountImages,\n      removedNodes,\n      transaction,\n      this,\n      this._hostContainerInfo,\n      context,\n      selfDebugID,\n    );\n    return nextChildren;\n  },\n```\n\n又得看 ReactChildReconciler.updateChildren 这个函数：\n```javascript\n/**\n   * Updates the rendered children and returns a new set of children.\n   *\n   * @param {?object} prevChildren Previously initialized set of children.\n   * @param {?object} nextChildren Flat child element maps.\n   * @param {ReactReconcileTransaction} transaction\n   * @param {object} context\n   * @return {?object} A new set of child instances.\n   * @internal\n   */\n  updateChildren: function(\n    prevChildren,\n    nextChildren,\n    mountImages,\n    removedNodes,\n    transaction,\n    hostParent,\n    hostContainerInfo,\n    context,\n    selfDebugID, // 0 in production and for roots\n  ) {\n    // We currently don't have a way to track moves here but if we use iterators\n    // instead of for..in we can zip the iterators and check if an item has\n    // moved.\n    // TODO: If nothing has changed, return the prevChildren object so that we\n    // can quickly bailout if nothing has changed.\n    if (!nextChildren && !prevChildren) {\n      return;\n    }\n    var name;\n    var prevChild;\n    for (name in nextChildren) {\n      if (!nextChildren.hasOwnProperty(name)) {\n        continue;\n      }\n      prevChild = prevChildren && prevChildren[name];\n      var prevElement = prevChild && prevChild._currentElement;\n      var nextElement = nextChildren[name];\n      if (\n        prevChild != null &&\n        shouldUpdateReactComponent(prevElement, nextElement)\n      ) {\n        ReactReconciler.receiveComponent(\n          prevChild,\n          nextElement,\n          transaction,\n          context,\n        );\n        nextChildren[name] = prevChild;\n      } else {\n        // The child must be instantiated before it's mounted.\n        var nextChildInstance = instantiateReactComponent(nextElement, true);\n        nextChildren[name] = nextChildInstance;\n        // Creating mount image now ensures refs are resolved in right order\n        // (see https://github.com/facebook/react/pull/7101 for explanation).\n        var nextChildMountImage = ReactReconciler.mountComponent(\n          nextChildInstance,\n          transaction,\n          hostParent,\n          hostContainerInfo,\n          context,\n          selfDebugID,\n        );\n        mountImages.push(nextChildMountImage);\n        if (prevChild) {\n          removedNodes[name] = ReactReconciler.getHostNode(prevChild);\n          ReactReconciler.unmountComponent(\n            prevChild,\n            false /* safely */,\n            false /* skipLifecycle */,\n          );\n        }\n      }\n    }\n    // Unmount children that are no longer present.\n    for (name in prevChildren) {\n      if (\n        prevChildren.hasOwnProperty(name) &&\n        !(nextChildren && nextChildren.hasOwnProperty(name))\n      ) {\n        prevChild = prevChildren[name];\n        removedNodes[name] = ReactReconciler.getHostNode(prevChild);\n        ReactReconciler.unmountComponent(\n          prevChild,\n          false /* safely */,\n          false /* skipLifecycle */,\n        );\n      }\n    }\n  },\n```\n\n到这里基本上结束了，这个函数会遍历所有 children，然后对其调用 ReactReconciler.receiveComponent（如果只是更新的话）或者 直接走 mount 新节点／unmount 旧节点的流程。\n\n## 更新触发起点\n现在有一个重要的问题其实还没解决，那就是哪里是更新触发的起点，即究竟是通过哪一个函数触发了更新（也就是说调用了 performUpdateIfnecessary 这个函数）:\n\n```javascript\nfunction runBatchedUpdates(transaction) {\n  var len = transaction.dirtyComponentsLength;\n  invariant(\n    len === dirtyComponents.length,\n    \"Expected flush transaction's stored dirty-components length (%s) to \" +\n      'match dirty-components array length (%s).',\n    len,\n    dirtyComponents.length,\n  );\n\n  // Since reconciling a component higher in the owner hierarchy usually (not\n  // always -- see shouldComponentUpdate()) will reconcile children, reconcile\n  // them before their children by sorting the array.\n  dirtyComponents.sort(mountOrderComparator);\n\n  // Any updates enqueued while reconciling must be performed after this entire\n  // batch. Otherwise, if dirtyComponents is [A, B] where A has children B and\n  // C, B could update twice in a single batch if C's render enqueues an update\n  // to B (since B would have already updated, we should skip it, and the only\n  // way we can know to do so is by checking the batch counter).\n  updateBatchNumber++;\n\n  for (var i = 0; i < len; i++) {\n    // If a component is unmounted before pending changes apply, it will still\n    // be here, but we assume that it has cleared its _pendingCallbacks and\n    // that performUpdateIfNecessary is a noop.\n    var component = dirtyComponents[i];\n\n    ReactReconciler.performUpdateIfNecessary(\n      component,\n      transaction.reconcileTransaction,\n      updateBatchNumber,\n    );\n  }\n}\n```\n\n然后再向上追溯:\n```javascript\nvar flushBatchedUpdates = function() {\n  // ReactUpdatesFlushTransaction's wrappers will clear the dirtyComponents\n  // array and perform any updates enqueued by mount-ready handlers (i.e.,\n  // componentDidUpdate) but we need to check here too in order to catch\n  // updates enqueued by setState callbacks.\n  while (dirtyComponents.length) {\n    var transaction = ReactUpdatesFlushTransaction.getPooled();\n    transaction.perform(runBatchedUpdates, null, transaction);\n    ReactUpdatesFlushTransaction.release(transaction);\n  }\n```\n\n发现在 ReactDefaultBatchingStrategy 这个文件中:\n\n```javascript\nvar RESET_BATCHED_UPDATES = {\n  initialize: emptyFunction,\n  close: function() {\n    ReactDefaultBatchingStrategy.isBatchingUpdates = false;\n  },\n};\n\nvar FLUSH_BATCHED_UPDATES = {\n  initialize: emptyFunction,\n  close: ReactUpdates.flushBatchedUpdates.bind(ReactUpdates),\n};\n\nvar TRANSACTION_WRAPPERS = [FLUSH_BATCHED_UPDATES, RESET_BATCHED_UPDATES];\n\nfunction ReactDefaultBatchingStrategyTransaction() {\n  this.reinitializeTransaction();\n}\n\nObject.assign(ReactDefaultBatchingStrategyTransaction.prototype, Transaction, {\n  getTransactionWrappers: function() {\n    return TRANSACTION_WRAPPERS;\n  },\n});\n\nvar transaction = new ReactDefaultBatchingStrategyTransaction();\n\nvar ReactDefaultBatchingStrategy = {\n  isBatchingUpdates: false,\n\n  /**\n   * Call the provided function in a context within which calls to `setState`\n   * and friends are batched such that components aren't updated unnecessarily.\n   */\n  batchedUpdates: function(callback, a, b, c, d, e) {\n    var alreadyBatchingUpdates = ReactDefaultBatchingStrategy.isBatchingUpdates;\n\n    ReactDefaultBatchingStrategy.isBatchingUpdates = true;\n\n    // The code is written this way to avoid extra allocations\n    if (alreadyBatchingUpdates) {\n      return callback(a, b, c, d, e);\n    } else {\n      return transaction.perform(callback, null, a, b, c, d, e);\n    }\n  },\n};\n\nmodule.exports = ReactDefaultBatchingStrategy;\n```\n\nreact 很经典的一个 transaction 处理，然后再去找 ReactDefaultBatchingStrategy 的使用，由于 DOM 和 Native 的应用场景不同，这个 Strategy 是动态插入的，我们可以看 DOM 的场景：\n\n```javascript\n// ReactDOMStackInjection.js\nvar alreadyInjected = false;\n\nfunction inject() {\n  if (alreadyInjected) {\n    // TODO: This is currently true because these injections are shared between\n    // the client and the server package. They should be built independently\n    // and not share any injection state. Then this problem will be solved.\n    return;\n  }\n  alreadyInjected = true;\n\n  ReactGenericBatching.injection.injectStackBatchedUpdates(\n    ReactUpdates.batchedUpdates,\n  );\n\n  ReactHostComponent.injection.injectGenericComponentClass(ReactDOMComponent);\n\n  ReactHostComponent.injection.injectTextComponentClass(ReactDOMTextComponent);\n\n  ReactEmptyComponent.injection.injectEmptyComponentFactory(function(\n    instantiate,\n  ) {\n    return new ReactDOMEmptyComponent(instantiate);\n  });\n\n  ReactUpdates.injection.injectReconcileTransaction(ReactReconcileTransaction);\n  /*********this-line*****************/\n  ReactUpdates.injection.injectBatchingStrategy(ReactDefaultBatchingStrategy);\n  /*********this-line*****************/\n\n  ReactComponentEnvironment.injection.injectEnvironment(\n    ReactComponentBrowserEnvironment,\n  );\n\n  findDOMNode._injectStack(function(inst) {\n    inst = getHostComponentFromComposite(inst);\n    return inst ? ReactDOMComponentTree.getNodeFromInstance(inst) : null;\n  });\n}\n\nmodule.exports = {\n  inject: inject,\n};\n```\n\n然后就去看 ReactUpdates 的 injection:\n\n```javascript\nvar ReactUpdatesInjection = {\n  injectReconcileTransaction: function(ReconcileTransaction) {\n    invariant(\n      ReconcileTransaction,\n      'ReactUpdates: must provide a reconcile transaction class',\n    );\n    ReactUpdates.ReactReconcileTransaction = ReconcileTransaction;\n  },\n\n  injectBatchingStrategy: function(_batchingStrategy) {\n    invariant(\n      _batchingStrategy,\n      'ReactUpdates: must provide a batching strategy',\n    );\n    invariant(\n      typeof _batchingStrategy.batchedUpdates === 'function',\n      'ReactUpdates: must provide a batchedUpdates() function',\n    );\n    invariant(\n      typeof _batchingStrategy.isBatchingUpdates === 'boolean',\n      'ReactUpdates: must provide an isBatchingUpdates boolean attribute',\n    );\n    batchingStrategy = _batchingStrategy;\n  },\n\n  getBatchingStrategy: function() {\n    return batchingStrategy;\n  },\n};\n\n//...\nvar ReactUpdates = {\n  /**\n   * React references `ReactReconcileTransaction` using this property in order\n   * to allow dependency injection.\n   *\n   * @internal\n   */\n  ReactReconcileTransaction: null,\n\n  batchedUpdates: batchedUpdates,\n  enqueueUpdate: enqueueUpdate,\n  flushBatchedUpdates: flushBatchedUpdates,\n  injection: ReactUpdatesInjection,\n};\n\n```\n\n这个时候，需要把调用栈反过来看一下：\nReactUpdates.injection inject 了 ReactDefaultBatchingUpdates， 而 ReactDefaultBatchingUpdates 是一个 transaction，在其中一个 tansaction_wrapper 中，调用了 ReactUpdates.flushBatchedUpdates，然后在 flushBatchedUpdates 中又调用了 runBatchedUpdates 这个函数，而这个函数直接调用了 ReactReconciler 的 performUpdateIfNecessary，这个函数又把 performUpdateIfNecessary 的具体任务 delegate 到具体的 instance。\n\n那么接下来应该如何继续探究下去呢？继续往上追溯，ReactUpdatesInjection 中提供了一个接口 getBatchingStrategy，就顺着它就行了。但是没发现有用的信息。\n\n这个时候，我们在从 setState 开始看起:\n```javascript\nReactComponent.prototype.setState = function(partialState, callback) {\n  invariant(\n    typeof partialState === 'object' ||\n      typeof partialState === 'function' ||\n      partialState == null,\n    'setState(...): takes an object of state variables to update or a ' +\n      'function which returns an object of state variables.',\n  );\n  this.updater.enqueueSetState(this, partialState, callback, 'setState');\n};\n```\n\n这个是 ReactBaseClasses，老实说不是很清楚这个 class 有什么作用，基本上函数都是空的，不过如果这个 updater 用的不是默认值呢？我们可以从 enqueueSetState 这个方法入手，有这么几个类 ReactPartialRenderer 和 ReactUpdateQueue，但是 ReactPartialRenderer 是 server rendering，所以只看 ReactUpdateQueue 即可:\n```javascript\n/**\n   * Sets a subset of the state. This only exists because _pendingState is\n   * internal. This provides a merging strategy that is not available to deep\n   * properties which is confusing. TODO: Expose pendingState or don't use it\n   * during the merge.\n   *\n   * @param {ReactClass} publicInstance The instance that should rerender.\n   * @param {object} partialState Next partial state to be merged with state.\n   * @param {?function} callback Called after state is updated.\n   * @param {?string} Name of the calling function in the public API.\n   * @internal\n   */\n  enqueueSetState: function(\n    publicInstance,\n    partialState,\n    callback,\n    callerName,\n  ) {\n    if (__DEV__) {\n      ReactInstrumentation.debugTool.onSetState();\n      warning(\n        partialState != null,\n        'setState(...): You passed an undefined or null state object; ' +\n          'instead, use forceUpdate().',\n      );\n    }\n\n    var internalInstance = getInternalInstanceReadyForUpdate(publicInstance);\n\n    if (!internalInstance) {\n      return;\n    }\n\n    var queue =\n      internalInstance._pendingStateQueue ||\n      (internalInstance._pendingStateQueue = []);\n    queue.push(partialState);\n\n    callback = callback === undefined ? null : callback;\n    if (callback !== null) {\n      if (__DEV__) {\n        warnOnInvalidCallback(callback, callerName);\n      }\n      if (internalInstance._pendingCallbacks) {\n        internalInstance._pendingCallbacks.push(callback);\n      } else {\n        internalInstance._pendingCallbacks = [callback];\n      }\n    }\n\n    enqueueUpdate(internalInstance);\n  },\n```\n\n这个函数表明 partialState 会被存在 internalInstance._pendingStateQueue 中，然后会调用 enquereUpdate，这个函数实际上来自 ReactUpdates.js 中:\n\n```javascript\n/**\n * Mark a component as needing a rerender, adding an optional callback to a\n * list of functions which will be executed once the rerender occurs.\n */\nfunction enqueueUpdate(component) {\n  ensureInjected();\n\n  // Various parts of our code (such as ReactCompositeComponent's\n  // _renderValidatedComponent) assume that calls to render aren't nested;\n  // verify that that's the case. (This is called by each top-level update\n  // function, like setState, forceUpdate, etc.; creation and\n  // destruction of top-level components is guarded in ReactMount.)\n\n  if (!batchingStrategy.isBatchingUpdates) {\n    batchingStrategy.batchedUpdates(enqueueUpdate, component);\n    return;\n  }\n\n  dirtyComponents.push(component);\n  if (component._updateBatchNumber == null) {\n    component._updateBatchNumber = updateBatchNumber + 1;\n  }\n}\n```\n\n这个 batchedUpdates 其实就是上面提供的 ReactDefaultBatchingStrategy:\n\n```javascript\nvar ReactDefaultBatchingStrategy = {\n  isBatchingUpdates: false,\n\n  /**\n   * Call the provided function in a context within which calls to `setState`\n   * and friends are batched such that components aren't updated unnecessarily.\n   */\n  batchedUpdates: function(callback, a, b, c, d, e) {\n    var alreadyBatchingUpdates = ReactDefaultBatchingStrategy.isBatchingUpdates;\n\n    ReactDefaultBatchingStrategy.isBatchingUpdates = true;\n\n    // The code is written this way to avoid extra allocations\n    if (alreadyBatchingUpdates) {\n      return callback(a, b, c, d, e);\n    } else {\n      return transaction.perform(callback, null, a, b, c, d, e);\n    }\n  },\n};\n```\n\n结合两段代码来看实际上是有两种情况，一种是正在 batching，还有一种是还没开始 batching，很容易理解，但是到目前为止似乎这个 BatchingStrategy 并没有做到 batching 这个功能，暂时先不管，继续往下看，在 transaction 的 perform 完成后，肯定是要调用 其创建时定义的 wrapper，我们也即是之前提到的:\n\n```javascript\nvar RESET_BATCHED_UPDATES = {\n  initialize: emptyFunction,\n  close: function() {\n    ReactDefaultBatchingStrategy.isBatchingUpdates = false;\n  },\n};\n\nvar FLUSH_BATCHED_UPDATES = {\n  initialize: emptyFunction,\n  close: ReactUpdates.flushBatchedUpdates.bind(ReactUpdates),\n};\n```\nReactUpdates.flushBatchedUpdates 被调用了，如果再深入下去，就可以回到我们开头的部分了。\n\n目前总体看来还有一个问题，就是 setState 似乎完全不是 enqueue 的机制，但是它函数名还这么写，我们看到的是立即更新，并没有停一下再更新。\n真的是这样吗？\n看到这样一篇[文章](https://www.bennadel.com/blog/2893-setstate-state-mutation-operation-may-be-synchronous-in-reactjs.htm)，文中指只有在 onClick 的实践处理中 setState 是 equeue 机制的，在 event not managed by react 中又是同步的。\n\n后来我进行断点调试，一步一步地进行两种情况的执行顺序，然后我发现，如果是通过 props 定义的事件响应，那么当使用 setState 的时候，触发的 enqueueUpdate:\n\n```javascript\n\n/**\n * Mark a component as needing a rerender, adding an optional callback to a\n * list of functions which will be executed once the rerender occurs.\n */\nfunction enqueueUpdate(component) {\n  ensureInjected();\n\n  // Various parts of our code (such as ReactCompositeComponent's\n  // _renderValidatedComponent) assume that calls to render aren't nested;\n  // verify that that's the case. (This is called by each top-level update\n  // function, like setState, forceUpdate, etc.; creation and\n  // destruction of top-level components is guarded in ReactMount.)\n\n  if (!batchingStrategy.isBatchingUpdates) {\n    batchingStrategy.batchedUpdates(enqueueUpdate, component);\n    return;\n  }\n\n  dirtyComponents.push(component);\n  if (component._updateBatchNumber == null) {\n    component._updateBatchNumber = updateBatchNumber + 1;\n  }\n}\n```\n\n中的 batchingStrategy.isBatchingUpdates 是 true 的，也就是说 setState 本身是处于一个 update 的 transaction 中的，所以 batchingStrategy.batchedUpdates 是不会调用的，因此如果不断的 setState 就会产生 state 本身不更新，并且将传入的 partialstate 逐步 batching，最终在触发 React 的 onClick 事件中引发的外层 update transaction 的 close 函数中进行最终的 update。\n","slug":"React-源码阅读-Component-Update","published":1,"updated":"2017-07-30T07:45:51.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjbdyo321000znf8j2e7gceri","content":"<h1 id=\"ReactComponent-的更新流程\"><a href=\"#ReactComponent-的更新流程\" class=\"headerlink\" title=\"ReactComponent 的更新流程\"></a>ReactComponent 的更新流程</h1><h2 id=\"如何开始\"><a href=\"#如何开始\" class=\"headerlink\" title=\"如何开始\"></a>如何开始</h2><p>我是直接通过跑一个 react 的例子发现在 setState 操作出去的时候， performUpdateIfnecessary 开始了运行。</p>\n<p>我们就从 ReactCompositeComponent 的 performUpdateIfnecessary 看起：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/**</span></div><div class=\"line\">  * If any of `_pendingElement`, `_pendingStateQueue`, or `_pendingForceUpdate`</div><div class=\"line\">  * is set, update the component.</div><div class=\"line\">  *</div><div class=\"line\">  * @param &#123;ReactReconcileTransaction&#125; transaction</div><div class=\"line\">  * @internal</div><div class=\"line\">  */</div><div class=\"line\">performUpdateIfNecessary: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">transaction</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>._pendingElement != <span class=\"literal\">null</span>) &#123;</div><div class=\"line\">    ReactReconciler.receiveComponent(</div><div class=\"line\">      <span class=\"keyword\">this</span>,</div><div class=\"line\">      <span class=\"keyword\">this</span>._pendingElement,</div><div class=\"line\">      transaction,</div><div class=\"line\">      <span class=\"keyword\">this</span>._context,</div><div class=\"line\">    );</div><div class=\"line\">  &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>._pendingStateQueue !== <span class=\"literal\">null</span> || <span class=\"keyword\">this</span>._pendingForceUpdate) &#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>.updateComponent(</div><div class=\"line\">      transaction,</div><div class=\"line\">      <span class=\"keyword\">this</span>._currentElement,</div><div class=\"line\">      <span class=\"keyword\">this</span>._currentElement,</div><div class=\"line\">      <span class=\"keyword\">this</span>._context,</div><div class=\"line\">      <span class=\"keyword\">this</span>._context,</div><div class=\"line\">    );</div><div class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> callbacks = <span class=\"keyword\">this</span>._pendingCallbacks;</div><div class=\"line\">    <span class=\"keyword\">this</span>._pendingCallbacks = <span class=\"literal\">null</span>;</div><div class=\"line\">    <span class=\"keyword\">if</span> (callbacks) &#123;</div><div class=\"line\">      <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> j = <span class=\"number\">0</span>; j &lt; callbacks.length; j++) &#123;</div><div class=\"line\">        transaction</div><div class=\"line\">          .getReactMountReady()</div><div class=\"line\">          .enqueue(callbacks[j], <span class=\"keyword\">this</span>.getPublicInstance());</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">this</span>._updateBatchNumber = <span class=\"literal\">null</span>;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这个函数发现会有几种执行情况，如果 this._pendingElement 存在的话，会直接调用 ReactReconciler.receiveComponent 来更新，如果不存在但是 _pendingStateQueue 或者 强制更新 被 set 了，那么 updateComponent 便会被调用，最后如果上述条件都没有满足，那么只会去执行嵌入的  callback。</p>\n<p>我们先看使用 updateComponent 的情况<br>首先记住 updateComponent 参数的意义：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div></pre></td><td class=\"code\"><pre><div class=\"line\">updateComponent: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span></span></div><div class=\"line\">  transaction,</div><div class=\"line\">  prevParentElement,</div><div class=\"line\">  nextParentElement,</div><div class=\"line\">  prevUnmaskedContext,</div><div class=\"line\">  nextUnmaskedContext,</div><div class=\"line\">) &#123;</div><div class=\"line\">  <span class=\"comment\">//...</span></div><div class=\"line\">  <span class=\"keyword\">var</span> prevProps = prevParentElement.props;</div><div class=\"line\">  <span class=\"keyword\">var</span> nextProps = nextParentElement.props;</div><div class=\"line\">  <span class=\"comment\">//...</span></div><div class=\"line\">  <span class=\"keyword\">var</span> nextState = <span class=\"keyword\">this</span>._processPendingState(nextProps, nextContext);</div><div class=\"line\">  <span class=\"comment\">//...</span></div><div class=\"line\">  <span class=\"keyword\">if</span> (shouldUpdate) &#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>._pendingForceUpdate = <span class=\"literal\">false</span>;</div><div class=\"line\">    <span class=\"comment\">// Will set `this.props`, `this.state` and `this.context`.</span></div><div class=\"line\">    <span class=\"keyword\">this</span>._performComponentUpdate(</div><div class=\"line\">      nextParentElement,</div><div class=\"line\">      nextProps,</div><div class=\"line\">      nextState,</div><div class=\"line\">      nextContext,</div><div class=\"line\">      transaction,</div><div class=\"line\">      nextUnmaskedContext,</div><div class=\"line\">    );</div><div class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">    <span class=\"comment\">// If it's determined that a component should not update, we still want</span></div><div class=\"line\">    <span class=\"comment\">// to set props and state but we shortcut the rest of the update.</span></div><div class=\"line\">    <span class=\"keyword\">this</span>._currentElement = nextParentElement;</div><div class=\"line\">    <span class=\"keyword\">this</span>._context = nextUnmaskedContext;</div><div class=\"line\">    inst.props = nextProps;</div><div class=\"line\">    inst.state = nextState;</div><div class=\"line\">    inst.context = nextContext;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">if</span> (callbacks) &#123;</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> j = <span class=\"number\">0</span>; j &lt; callbacks.length; j++) &#123;</div><div class=\"line\">      transaction</div><div class=\"line\">        .getReactMountReady()</div><div class=\"line\">        .enqueue(callbacks[j], <span class=\"keyword\">this</span>.getPublicInstance());</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>然后注意到传入的参数是当前的 element 和 context，因此这里只是做 state 的更新。<br>this._processPendingState 这个函数会用来计算 nextState：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div></pre></td><td class=\"code\"><pre><div class=\"line\">_processPendingState: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">props, context</span>) </span>&#123;</div><div class=\"line\">   <span class=\"keyword\">var</span> inst = <span class=\"keyword\">this</span>._instance;</div><div class=\"line\">   <span class=\"keyword\">var</span> queue = <span class=\"keyword\">this</span>._pendingStateQueue;</div><div class=\"line\">   <span class=\"keyword\">var</span> replace = <span class=\"keyword\">this</span>._pendingReplaceState;</div><div class=\"line\">   <span class=\"keyword\">this</span>._pendingReplaceState = <span class=\"literal\">false</span>;</div><div class=\"line\">   <span class=\"keyword\">this</span>._pendingStateQueue = <span class=\"literal\">null</span>;</div><div class=\"line\"></div><div class=\"line\">   <span class=\"keyword\">if</span> (!queue) &#123;</div><div class=\"line\">     <span class=\"keyword\">return</span> inst.state;</div><div class=\"line\">   &#125;</div><div class=\"line\"></div><div class=\"line\">   <span class=\"keyword\">if</span> (replace &amp;&amp; queue.length === <span class=\"number\">1</span>) &#123;</div><div class=\"line\">     <span class=\"keyword\">return</span> queue[<span class=\"number\">0</span>];</div><div class=\"line\">   &#125;</div><div class=\"line\"></div><div class=\"line\">   <span class=\"keyword\">var</span> nextState = replace ? queue[<span class=\"number\">0</span>] : inst.state;</div><div class=\"line\">   <span class=\"keyword\">var</span> dontMutate = <span class=\"literal\">true</span>;</div><div class=\"line\">   <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = replace ? <span class=\"number\">1</span> : <span class=\"number\">0</span>; i &lt; queue.length; i++) &#123;</div><div class=\"line\">     <span class=\"keyword\">var</span> partial = queue[i];</div><div class=\"line\">     <span class=\"keyword\">let</span> partialState = <span class=\"keyword\">typeof</span> partial === <span class=\"string\">'function'</span></div><div class=\"line\">       ? partial.call(inst, nextState, props, context)</div><div class=\"line\">       : partial;</div><div class=\"line\">     <span class=\"keyword\">if</span> (partialState) &#123;</div><div class=\"line\">       <span class=\"keyword\">if</span> (dontMutate) &#123;</div><div class=\"line\">         dontMutate = <span class=\"literal\">false</span>;</div><div class=\"line\">         nextState = <span class=\"built_in\">Object</span>.assign(&#123;&#125;, nextState, partialState);</div><div class=\"line\">       &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">         <span class=\"built_in\">Object</span>.assign(nextState, partialState);</div><div class=\"line\">       &#125;</div><div class=\"line\">     &#125;</div><div class=\"line\">   &#125;</div><div class=\"line\"></div><div class=\"line\">   <span class=\"keyword\">return</span> nextState;</div><div class=\"line\"> &#125;,</div></pre></td></tr></table></figure>\n<p>这个函数有趣的地方在于：</p>\n<ol>\n<li>会把你所有的 setState 填入的状态融合起来，也就是说很有可能只有最后一次的 State 有效果</li>\n<li>state 也可以传入一个 function</li>\n</ol>\n<p>有了新的 state 之后，便会进入 this._performComponentUpdate 这个函数的调用：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div></pre></td><td class=\"code\"><pre><div class=\"line\">_performComponentUpdate: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span></span></div><div class=\"line\">  nextElement,</div><div class=\"line\">  nextProps,</div><div class=\"line\">  nextState,</div><div class=\"line\">  nextContext,</div><div class=\"line\">  transaction,</div><div class=\"line\">  unmaskedContext,</div><div class=\"line\">) &#123;</div><div class=\"line\">  <span class=\"keyword\">var</span> inst = <span class=\"keyword\">this</span>._instance;</div><div class=\"line\">  <span class=\"comment\">//...</span></div><div class=\"line\">  <span class=\"keyword\">if</span> (inst.componentWillUpdate) &#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (__DEV__) &#123;</div><div class=\"line\">      measureLifeCyclePerf(</div><div class=\"line\">        <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> inst.componentWillUpdate(nextProps, nextState, nextContext),</div><div class=\"line\">        <span class=\"keyword\">this</span>._debugID,</div><div class=\"line\">        <span class=\"string\">'componentWillUpdate'</span>,</div><div class=\"line\">      );</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">      inst.componentWillUpdate(nextProps, nextState, nextContext);</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">  <span class=\"keyword\">this</span>._currentElement = nextElement;</div><div class=\"line\">  <span class=\"keyword\">this</span>._context = unmaskedContext;</div><div class=\"line\">  inst.props = nextProps;</div><div class=\"line\">  inst.state = nextState;</div><div class=\"line\">  inst.context = nextContext;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">if</span> (inst.unstable_handleError) &#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>._updateRenderedComponentWithErrorHandling(</div><div class=\"line\">      transaction,</div><div class=\"line\">      unmaskedContext,</div><div class=\"line\">    );</div><div class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>._updateRenderedComponent(transaction, unmaskedContext);</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">//... ComponentDidUpdate</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这个函数在 componentWillUpdate 和 componentDidUpdate 之间调用了：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">this</span>._updateRenderedComponent(transaction, unmaskedContext);</div></pre></td></tr></table></figure>\n<p>我们继续看 _updateRenderedComponent:<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/**</span></div><div class=\"line\">  * Call the component's `render` method and update the DOM accordingly.</div><div class=\"line\">  *</div><div class=\"line\">  * @param &#123;ReactReconcileTransaction&#125; transaction</div><div class=\"line\">  * @internal</div><div class=\"line\">  */</div><div class=\"line\">_updateRenderedComponent: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">transaction, context</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">var</span> nextRenderedElement = <span class=\"keyword\">this</span>._renderValidatedComponent();</div><div class=\"line\">  <span class=\"keyword\">this</span>._updateRenderedComponentWithNextElement(</div><div class=\"line\">    transaction,</div><div class=\"line\">    context,</div><div class=\"line\">    nextRenderedElement,</div><div class=\"line\">    <span class=\"literal\">false</span> <span class=\"comment\">/* safely */</span>,</div><div class=\"line\">  );</div><div class=\"line\">&#125;,</div></pre></td></tr></table></figure></p>\n<p> this._renderValidatedComponent 里面表明要看 _updateRenderedComponentWithoutOwnerOrContext：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/**</span></div><div class=\"line\">  * @protected</div><div class=\"line\">  */</div><div class=\"line\">_renderValidatedComponentWithoutOwnerOrContext: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">var</span> inst = <span class=\"keyword\">this</span>._instance;</div><div class=\"line\">  <span class=\"keyword\">var</span> renderedElement;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">if</span> (__DEV__) &#123;</div><div class=\"line\">    renderedElement = measureLifeCyclePerf(</div><div class=\"line\">      <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> inst.render(),</div><div class=\"line\">      <span class=\"keyword\">this</span>._debugID,</div><div class=\"line\">      <span class=\"string\">'render'</span>,</div><div class=\"line\">    );</div><div class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">    renderedElement = inst.render();</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">if</span> (__DEV__) &#123;</div><div class=\"line\">    <span class=\"comment\">// We allow auto-mocks to proceed as if they're returning null.</span></div><div class=\"line\">    <span class=\"keyword\">if</span> (renderedElement === <span class=\"literal\">undefined</span> &amp;&amp; inst.render._isMockFunction) &#123;</div><div class=\"line\">      <span class=\"comment\">// This is probably bad practice. Consider warning here and</span></div><div class=\"line\">      <span class=\"comment\">// deprecating this convenience.</span></div><div class=\"line\">      renderedElement = <span class=\"literal\">null</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">return</span> renderedElement;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>可以看出来这个会调用 render 方法，调用了 render 方法后就会返回 一个 新的 element。</p>\n<p>再回到 _updateRenderedComponent:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/**</span></div><div class=\"line\">  * Call the component's `render` method and update the DOM accordingly.</div><div class=\"line\">  *</div><div class=\"line\">  * @param &#123;ReactReconcileTransaction&#125; transaction</div><div class=\"line\">  * @internal</div><div class=\"line\">  */</div><div class=\"line\">_updateRenderedComponent: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">transaction, context</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">var</span> nextRenderedElement = <span class=\"keyword\">this</span>._renderValidatedComponent();</div><div class=\"line\">  <span class=\"keyword\">this</span>._updateRenderedComponentWithNextElement(</div><div class=\"line\">    transaction,</div><div class=\"line\">    context,</div><div class=\"line\">    nextRenderedElement,</div><div class=\"line\">    <span class=\"literal\">false</span> <span class=\"comment\">/* safely */</span>,</div><div class=\"line\">  );</div><div class=\"line\">&#125;,</div></pre></td></tr></table></figure>\n<p>拿到了 render 出来的 element 就会调用 _updateRenderedComponentWithNextElement:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/**</span></div><div class=\"line\">  * Call the component's `render` method and update the DOM accordingly.</div><div class=\"line\">  *</div><div class=\"line\">  * @param &#123;ReactReconcileTransaction&#125; transaction</div><div class=\"line\">  * @internal</div><div class=\"line\">  */</div><div class=\"line\">_updateRenderedComponentWithNextElement: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span></span></div><div class=\"line\">  transaction,</div><div class=\"line\">  context,</div><div class=\"line\">  nextRenderedElement,</div><div class=\"line\">  safely,</div><div class=\"line\">) &#123;</div><div class=\"line\">  <span class=\"keyword\">var</span> prevComponentInstance = <span class=\"keyword\">this</span>._renderedComponent;</div><div class=\"line\">  <span class=\"keyword\">var</span> prevRenderedElement = prevComponentInstance._currentElement;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">//...</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">if</span> (shouldUpdateReactComponent(prevRenderedElement, nextRenderedElement)) &#123;</div><div class=\"line\">    ReactReconciler.receiveComponent(</div><div class=\"line\">      prevComponentInstance,</div><div class=\"line\">      nextRenderedElement,</div><div class=\"line\">      transaction,</div><div class=\"line\">      <span class=\"keyword\">this</span>._processChildContext(context),</div><div class=\"line\">    );</div><div class=\"line\">  &#125;</div><div class=\"line\">  <span class=\"comment\">//...</span></div></pre></td></tr></table></figure>\n<p>到这里会发现 首先调用 shouldUpdateReactComponent，注意这个和生命周期里面的 shouldComponentUpdate 不同。<br>如果返回 true，那么直接调用 ReactReconciler 的 receiveComponent 来进行更新。</p>\n<p>那么我们就先看一下 shoudlUpdateReactComponent:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/**</span></div><div class=\"line\">* Given a `prevElement` and `nextElement`, determines if the existing</div><div class=\"line\">* instance should be updated as opposed to being destroyed or replaced by a new</div><div class=\"line\">* instance. Both arguments are elements. This ensures that this logic can</div><div class=\"line\">* operate on stateless trees without any backing instance.</div><div class=\"line\">*</div><div class=\"line\">* @param &#123;?object&#125; prevElement</div><div class=\"line\">* @param &#123;?object&#125; nextElement</div><div class=\"line\">* @return &#123;boolean&#125; True if the existing instance should be updated.</div><div class=\"line\">* @protected</div><div class=\"line\">*/</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">shouldUpdateReactComponent</span>(<span class=\"params\">prevElement, nextElement</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">var</span> prevEmpty = prevElement === <span class=\"literal\">null</span> || prevElement === <span class=\"literal\">false</span>;</div><div class=\"line\">  <span class=\"keyword\">var</span> nextEmpty = nextElement === <span class=\"literal\">null</span> || nextElement === <span class=\"literal\">false</span>;</div><div class=\"line\">  <span class=\"keyword\">if</span> (prevEmpty || nextEmpty) &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> prevEmpty === nextEmpty;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">var</span> prevType = <span class=\"keyword\">typeof</span> prevElement;</div><div class=\"line\">  <span class=\"keyword\">var</span> nextType = <span class=\"keyword\">typeof</span> nextElement;</div><div class=\"line\">  <span class=\"keyword\">if</span> (prevType === <span class=\"string\">'string'</span> || prevType === <span class=\"string\">'number'</span>) &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> nextType === <span class=\"string\">'string'</span> || nextType === <span class=\"string\">'number'</span>;</div><div class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> (</div><div class=\"line\">      nextType === <span class=\"string\">'object'</span> &amp;&amp;</div><div class=\"line\">      prevElement.type === nextElement.type &amp;&amp;</div><div class=\"line\">      prevElement.key === nextElement.key</div><div class=\"line\">    );</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>注意这段代码的注释部分，该函数返回 true 意味着更新当前的 instance，而不是直接 destroy 掉，若是返回 false，那么就是说当前的 instance 会被销毁加替代。<br>为 true 的条件很简单：</p>\n<ol>\n<li>如果是 string 或者 number 直接返回 true</li>\n<li>如果是 object 必须保证 type 和 key 一致</li>\n</ol>\n<p>让我们在回到上层代码，考虑 shoudlUpdateReactComponent 结果为 true 的时候，ReactConciler.ReceiveComponent 的调用：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//_updateRenderedComponentWithNextElement: function</span></div><div class=\"line\">ReactReconciler.receiveComponent(</div><div class=\"line\">        prevComponentInstance,</div><div class=\"line\">        nextRenderedElement,</div><div class=\"line\">        transaction,</div><div class=\"line\">        <span class=\"keyword\">this</span>._processChildContext(context),</div><div class=\"line\">      );</div></pre></td></tr></table></figure>\n<p>这里有段 context 的处理，但是考虑到目前 context 的使用并不是很频繁，我们直接跳过。<br>我们再看一下 ReactReconciler.receiveComponent 的实现：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// ReactReconciler.receiveComponent</span></div><div class=\"line\"><span class=\"comment\">/**</span></div><div class=\"line\">  * Update a component using a new element.</div><div class=\"line\">  *</div><div class=\"line\">  * @param &#123;ReactComponent&#125; internalInstance</div><div class=\"line\">  * @param &#123;ReactElement&#125; nextElement</div><div class=\"line\">  * @param &#123;ReactReconcileTransaction&#125; transaction</div><div class=\"line\">  * @param &#123;object&#125; context</div><div class=\"line\">  * @internal</div><div class=\"line\">  */</div><div class=\"line\">receiveComponent: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span></span></div><div class=\"line\">  internalInstance,</div><div class=\"line\">  nextElement,</div><div class=\"line\">  transaction,</div><div class=\"line\">  context,</div><div class=\"line\">) &#123;</div><div class=\"line\">  <span class=\"keyword\">var</span> prevElement = internalInstance._currentElement;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">if</span> (nextElement === prevElement &amp;&amp; context === internalInstance._context) &#123;</div><div class=\"line\">    <span class=\"comment\">// Since elements are immutable after the owner is rendered,</span></div><div class=\"line\">    <span class=\"comment\">// we can do a cheap identity compare here to determine if this is a</span></div><div class=\"line\">    <span class=\"comment\">// superfluous reconcile. It's possible for state to be mutable but such</span></div><div class=\"line\">    <span class=\"comment\">// change should trigger an update of the owner which would recreate</span></div><div class=\"line\">    <span class=\"comment\">// the element. We explicitly check for the existence of an owner since</span></div><div class=\"line\">    <span class=\"comment\">// it's possible for an element created outside a composite to be</span></div><div class=\"line\">    <span class=\"comment\">// deeply mutated and reused.</span></div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// <span class=\"doctag\">TODO:</span> Bailing out early is just a perf optimization right?</span></div><div class=\"line\">    <span class=\"comment\">// <span class=\"doctag\">TODO:</span> Removing the return statement should affect correctness?</span></div><div class=\"line\">    <span class=\"keyword\">return</span>;</div><div class=\"line\">  &#125;</div><div class=\"line\">  <span class=\"comment\">//...</span></div><div class=\"line\">  internalInstance.receiveComponent(nextElement, transaction, context);</div><div class=\"line\">  <span class=\"comment\">//...</span></div><div class=\"line\">&#125;,</div></pre></td></tr></table></figure>\n<p>这段代码这里省略了一些 ref 的处理，不过以后也可以详细谈。<br>这里会做一次检查，会做一次 reference 的比较，如果相同，那么自然就没有必要去更新。<br>然后在使用传入的 internalInstance.receiveComponent 去做真正的更新。</p>\n<p>那么我们直接看 ReactComponent 的 receiveComponent：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">receiveComponent: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">nextElement, transaction, nextContext</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">var</span> prevElement = <span class=\"keyword\">this</span>._currentElement;</div><div class=\"line\">  <span class=\"keyword\">var</span> prevContext = <span class=\"keyword\">this</span>._context;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">this</span>._pendingElement = <span class=\"literal\">null</span>;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">this</span>.updateComponent(</div><div class=\"line\">    transaction,</div><div class=\"line\">    prevElement,</div><div class=\"line\">    nextElement,</div><div class=\"line\">    prevContext,</div><div class=\"line\">    nextContext,</div><div class=\"line\">  );</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>然后我们发现居然又回到了 updateComponent 这个函数，因此现在有两个问题：</p>\n<ol>\n<li>上次调用和这次调用那里不同？</li>\n<li>如果不同，是一种递归的话，在哪里停止？<br>第一个问题是容易回答的，肯定不同，不同之处在于 this 发生了变化，其实这个 instance 是这样来的：</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/**</span></div><div class=\"line\">  * Call the component's `render` method and update the DOM accordingly.</div><div class=\"line\">  *</div><div class=\"line\">  * @param &#123;ReactReconcileTransaction&#125; transaction</div><div class=\"line\">  * @internal</div><div class=\"line\">  */</div><div class=\"line\">_updateRenderedComponentWithNextElement: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span></span></div><div class=\"line\">  transaction,</div><div class=\"line\">  context,</div><div class=\"line\">  nextRenderedElement,</div><div class=\"line\">  safely,</div><div class=\"line\">) &#123;</div><div class=\"line\">  <span class=\"keyword\">var</span> prevComponentInstance = <span class=\"keyword\">this</span>._renderedComponent;</div><div class=\"line\">  <span class=\"comment\">//...</span></div></pre></td></tr></table></figure>\n<p>而 this._renderedComponent 的唯一 assignment 是在 _updateRenderedComponentWithNextElement 的另一条条件分支里面，也就是说当需要替换 component 的时候，会将产生这个 assignment：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div></pre></td><td class=\"code\"><pre><div class=\"line\">_updateRenderedComponentWithNextElement: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span></span></div><div class=\"line\">  transaction,</div><div class=\"line\">  context,</div><div class=\"line\">  nextRenderedElement,</div><div class=\"line\">  safely,</div><div class=\"line\">) &#123;</div><div class=\"line\">  <span class=\"keyword\">var</span> prevComponentInstance = <span class=\"keyword\">this</span>._renderedComponent;</div><div class=\"line\">  <span class=\"keyword\">var</span> prevRenderedElement = prevComponentInstance._currentElement;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">//...</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">if</span> (shouldUpdateReactComponent(prevRenderedElement, nextRenderedElement)) &#123;</div><div class=\"line\">  ReactReconciler.receiveComponent(</div><div class=\"line\">    prevComponentInstance,</div><div class=\"line\">    nextRenderedElement,</div><div class=\"line\">    transaction,</div><div class=\"line\">    <span class=\"keyword\">this</span>._processChildContext(context),</div><div class=\"line\">  );</div><div class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">  <span class=\"keyword\">var</span> oldHostNode = ReactReconciler.getHostNode(prevComponentInstance);</div><div class=\"line\">  <span class=\"keyword\">var</span> nodeType = ReactNodeTypes.getType(nextRenderedElement);</div><div class=\"line\">  <span class=\"keyword\">this</span>._renderedNodeType = nodeType;</div><div class=\"line\">  <span class=\"keyword\">var</span> child = <span class=\"keyword\">this</span>._instantiateReactComponent(</div><div class=\"line\">    nextRenderedElement,</div><div class=\"line\">    nodeType !== ReactNodeTypes.EMPTY <span class=\"comment\">/* shouldHaveDebugID */</span>,</div><div class=\"line\">  );</div><div class=\"line\">  <span class=\"keyword\">this</span>._renderedComponent = child;</div><div class=\"line\">  <span class=\"comment\">//...</span></div></pre></td></tr></table></figure>\n<p>这里试想如果是第一次进入这个函数，this._renderedComponent 肯定是 undefined，而 nextRenderedElement 肯定不是空的，也就说一定会进入第二个分支，然后将新的 element 实例化成新的 this._renderedComponent。<br>因此所有的秘密都停留在了 this._instantiateReactComponent 里面了。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/**</span></div><div class=\"line\"> * Given a ReactNode, create an instance that will actually be mounted.</div><div class=\"line\"> *</div><div class=\"line\"> * @param &#123;ReactNode&#125; node</div><div class=\"line\"> * @param &#123;boolean&#125; shouldHaveDebugID</div><div class=\"line\"> * @return &#123;object&#125; A new instance of the element's constructor.</div><div class=\"line\"> * @protected</div><div class=\"line\"> */</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">instantiateReactComponent</span>(<span class=\"params\">node, shouldHaveDebugID</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">var</span> instance;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">if</span> (node === <span class=\"literal\">null</span> || node === <span class=\"literal\">false</span>) &#123;</div><div class=\"line\">    instance = ReactEmptyComponent.create(instantiateReactComponent);</div><div class=\"line\">  &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> node === <span class=\"string\">'object'</span>) &#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> element = node;</div><div class=\"line\">    <span class=\"keyword\">var</span> type = element.type;</div><div class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> type !== <span class=\"string\">'function'</span> &amp;&amp; <span class=\"keyword\">typeof</span> type !== <span class=\"string\">'string'</span>) &#123;</div><div class=\"line\">      <span class=\"keyword\">var</span> info = <span class=\"string\">''</span>;</div><div class=\"line\">      <span class=\"keyword\">if</span> (__DEV__) &#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (</div><div class=\"line\">          type === <span class=\"literal\">undefined</span> ||</div><div class=\"line\">          (<span class=\"keyword\">typeof</span> type === <span class=\"string\">'object'</span> &amp;&amp;</div><div class=\"line\">            type !== <span class=\"literal\">null</span> &amp;&amp;</div><div class=\"line\">            <span class=\"built_in\">Object</span>.keys(type).length === <span class=\"number\">0</span>)</div><div class=\"line\">        ) &#123;</div><div class=\"line\">          info +=</div><div class=\"line\">            <span class=\"string\">' You likely forgot to export your component from the file '</span> +</div><div class=\"line\">            <span class=\"string\">\"it's defined in.\"</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\">      &#125;</div><div class=\"line\">      info += getDeclarationErrorAddendum(element._owner);</div><div class=\"line\">      invariant(</div><div class=\"line\">        <span class=\"literal\">false</span>,</div><div class=\"line\">        <span class=\"string\">'Element type is invalid: expected a string (for built-in components) '</span> +</div><div class=\"line\">          <span class=\"string\">'or a class/function (for composite components) but got: %s.%s'</span>,</div><div class=\"line\">        type == <span class=\"literal\">null</span> ? type : <span class=\"keyword\">typeof</span> type,</div><div class=\"line\">        info,</div><div class=\"line\">      );</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// Special case string values</span></div><div class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> element.type === <span class=\"string\">'string'</span>) &#123;</div><div class=\"line\">      instance = ReactHostComponent.createInternalComponent(element);</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (isInternalComponentType(element.type)) &#123;</div><div class=\"line\">      <span class=\"comment\">// This is temporarily available for custom components that are not string</span></div><div class=\"line\">      <span class=\"comment\">// representations. I.e. ART. Once those are updated to use the string</span></div><div class=\"line\">      <span class=\"comment\">// representation, we can drop this code path.</span></div><div class=\"line\">      instance = <span class=\"keyword\">new</span> element.type(element);</div><div class=\"line\"></div><div class=\"line\">      <span class=\"comment\">// We renamed this. Allow the old name for compat. :(</span></div><div class=\"line\">      <span class=\"keyword\">if</span> (!instance.getHostNode) &#123;</div><div class=\"line\">        instance.getHostNode = instance.getNativeNode;</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">      instance = <span class=\"keyword\">new</span> ReactCompositeComponentWrapper(element);</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> node === <span class=\"string\">'string'</span> || <span class=\"keyword\">typeof</span> node === <span class=\"string\">'number'</span>) &#123;</div><div class=\"line\">    instance = ReactHostComponent.createInstanceForText(node);</div><div class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">    invariant(<span class=\"literal\">false</span>, <span class=\"string\">'Encountered invalid React node of type %s'</span>, <span class=\"keyword\">typeof</span> node);</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">if</span> (__DEV__) &#123;</div><div class=\"line\">    warning(</div><div class=\"line\">      <span class=\"keyword\">typeof</span> instance.mountComponent === <span class=\"string\">'function'</span> &amp;&amp;</div><div class=\"line\">        <span class=\"keyword\">typeof</span> instance.receiveComponent === <span class=\"string\">'function'</span> &amp;&amp;</div><div class=\"line\">        <span class=\"keyword\">typeof</span> instance.getHostNode === <span class=\"string\">'function'</span> &amp;&amp;</div><div class=\"line\">        <span class=\"keyword\">typeof</span> instance.unmountComponent === <span class=\"string\">'function'</span>,</div><div class=\"line\">      <span class=\"string\">'Only React Components can be mounted.'</span>,</div><div class=\"line\">    );</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">// These two fields are used by the DOM and ART diffing algorithms</span></div><div class=\"line\">  <span class=\"comment\">// respectively. Instead of using expandos on components, we should be</span></div><div class=\"line\">  <span class=\"comment\">// storing the state needed by the diffing algorithms elsewhere.</span></div><div class=\"line\">  instance._mountIndex = <span class=\"number\">0</span>;</div><div class=\"line\">  instance._mountImage = <span class=\"literal\">null</span>;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">if</span> (__DEV__) &#123;</div><div class=\"line\">    instance._debugID = shouldHaveDebugID ? nextDebugID++ : <span class=\"number\">0</span>;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">// Internal instances should fully constructed at this point, so they should</span></div><div class=\"line\">  <span class=\"comment\">// not get any new fields added to them at this point.</span></div><div class=\"line\">  <span class=\"keyword\">if</span> (__DEV__) &#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">Object</span>.preventExtensions) &#123;</div><div class=\"line\">      <span class=\"built_in\">Object</span>.preventExtensions(instance);</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">return</span> instance;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这段代码其实简单的看来就是处理三种不同的 ReactElement：</p>\n<ol>\n<li>string, number =&gt; 直接使用 ReactHostComponent.createInstanceForText 来进行实例化</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//...</span></div><div class=\"line\"> <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> node === <span class=\"string\">'string'</span> || <span class=\"keyword\">typeof</span> node === <span class=\"string\">'number'</span>) &#123;</div><div class=\"line\">    instance = ReactHostComponent.createInstanceForText(node);</div><div class=\"line\"><span class=\"comment\">//...</span></div></pre></td></tr></table></figure>\n<ol>\n<li>是 object 并且其 type 字段又是 string，那么就会使用 ReactHostComponent.createInternalComponent 来进行实例化</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//...</span></div><div class=\"line\"> <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> element.type === <span class=\"string\">'string'</span>) &#123;</div><div class=\"line\">      instance = ReactHostComponent.createInternalComponent(element);</div><div class=\"line\">    &#125;</div><div class=\"line\"><span class=\"comment\">//...</span></div></pre></td></tr></table></figure>\n<ol>\n<li>是 CompositeElement，会使用 ReactCompositeComponentWrapper 来进行实例化，其中会做一次检查，检查是否是是自定义的 type（只要定义了 mountComponent 和 receiveComponent 就行了）</li>\n</ol>\n<p>因此在回到我们之前的问题：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div></pre></td><td class=\"code\"><pre><div class=\"line\">_updateRenderedComponentWithNextElement: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span></span></div><div class=\"line\">  transaction,</div><div class=\"line\">  context,</div><div class=\"line\">  nextRenderedElement,</div><div class=\"line\">  safely,</div><div class=\"line\">) &#123;</div><div class=\"line\">  <span class=\"keyword\">var</span> prevComponentInstance = <span class=\"keyword\">this</span>._renderedComponent;</div><div class=\"line\">  <span class=\"keyword\">var</span> prevRenderedElement = prevComponentInstance._currentElement;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">//...</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">if</span> (shouldUpdateReactComponent(prevRenderedElement, nextRenderedElement)) &#123;</div><div class=\"line\">  ReactReconciler.receiveComponent(</div><div class=\"line\">    prevComponentInstance,</div><div class=\"line\">    nextRenderedElement,</div><div class=\"line\">    transaction,</div><div class=\"line\">    <span class=\"keyword\">this</span>._processChildContext(context),</div><div class=\"line\">  );</div><div class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">  <span class=\"keyword\">var</span> oldHostNode = ReactReconciler.getHostNode(prevComponentInstance);</div><div class=\"line\">  <span class=\"keyword\">var</span> nodeType = ReactNodeTypes.getType(nextRenderedElement);</div><div class=\"line\">  <span class=\"keyword\">this</span>._renderedNodeType = nodeType;</div><div class=\"line\">  <span class=\"keyword\">var</span> child = <span class=\"keyword\">this</span>._instantiateReactComponent(</div><div class=\"line\">    nextRenderedElement,</div><div class=\"line\">    nodeType !== ReactNodeTypes.EMPTY <span class=\"comment\">/* shouldHaveDebugID */</span>,</div><div class=\"line\">  );</div><div class=\"line\">  <span class=\"keyword\">this</span>._renderedComponent = child;</div><div class=\"line\">  <span class=\"comment\">//...</span></div></pre></td></tr></table></figure>\n<p>这个 child 实际上就是被实例化出来的一个新的 Component（注意为什么是 child，是因为 nextRenderedElement 是用当前 Component 的 render 函数形成的），所以 第一个问题解决了：</p>\n<blockquote>\n<ol>\n<li>上次调用和这次调用那里不同？</li>\n<li>如果不同，是一种递归的话，在哪里停止？</li>\n</ol>\n</blockquote>\n<p>那么第二个问题是怎么解决的呢？<br>直观上看这个递归的结束很简单，就是最后没有了 child，所以这里就不深究了。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//...</span></div><div class=\"line\"><span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (isInternalComponentType(element.type)) &#123;</div><div class=\"line\">      <span class=\"comment\">// This is temporarily available for custom components that are not string</span></div><div class=\"line\">      <span class=\"comment\">// representations. I.e. ART. Once those are updated to use the string</span></div><div class=\"line\">      <span class=\"comment\">// representation, we can drop this code path.</span></div><div class=\"line\">      instance = <span class=\"keyword\">new</span> element.type(element);</div><div class=\"line\"></div><div class=\"line\">      <span class=\"comment\">// We renamed this. Allow the old name for compat. :(</span></div><div class=\"line\">      <span class=\"keyword\">if</span> (!instance.getHostNode) &#123;</div><div class=\"line\">        instance.getHostNode = instance.getNativeNode;</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">      instance = <span class=\"keyword\">new</span> ReactCompositeComponentWrapper(element);</div><div class=\"line\">    &#125;</div><div class=\"line\"><span class=\"comment\">//...</span></div></pre></td></tr></table></figure>\n<p>再回到之前的 _updateRenderedComponentWithNextElement，把接下来的处理看掉：</p>\n  <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div></pre></td><td class=\"code\"><pre><div class=\"line\">  <span class=\"comment\">// _updateRenderedComponentWithNextElement: function()</span></div><div class=\"line\">  <span class=\"keyword\">if</span> (shouldUpdateReactComponent(prevRenderedElement, nextRenderedElement)) &#123;</div><div class=\"line\">    ReactReconciler.receiveComponent(</div><div class=\"line\">      prevComponentInstance,</div><div class=\"line\">      nextRenderedElement,</div><div class=\"line\">      transaction,</div><div class=\"line\">      <span class=\"keyword\">this</span>._processChildContext(context),</div><div class=\"line\">    );</div><div class=\"line\">  &#125; </div><div class=\"line\">  <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> oldHostNode = ReactReconciler.getHostNode(prevComponentInstance);</div><div class=\"line\">    <span class=\"keyword\">var</span> nodeType = ReactNodeTypes.getType(nextRenderedElement);</div><div class=\"line\">    <span class=\"keyword\">this</span>._renderedNodeType = nodeType;</div><div class=\"line\">    <span class=\"keyword\">var</span> child = <span class=\"keyword\">this</span>._instantiateReactComponent(</div><div class=\"line\">      nextRenderedElement,</div><div class=\"line\">      nodeType !== ReactNodeTypes.EMPTY <span class=\"comment\">/* shouldHaveDebugID */</span>,</div><div class=\"line\">    );</div><div class=\"line\">    <span class=\"keyword\">this</span>._renderedComponent = child;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">var</span> nextMarkup = ReactReconciler.mountComponent(</div><div class=\"line\">      child,</div><div class=\"line\">      transaction,</div><div class=\"line\">      <span class=\"keyword\">this</span>._hostParent,</div><div class=\"line\">      <span class=\"keyword\">this</span>._hostContainerInfo,</div><div class=\"line\">      <span class=\"keyword\">this</span>._processChildContext(context),</div><div class=\"line\">      debugID,</div><div class=\"line\">    );</div><div class=\"line\"></div><div class=\"line\">    ReactReconciler.unmountComponent(</div><div class=\"line\">      prevComponentInstance,</div><div class=\"line\">      safely,</div><div class=\"line\">      <span class=\"literal\">false</span> <span class=\"comment\">/* skipLifecycle */</span>,</div><div class=\"line\">    );</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">if</span> (__DEV__) &#123;</div><div class=\"line\">      <span class=\"keyword\">if</span> (debugID !== <span class=\"number\">0</span>) &#123;</div><div class=\"line\">        <span class=\"keyword\">var</span> childDebugIDs = child._debugID !== <span class=\"number\">0</span> ? [child._debugID] : [];</div><div class=\"line\">        ReactInstrumentation.debugTool.onSetChildren(debugID, childDebugIDs);</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">this</span>._replaceNodeWithMarkup(</div><div class=\"line\">      oldHostNode,</div><div class=\"line\">      nextMarkup,</div><div class=\"line\">      prevComponentInstance,</div><div class=\"line\">    );</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;,</div></pre></td></tr></table></figure>\n<p>这块总的来说就是在 shouldUpdateReactComponent 返回 false 的时候：</p>\n<ol>\n<li>保存老的 hostNode</li>\n<li>instantiate 新的 ReactComponent</li>\n<li>mount 这个新的 instance，拿到 markup</li>\n<li>unmount 旧的 instance</li>\n<li>重新渲染 hostNode 下的 dom</li>\n</ol>\n<h2 id=\"ReactDOMComponent\"><a href=\"#ReactDOMComponent\" class=\"headerlink\" title=\"ReactDOMComponent\"></a>ReactDOMComponent</h2><p>其实 ReactCompositeComponent 不会做具体的更新的。<br>在 performUpdateIfNecessary 中的第一个条件表明，如果存在 pendingElement 那么会直接调用 ReactReconciler.receiveComponent。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/**</span></div><div class=\"line\">  * If any of `_pendingElement`, `_pendingStateQueue`, or `_pendingForceUpdate`</div><div class=\"line\">  * is set, update the component.</div><div class=\"line\">  *</div><div class=\"line\">  * @param &#123;ReactReconcileTransaction&#125; transaction</div><div class=\"line\">  * @internal</div><div class=\"line\">  */</div><div class=\"line\">performUpdateIfNecessary: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">transaction</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>._pendingElement != <span class=\"literal\">null</span>) &#123;</div><div class=\"line\">    ReactReconciler.receiveComponent(</div><div class=\"line\">      <span class=\"keyword\">this</span>,</div><div class=\"line\">      <span class=\"keyword\">this</span>._pendingElement,</div><div class=\"line\">      transaction,</div><div class=\"line\">      <span class=\"keyword\">this</span>._context,</div><div class=\"line\">    );</div><div class=\"line\">  &#125;</div></pre></td></tr></table></figure>\n<p>而 ReactReconciler.receiveComponent 中的具体做法是：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// ReactReconciler.receiveComponent</span></div><div class=\"line\"><span class=\"comment\">/**</span></div><div class=\"line\">  * Update a component using a new element.</div><div class=\"line\">  *</div><div class=\"line\">  * @param &#123;ReactComponent&#125; internalInstance</div><div class=\"line\">  * @param &#123;ReactElement&#125; nextElement</div><div class=\"line\">  * @param &#123;ReactReconcileTransaction&#125; transaction</div><div class=\"line\">  * @param &#123;object&#125; context</div><div class=\"line\">  * @internal</div><div class=\"line\">  */</div><div class=\"line\">receiveComponent: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span></span></div><div class=\"line\">  internalInstance,</div><div class=\"line\">  nextElement,</div><div class=\"line\">  transaction,</div><div class=\"line\">  context,</div><div class=\"line\">) &#123;</div><div class=\"line\">  <span class=\"keyword\">var</span> prevElement = internalInstance._currentElement;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">if</span> (nextElement === prevElement &amp;&amp; context === internalInstance._context) &#123;</div><div class=\"line\">    <span class=\"comment\">// Since elements are immutable after the owner is rendered,</span></div><div class=\"line\">    <span class=\"comment\">// we can do a cheap identity compare here to determine if this is a</span></div><div class=\"line\">    <span class=\"comment\">// superfluous reconcile. It's possible for state to be mutable but such</span></div><div class=\"line\">    <span class=\"comment\">// change should trigger an update of the owner which would recreate</span></div><div class=\"line\">    <span class=\"comment\">// the element. We explicitly check for the existence of an owner since</span></div><div class=\"line\">    <span class=\"comment\">// it's possible for an element created outside a composite to be</span></div><div class=\"line\">    <span class=\"comment\">// deeply mutated and reused.</span></div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// <span class=\"doctag\">TODO:</span> Bailing out early is just a perf optimization right?</span></div><div class=\"line\">    <span class=\"comment\">// <span class=\"doctag\">TODO:</span> Removing the return statement should affect correctness?</span></div><div class=\"line\">    <span class=\"keyword\">return</span>;</div><div class=\"line\">  &#125;</div><div class=\"line\">  <span class=\"comment\">//...</span></div><div class=\"line\">  internalInstance.receiveComponent(nextElement, transaction, context);</div><div class=\"line\">  <span class=\"comment\">//...</span></div><div class=\"line\">&#125;,</div></pre></td></tr></table></figure>\n<p>又把 receiveComponent delegate 给了这个 Component 的 instance，我们再看 ReactCompositeComponent.receiveComponent：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">receiveComponent: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">nextElement, transaction, nextContext</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">var</span> prevElement = <span class=\"keyword\">this</span>._currentElement;</div><div class=\"line\">  <span class=\"keyword\">var</span> prevContext = <span class=\"keyword\">this</span>._context;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">this</span>._pendingElement = <span class=\"literal\">null</span>;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">this</span>.updateComponent(</div><div class=\"line\">    transaction,</div><div class=\"line\">    prevElement,</div><div class=\"line\">    nextElement,</div><div class=\"line\">    prevContext,</div><div class=\"line\">    nextContext,</div><div class=\"line\">  );</div><div class=\"line\">&#125;,</div></pre></td></tr></table></figure>\n<p>再看 updateComponent：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/**</span></div><div class=\"line\">   * Perform an update to a mounted component. The componentWillReceiveProps and</div><div class=\"line\">   * shouldComponentUpdate methods are called, then (assuming the update isn't</div><div class=\"line\">   * skipped) the remaining update lifecycle methods are called and the DOM</div><div class=\"line\">   * representation is updated.</div><div class=\"line\">   *</div><div class=\"line\">   * By default, this implements React's rendering and reconciliation algorithm.</div><div class=\"line\">   * Sophisticated clients may wish to override this.</div><div class=\"line\">   *</div><div class=\"line\">   * @param &#123;ReactReconcileTransaction&#125; transaction</div><div class=\"line\">   * @param &#123;ReactElement&#125; prevParentElement</div><div class=\"line\">   * @param &#123;ReactElement&#125; nextParentElement</div><div class=\"line\">   * @internal</div><div class=\"line\">   * @overridable</div><div class=\"line\">   */</div><div class=\"line\">  updateComponent: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span></span></div><div class=\"line\">    transaction,</div><div class=\"line\">    prevParentElement,</div><div class=\"line\">    nextParentElement,</div><div class=\"line\">    prevUnmaskedContext,</div><div class=\"line\">    nextUnmaskedContext,</div><div class=\"line\">  ) &#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (shouldUpdate) &#123;</div><div class=\"line\">      <span class=\"keyword\">this</span>._pendingForceUpdate = <span class=\"literal\">false</span>;</div><div class=\"line\">      <span class=\"comment\">// Will set `this.props`, `this.state` and `this.context`.</span></div><div class=\"line\">      <span class=\"keyword\">this</span>._performComponentUpdate(</div><div class=\"line\">        nextParentElement,</div><div class=\"line\">        nextProps,</div><div class=\"line\">        nextState,</div><div class=\"line\">        nextContext,</div><div class=\"line\">        transaction,</div><div class=\"line\">        nextUnmaskedContext,</div><div class=\"line\">      );</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">    <span class=\"comment\">//...</span></div></pre></td></tr></table></figure>\n<p>再看 _performComponentUpdate:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/**</span></div><div class=\"line\">   * Merges new props and state, notifies delegate methods of update and</div><div class=\"line\">   * performs update.</div><div class=\"line\">   *</div><div class=\"line\">   * @param &#123;ReactElement&#125; nextElement Next element</div><div class=\"line\">   * @param &#123;object&#125; nextProps Next public object to set as properties.</div><div class=\"line\">   * @param &#123;?object&#125; nextState Next object to set as state.</div><div class=\"line\">   * @param &#123;?object&#125; nextContext Next public object to set as context.</div><div class=\"line\">   * @param &#123;ReactReconcileTransaction&#125; transaction</div><div class=\"line\">   * @param &#123;?object&#125; unmaskedContext</div><div class=\"line\">   * @private</div><div class=\"line\">   */</div><div class=\"line\">  _performComponentUpdate: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span></span></div><div class=\"line\">    nextElement,</div><div class=\"line\">    nextProps,</div><div class=\"line\">    nextState,</div><div class=\"line\">    nextContext,</div><div class=\"line\">    transaction,</div><div class=\"line\">    unmaskedContext,</div><div class=\"line\">  ) &#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> inst = <span class=\"keyword\">this</span>._instance;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">var</span> hasComponentDidUpdate = !!inst.componentDidUpdate;</div><div class=\"line\">    <span class=\"keyword\">var</span> prevProps;</div><div class=\"line\">    <span class=\"keyword\">var</span> prevState;</div><div class=\"line\">    <span class=\"keyword\">if</span> (hasComponentDidUpdate) &#123;</div><div class=\"line\">      prevProps = inst.props;</div><div class=\"line\">      prevState = inst.state;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"comment\">//...</span></div><div class=\"line\">    <span class=\"keyword\">this</span>._currentElement = nextElement;</div><div class=\"line\">    <span class=\"keyword\">this</span>._context = unmaskedContext;</div><div class=\"line\">    inst.props = nextProps;</div><div class=\"line\">    inst.state = nextState;</div><div class=\"line\">    inst.context = nextContext;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">if</span> (inst.unstable_handleError) &#123;</div><div class=\"line\">      <span class=\"keyword\">this</span>._updateRenderedComponentWithErrorHandling(</div><div class=\"line\">        transaction,</div><div class=\"line\">        unmaskedContext,</div><div class=\"line\">      );</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">      <span class=\"keyword\">this</span>._updateRenderedComponent(transaction, unmaskedContext);</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"comment\">//...</span></div></pre></td></tr></table></figure>\n<p>因此我们又要看 _updateRenderedComponent:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/**</span></div><div class=\"line\"> * Call the component's `render` method and update the DOM accordingly.</div><div class=\"line\"> *</div><div class=\"line\"> * @param &#123;ReactReconcileTransaction&#125; transaction</div><div class=\"line\"> * @internal</div><div class=\"line\"> */</div><div class=\"line\">_updateRenderedComponent: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">transaction, context</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">var</span> nextRenderedElement = <span class=\"keyword\">this</span>._renderValidatedComponent();</div><div class=\"line\">  <span class=\"keyword\">this</span>._updateRenderedComponentWithNextElement(</div><div class=\"line\">    transaction,</div><div class=\"line\">    context,</div><div class=\"line\">    nextRenderedElement,</div><div class=\"line\">    <span class=\"literal\">false</span> <span class=\"comment\">/* safely */</span>,</div><div class=\"line\">  );</div><div class=\"line\">&#125;,</div></pre></td></tr></table></figure>\n<p>进入 _updateRenderedComponentWithNextElement:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/**</span></div><div class=\"line\">   * Call the component's `render` method and update the DOM accordingly.</div><div class=\"line\">   *</div><div class=\"line\">   * @param &#123;ReactReconcileTransaction&#125; transaction</div><div class=\"line\">   * @internal</div><div class=\"line\">   */</div><div class=\"line\">  _updateRenderedComponentWithNextElement: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span></span></div><div class=\"line\">    transaction,</div><div class=\"line\">    context,</div><div class=\"line\">    nextRenderedElement,</div><div class=\"line\">    safely,</div><div class=\"line\">  ) &#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> prevComponentInstance = <span class=\"keyword\">this</span>._renderedComponent;</div><div class=\"line\">    <span class=\"keyword\">var</span> prevRenderedElement = prevComponentInstance._currentElement;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">var</span> debugID = <span class=\"number\">0</span>;</div><div class=\"line\">    <span class=\"keyword\">if</span> (__DEV__) &#123;</div><div class=\"line\">      debugID = <span class=\"keyword\">this</span>._debugID;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">if</span> (shouldUpdateReactComponent(prevRenderedElement, nextRenderedElement)) &#123;</div><div class=\"line\">      ReactReconciler.receiveComponent(</div><div class=\"line\">        prevComponentInstance,</div><div class=\"line\">        nextRenderedElement,</div><div class=\"line\">        transaction,</div><div class=\"line\">        <span class=\"keyword\">this</span>._processChildContext(context),</div><div class=\"line\">      );</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">      <span class=\"keyword\">var</span> oldHostNode = ReactReconciler.getHostNode(prevComponentInstance);</div><div class=\"line\">      <span class=\"keyword\">var</span> nodeType = ReactNodeTypes.getType(nextRenderedElement);</div><div class=\"line\">      <span class=\"keyword\">this</span>._renderedNodeType = nodeType;</div><div class=\"line\">      <span class=\"keyword\">var</span> child = <span class=\"keyword\">this</span>._instantiateReactComponent(</div><div class=\"line\">        nextRenderedElement,</div><div class=\"line\">        nodeType !== ReactNodeTypes.EMPTY <span class=\"comment\">/* shouldHaveDebugID */</span>,</div><div class=\"line\">      );</div><div class=\"line\">      <span class=\"keyword\">this</span>._renderedComponent = child;</div><div class=\"line\"></div><div class=\"line\">      <span class=\"keyword\">var</span> nextMarkup = ReactReconciler.mountComponent(</div><div class=\"line\">        child,</div><div class=\"line\">        transaction,</div><div class=\"line\">        <span class=\"keyword\">this</span>._hostParent,</div><div class=\"line\">        <span class=\"keyword\">this</span>._hostContainerInfo,</div><div class=\"line\">        <span class=\"keyword\">this</span>._processChildContext(context),</div><div class=\"line\">        debugID,</div><div class=\"line\">      );</div><div class=\"line\"></div><div class=\"line\">      ReactReconciler.unmountComponent(</div><div class=\"line\">        prevComponentInstance,</div><div class=\"line\">        safely,</div><div class=\"line\">        <span class=\"literal\">false</span> <span class=\"comment\">/* skipLifecycle */</span>,</div><div class=\"line\">      );</div><div class=\"line\"></div><div class=\"line\">      <span class=\"keyword\">if</span> (__DEV__) &#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (debugID !== <span class=\"number\">0</span>) &#123;</div><div class=\"line\">          <span class=\"keyword\">var</span> childDebugIDs = child._debugID !== <span class=\"number\">0</span> ? [child._debugID] : [];</div><div class=\"line\">          ReactInstrumentation.debugTool.onSetChildren(debugID, childDebugIDs);</div><div class=\"line\">        &#125;</div><div class=\"line\">      &#125;</div><div class=\"line\"></div><div class=\"line\">      <span class=\"keyword\">this</span>._replaceNodeWithMarkup(</div><div class=\"line\">        oldHostNode,</div><div class=\"line\">        nextMarkup,</div><div class=\"line\">        prevComponentInstance,</div><div class=\"line\">      );</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;,</div></pre></td></tr></table></figure>\n<p>这里注意，根据我们之前的说明：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/**</span></div><div class=\"line\">   * Call the component's `render` method and update the DOM accordingly.</div><div class=\"line\">   *</div><div class=\"line\">   * @param &#123;ReactReconcileTransaction&#125; transaction</div><div class=\"line\">   * @internal</div><div class=\"line\">   */</div><div class=\"line\">  _updateRenderedComponentWithNextElement: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span></span></div><div class=\"line\">    transaction,</div><div class=\"line\">    context,</div><div class=\"line\">    nextRenderedElement,</div><div class=\"line\">    safely,</div><div class=\"line\">  ) &#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> prevComponentInstance = <span class=\"keyword\">this</span>._renderedComponent;</div><div class=\"line\">    <span class=\"keyword\">var</span> prevRenderedElement = prevComponentInstance._currentElement;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">var</span> debugID = <span class=\"number\">0</span>;</div><div class=\"line\">    <span class=\"keyword\">if</span> (__DEV__) &#123;</div><div class=\"line\">      debugID = <span class=\"keyword\">this</span>._debugID;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">if</span> (shouldUpdateReactComponent(prevRenderedElement, nextRenderedElement)) &#123;</div><div class=\"line\">      ReactReconciler.receiveComponent(</div><div class=\"line\">        prevComponentInstance,</div><div class=\"line\">        nextRenderedElement,</div><div class=\"line\">        transaction,</div><div class=\"line\">        <span class=\"keyword\">this</span>._processChildContext(context),</div><div class=\"line\">      );</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</div></pre></td></tr></table></figure>\n<p>这里的 prevComponentInstance 实际上是 this（这个也是一个 ComponentInstance）的 render 函数返回的 ReactElement 的 Component Instance，然后 nextRenderedElement 是当前的被更新了的 ReactElement，如果我们假设这个 prevComponentInstance 是一个 ReactDOMComponent 的话，那么一切就会进入 ReactDOMComponent 的 receiveComponent，并且接受的参数就是 nextRenderedElement，我们看一下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/**</span></div><div class=\"line\">   * Receives a next element and updates the component.</div><div class=\"line\">   *</div><div class=\"line\">   * @internal</div><div class=\"line\">   * @param &#123;ReactElement&#125; nextElement</div><div class=\"line\">   * @param &#123;ReactReconcileTransaction|ReactServerRenderingTransaction&#125; transaction</div><div class=\"line\">   * @param &#123;object&#125; context</div><div class=\"line\">   */</div><div class=\"line\">  receiveComponent: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">nextElement, transaction, context</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> prevElement = <span class=\"keyword\">this</span>._currentElement;</div><div class=\"line\">    <span class=\"keyword\">this</span>._currentElement = nextElement;</div><div class=\"line\">    <span class=\"keyword\">this</span>.updateComponent(transaction, prevElement, nextElement, context);</div><div class=\"line\">  &#125;,</div></pre></td></tr></table></figure>\n<p>在看 updateComponent：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/**</span></div><div class=\"line\"> * Updates a DOM component after it has already been allocated and</div><div class=\"line\"> * attached to the DOM. Reconciles the root DOM node, then recurses.</div><div class=\"line\"> *</div><div class=\"line\"> * @param &#123;ReactReconcileTransaction&#125; transaction</div><div class=\"line\"> * @param &#123;ReactElement&#125; prevElement</div><div class=\"line\"> * @param &#123;ReactElement&#125; nextElement</div><div class=\"line\"> * @internal</div><div class=\"line\"> * @overridable</div><div class=\"line\"> */</div><div class=\"line\">updateComponent: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">transaction, prevElement, nextElement, context</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">var</span> lastProps = prevElement.props;</div><div class=\"line\">  <span class=\"keyword\">var</span> nextProps = <span class=\"keyword\">this</span>._currentElement.props;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">switch</span> (<span class=\"keyword\">this</span>._tag) &#123;</div><div class=\"line\">    <span class=\"keyword\">case</span> <span class=\"string\">'input'</span>:</div><div class=\"line\">      lastProps = ReactDOMInput.getHostProps(<span class=\"keyword\">this</span>, lastProps);</div><div class=\"line\">      nextProps = ReactDOMInput.getHostProps(<span class=\"keyword\">this</span>, nextProps);</div><div class=\"line\">      <span class=\"keyword\">break</span>;</div><div class=\"line\">    <span class=\"keyword\">case</span> <span class=\"string\">'option'</span>:</div><div class=\"line\">      lastProps = ReactDOMOption.getHostProps(<span class=\"keyword\">this</span>, lastProps);</div><div class=\"line\">      nextProps = ReactDOMOption.getHostProps(<span class=\"keyword\">this</span>, nextProps);</div><div class=\"line\">      <span class=\"keyword\">break</span>;</div><div class=\"line\">    <span class=\"keyword\">case</span> <span class=\"string\">'select'</span>:</div><div class=\"line\">      lastProps = ReactDOMSelect.getHostProps(<span class=\"keyword\">this</span>, lastProps);</div><div class=\"line\">      nextProps = ReactDOMSelect.getHostProps(<span class=\"keyword\">this</span>, nextProps);</div><div class=\"line\">      <span class=\"keyword\">break</span>;</div><div class=\"line\">    <span class=\"keyword\">case</span> <span class=\"string\">'textarea'</span>:</div><div class=\"line\">      lastProps = ReactDOMTextarea.getHostProps(<span class=\"keyword\">this</span>, lastProps);</div><div class=\"line\">      nextProps = ReactDOMTextarea.getHostProps(<span class=\"keyword\">this</span>, nextProps);</div><div class=\"line\">      <span class=\"keyword\">break</span>;</div><div class=\"line\">    <span class=\"keyword\">default</span>:</div><div class=\"line\">      <span class=\"keyword\">if</span> (</div><div class=\"line\">        <span class=\"keyword\">typeof</span> lastProps.onClick !== <span class=\"string\">'function'</span> &amp;&amp;</div><div class=\"line\">        <span class=\"keyword\">typeof</span> nextProps.onClick === <span class=\"string\">'function'</span></div><div class=\"line\">      ) &#123;</div><div class=\"line\">        transaction</div><div class=\"line\">          .getReactMountReady()</div><div class=\"line\">          .enqueue(trapClickOnNonInteractiveElement, <span class=\"keyword\">this</span>);</div><div class=\"line\">      &#125;</div><div class=\"line\">      <span class=\"keyword\">break</span>;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  assertValidProps(<span class=\"keyword\">this</span>, nextProps);</div><div class=\"line\">  <span class=\"keyword\">var</span> isCustomComponentTag = isCustomComponent(<span class=\"keyword\">this</span>._tag, nextProps);</div><div class=\"line\">  <span class=\"keyword\">this</span>._updateDOMProperties(</div><div class=\"line\">    lastProps,</div><div class=\"line\">    nextProps,</div><div class=\"line\">    transaction,</div><div class=\"line\">    isCustomComponentTag,</div><div class=\"line\">  );</div><div class=\"line\">  <span class=\"keyword\">this</span>._updateDOMChildren(lastProps, nextProps, transaction, context);</div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">switch</span> (<span class=\"keyword\">this</span>._tag) &#123;</div><div class=\"line\">    <span class=\"keyword\">case</span> <span class=\"string\">'input'</span>:</div><div class=\"line\">      <span class=\"comment\">// Update the wrapper around inputs *after* updating props. This has to</span></div><div class=\"line\">      <span class=\"comment\">// happen after `_updateDOMProperties`. Otherwise HTML5 input validations</span></div><div class=\"line\">      <span class=\"comment\">// raise warnings and prevent the new value from being assigned.</span></div><div class=\"line\">      ReactDOMInput.updateWrapper(<span class=\"keyword\">this</span>);</div><div class=\"line\">      <span class=\"keyword\">break</span>;</div><div class=\"line\">    <span class=\"keyword\">case</span> <span class=\"string\">'textarea'</span>:</div><div class=\"line\">      ReactDOMTextarea.updateWrapper(<span class=\"keyword\">this</span>);</div><div class=\"line\">      <span class=\"keyword\">break</span>;</div><div class=\"line\">    <span class=\"keyword\">case</span> <span class=\"string\">'select'</span>:</div><div class=\"line\">      <span class=\"comment\">// &lt;select&gt; value update needs to occur after &lt;option&gt; children</span></div><div class=\"line\">      <span class=\"comment\">// reconciliation</span></div><div class=\"line\">      transaction.getReactMountReady().enqueue(postUpdateSelectWrapper, <span class=\"keyword\">this</span>);</div><div class=\"line\">      <span class=\"keyword\">break</span>;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;,</div></pre></td></tr></table></figure>\n<p>这段代码真的比较简单，唯一值得看的是 this._updateDOMChildren 这个函数:<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/**</span></div><div class=\"line\">   * Reconciles the children with the various properties that affect the</div><div class=\"line\">   * children content.</div><div class=\"line\">   *</div><div class=\"line\">   * @param &#123;object&#125; lastProps</div><div class=\"line\">   * @param &#123;object&#125; nextProps</div><div class=\"line\">   * @param &#123;ReactReconcileTransaction&#125; transaction</div><div class=\"line\">   * @param &#123;object&#125; context</div><div class=\"line\">   */</div><div class=\"line\">  _updateDOMChildren: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">lastProps, nextProps, transaction, context</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> lastContent = CONTENT_TYPES[<span class=\"keyword\">typeof</span> lastProps.children]</div><div class=\"line\">      ? lastProps.children</div><div class=\"line\">      : <span class=\"literal\">null</span>;</div><div class=\"line\">    <span class=\"keyword\">var</span> nextContent = CONTENT_TYPES[<span class=\"keyword\">typeof</span> nextProps.children]</div><div class=\"line\">      ? nextProps.children</div><div class=\"line\">      : <span class=\"literal\">null</span>;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">var</span> lastHtml =</div><div class=\"line\">      lastProps.dangerouslySetInnerHTML &amp;&amp;</div><div class=\"line\">      lastProps.dangerouslySetInnerHTML.__html;</div><div class=\"line\">    <span class=\"keyword\">var</span> nextHtml =</div><div class=\"line\">      nextProps.dangerouslySetInnerHTML &amp;&amp;</div><div class=\"line\">      nextProps.dangerouslySetInnerHTML.__html;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// Note the use of `!=` which checks for null or undefined.</span></div><div class=\"line\">    <span class=\"keyword\">var</span> lastChildren = lastContent != <span class=\"literal\">null</span> ? <span class=\"literal\">null</span> : lastProps.children;</div><div class=\"line\">    <span class=\"keyword\">var</span> nextChildren = nextContent != <span class=\"literal\">null</span> ? <span class=\"literal\">null</span> : nextProps.children;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// If we're switching from children to content/html or vice versa, remove</span></div><div class=\"line\">    <span class=\"comment\">// the old content</span></div><div class=\"line\">    <span class=\"keyword\">var</span> lastHasContentOrHtml = lastContent != <span class=\"literal\">null</span> || lastHtml != <span class=\"literal\">null</span>;</div><div class=\"line\">    <span class=\"keyword\">var</span> nextHasContentOrHtml = nextContent != <span class=\"literal\">null</span> || nextHtml != <span class=\"literal\">null</span>;</div><div class=\"line\">    <span class=\"keyword\">if</span> (lastChildren != <span class=\"literal\">null</span> &amp;&amp; nextChildren == <span class=\"literal\">null</span>) &#123;</div><div class=\"line\">      <span class=\"keyword\">this</span>.updateChildren(<span class=\"literal\">null</span>, transaction, context);</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (lastHasContentOrHtml &amp;&amp; !nextHasContentOrHtml) &#123;</div><div class=\"line\">      <span class=\"keyword\">this</span>.updateTextContent(<span class=\"string\">''</span>);</div><div class=\"line\">      <span class=\"keyword\">if</span> (__DEV__) &#123;</div><div class=\"line\">        ReactInstrumentation.debugTool.onSetChildren(<span class=\"keyword\">this</span>._debugID, []);</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">if</span> (nextContent != <span class=\"literal\">null</span>) &#123;</div><div class=\"line\">      <span class=\"keyword\">if</span> (lastContent !== nextContent) &#123;</div><div class=\"line\">        <span class=\"keyword\">this</span>.updateTextContent(<span class=\"string\">''</span> + nextContent);</div><div class=\"line\">        <span class=\"keyword\">if</span> (__DEV__) &#123;</div><div class=\"line\">          setAndValidateContentChildDev.call(<span class=\"keyword\">this</span>, nextContent);</div><div class=\"line\">        &#125;</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (nextHtml != <span class=\"literal\">null</span>) &#123;</div><div class=\"line\">      <span class=\"keyword\">if</span> (lastHtml !== nextHtml) &#123;</div><div class=\"line\">        <span class=\"keyword\">this</span>.updateMarkup(<span class=\"string\">''</span> + nextHtml);</div><div class=\"line\">      &#125;</div><div class=\"line\">      <span class=\"keyword\">if</span> (__DEV__) &#123;</div><div class=\"line\">        ReactInstrumentation.debugTool.onSetChildren(<span class=\"keyword\">this</span>._debugID, []);</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (nextChildren != <span class=\"literal\">null</span>) &#123;</div><div class=\"line\">      <span class=\"keyword\">if</span> (__DEV__) &#123;</div><div class=\"line\">        setAndValidateContentChildDev.call(<span class=\"keyword\">this</span>, <span class=\"literal\">null</span>);</div><div class=\"line\">      &#125;</div><div class=\"line\"></div><div class=\"line\">      <span class=\"keyword\">this</span>.updateChildren(nextChildren, transaction, context);</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;,</div></pre></td></tr></table></figure></p>\n<p>这段代码告诉我得看 updateChildren 这个函数，而这个函数是来自于其它类，最终在 ReactMultiChild 中找到：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/**</span></div><div class=\"line\">   * @param &#123;?object&#125; nextNestedChildrenElements Nested child element maps.</div><div class=\"line\">   * @param &#123;ReactReconcileTransaction&#125; transaction</div><div class=\"line\">   * @final</div><div class=\"line\">   * @protected</div><div class=\"line\">   */</div><div class=\"line\">  _updateChildren: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">nextNestedChildrenElements, transaction, context</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> prevChildren = <span class=\"keyword\">this</span>._renderedChildren;</div><div class=\"line\">    <span class=\"keyword\">var</span> removedNodes = &#123;&#125;;</div><div class=\"line\">    <span class=\"keyword\">var</span> mountImages = [];</div><div class=\"line\">    <span class=\"keyword\">var</span> nextChildren = <span class=\"keyword\">this</span>._reconcilerUpdateChildren(</div><div class=\"line\">      prevChildren,</div><div class=\"line\">      nextNestedChildrenElements,</div><div class=\"line\">      mountImages,</div><div class=\"line\">      removedNodes,</div><div class=\"line\">      transaction,</div><div class=\"line\">      context,</div><div class=\"line\">    );</div><div class=\"line\">    <span class=\"keyword\">if</span> (!nextChildren &amp;&amp; !prevChildren) &#123;</div><div class=\"line\">      <span class=\"keyword\">return</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">var</span> updates = <span class=\"literal\">null</span>;</div><div class=\"line\">    <span class=\"keyword\">var</span> name;</div><div class=\"line\">    <span class=\"comment\">// `nextIndex` will increment for each child in `nextChildren`, but</span></div><div class=\"line\">    <span class=\"comment\">// `lastIndex` will be the last index visited in `prevChildren`.</span></div><div class=\"line\">    <span class=\"keyword\">var</span> nextIndex = <span class=\"number\">0</span>;</div><div class=\"line\">    <span class=\"keyword\">var</span> lastIndex = <span class=\"number\">0</span>;</div><div class=\"line\">    <span class=\"comment\">// `nextMountIndex` will increment for each newly mounted child.</span></div><div class=\"line\">    <span class=\"keyword\">var</span> nextMountIndex = <span class=\"number\">0</span>;</div><div class=\"line\">    <span class=\"keyword\">var</span> lastPlacedNode = <span class=\"literal\">null</span>;</div><div class=\"line\">    <span class=\"keyword\">for</span> (name <span class=\"keyword\">in</span> nextChildren) &#123;</div><div class=\"line\">      <span class=\"keyword\">if</span> (!nextChildren.hasOwnProperty(name)) &#123;</div><div class=\"line\">        <span class=\"keyword\">continue</span>;</div><div class=\"line\">      &#125;</div><div class=\"line\">      <span class=\"keyword\">var</span> prevChild = prevChildren &amp;&amp; prevChildren[name];</div><div class=\"line\">      <span class=\"keyword\">var</span> nextChild = nextChildren[name];</div><div class=\"line\">      <span class=\"keyword\">if</span> (prevChild === nextChild) &#123;</div><div class=\"line\">        updates = enqueue(</div><div class=\"line\">          updates,</div><div class=\"line\">          <span class=\"keyword\">this</span>.moveChild(prevChild, lastPlacedNode, nextIndex, lastIndex),</div><div class=\"line\">        );</div><div class=\"line\">        lastIndex = <span class=\"built_in\">Math</span>.max(prevChild._mountIndex, lastIndex);</div><div class=\"line\">        prevChild._mountIndex = nextIndex;</div><div class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (prevChild) &#123;</div><div class=\"line\">          <span class=\"comment\">// Update `lastIndex` before `_mountIndex` gets unset by unmounting.</span></div><div class=\"line\">          lastIndex = <span class=\"built_in\">Math</span>.max(prevChild._mountIndex, lastIndex);</div><div class=\"line\">          <span class=\"comment\">// The `removedNodes` loop below will actually remove the child.</span></div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"comment\">// The child must be instantiated before it's mounted.</span></div><div class=\"line\">        updates = enqueue(</div><div class=\"line\">          updates,</div><div class=\"line\">          <span class=\"keyword\">this</span>._mountChildAtIndex(</div><div class=\"line\">            nextChild,</div><div class=\"line\">            mountImages[nextMountIndex],</div><div class=\"line\">            lastPlacedNode,</div><div class=\"line\">            nextIndex,</div><div class=\"line\">            transaction,</div><div class=\"line\">            context,</div><div class=\"line\">          ),</div><div class=\"line\">        );</div><div class=\"line\">        nextMountIndex++;</div><div class=\"line\">      &#125;</div><div class=\"line\">      nextIndex++;</div><div class=\"line\">      lastPlacedNode = ReactReconciler.getHostNode(nextChild);</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"comment\">// Remove children that are no longer present.</span></div><div class=\"line\">    <span class=\"keyword\">for</span> (name <span class=\"keyword\">in</span> removedNodes) &#123;</div><div class=\"line\">      <span class=\"keyword\">if</span> (removedNodes.hasOwnProperty(name)) &#123;</div><div class=\"line\">        updates = enqueue(</div><div class=\"line\">          updates,</div><div class=\"line\">          <span class=\"keyword\">this</span>._unmountChild(prevChildren[name], removedNodes[name]),</div><div class=\"line\">        );</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">if</span> (updates) &#123;</div><div class=\"line\">      processQueue(<span class=\"keyword\">this</span>, updates);</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">this</span>._renderedChildren = nextChildren;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">if</span> (__DEV__) &#123;</div><div class=\"line\">      setChildrenForInstrumentation.call(<span class=\"keyword\">this</span>, nextChildren);</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;,</div></pre></td></tr></table></figure></p>\n<p>还得看 this._reconcilerUpdateChildren 这个函数：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div></pre></td><td class=\"code\"><pre><div class=\"line\">_reconcilerUpdateChildren: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span></span></div><div class=\"line\">    prevChildren,</div><div class=\"line\">    nextNestedChildrenElements,</div><div class=\"line\">    mountImages,</div><div class=\"line\">    removedNodes,</div><div class=\"line\">    transaction,</div><div class=\"line\">    context,</div><div class=\"line\">  ) &#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> nextChildren;</div><div class=\"line\">    <span class=\"keyword\">var</span> selfDebugID = <span class=\"number\">0</span>;</div><div class=\"line\">    <span class=\"keyword\">if</span> (__DEV__) &#123;</div><div class=\"line\">      selfDebugID = getDebugID(<span class=\"keyword\">this</span>);</div><div class=\"line\">      <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>._currentElement) &#123;</div><div class=\"line\">        <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">          ReactCurrentOwner.current = <span class=\"keyword\">this</span>._currentElement._owner;</div><div class=\"line\">          nextChildren = flattenStackChildren(</div><div class=\"line\">            nextNestedChildrenElements,</div><div class=\"line\">            selfDebugID,</div><div class=\"line\">          );</div><div class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</div><div class=\"line\">          ReactCurrentOwner.current = <span class=\"literal\">null</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\">        ReactChildReconciler.updateChildren(</div><div class=\"line\">          prevChildren,</div><div class=\"line\">          nextChildren,</div><div class=\"line\">          mountImages,</div><div class=\"line\">          removedNodes,</div><div class=\"line\">          transaction,</div><div class=\"line\">          <span class=\"keyword\">this</span>,</div><div class=\"line\">          <span class=\"keyword\">this</span>._hostContainerInfo,</div><div class=\"line\">          context,</div><div class=\"line\">          selfDebugID,</div><div class=\"line\">        );</div><div class=\"line\">        <span class=\"keyword\">return</span> nextChildren;</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    nextChildren = flattenStackChildren(</div><div class=\"line\">      nextNestedChildrenElements,</div><div class=\"line\">      selfDebugID,</div><div class=\"line\">    );</div><div class=\"line\">    ReactChildReconciler.updateChildren(</div><div class=\"line\">      prevChildren,</div><div class=\"line\">      nextChildren,</div><div class=\"line\">      mountImages,</div><div class=\"line\">      removedNodes,</div><div class=\"line\">      transaction,</div><div class=\"line\">      <span class=\"keyword\">this</span>,</div><div class=\"line\">      <span class=\"keyword\">this</span>._hostContainerInfo,</div><div class=\"line\">      context,</div><div class=\"line\">      selfDebugID,</div><div class=\"line\">    );</div><div class=\"line\">    <span class=\"keyword\">return</span> nextChildren;</div><div class=\"line\">  &#125;,</div></pre></td></tr></table></figure>\n<p>又得看 ReactChildReconciler.updateChildren 这个函数：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/**</span></div><div class=\"line\">   * Updates the rendered children and returns a new set of children.</div><div class=\"line\">   *</div><div class=\"line\">   * @param &#123;?object&#125; prevChildren Previously initialized set of children.</div><div class=\"line\">   * @param &#123;?object&#125; nextChildren Flat child element maps.</div><div class=\"line\">   * @param &#123;ReactReconcileTransaction&#125; transaction</div><div class=\"line\">   * @param &#123;object&#125; context</div><div class=\"line\">   * @return &#123;?object&#125; A new set of child instances.</div><div class=\"line\">   * @internal</div><div class=\"line\">   */</div><div class=\"line\">  updateChildren: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span></span></div><div class=\"line\">    prevChildren,</div><div class=\"line\">    nextChildren,</div><div class=\"line\">    mountImages,</div><div class=\"line\">    removedNodes,</div><div class=\"line\">    transaction,</div><div class=\"line\">    hostParent,</div><div class=\"line\">    hostContainerInfo,</div><div class=\"line\">    context,</div><div class=\"line\">    selfDebugID, <span class=\"regexp\">//</span> <span class=\"number\">0</span> in production and for roots</div><div class=\"line\">  ) &#123;</div><div class=\"line\">    <span class=\"comment\">// We currently don't have a way to track moves here but if we use iterators</span></div><div class=\"line\">    <span class=\"comment\">// instead of for..in we can zip the iterators and check if an item has</span></div><div class=\"line\">    <span class=\"comment\">// moved.</span></div><div class=\"line\">    <span class=\"comment\">// <span class=\"doctag\">TODO:</span> If nothing has changed, return the prevChildren object so that we</span></div><div class=\"line\">    <span class=\"comment\">// can quickly bailout if nothing has changed.</span></div><div class=\"line\">    <span class=\"keyword\">if</span> (!nextChildren &amp;&amp; !prevChildren) &#123;</div><div class=\"line\">      <span class=\"keyword\">return</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">var</span> name;</div><div class=\"line\">    <span class=\"keyword\">var</span> prevChild;</div><div class=\"line\">    <span class=\"keyword\">for</span> (name <span class=\"keyword\">in</span> nextChildren) &#123;</div><div class=\"line\">      <span class=\"keyword\">if</span> (!nextChildren.hasOwnProperty(name)) &#123;</div><div class=\"line\">        <span class=\"keyword\">continue</span>;</div><div class=\"line\">      &#125;</div><div class=\"line\">      prevChild = prevChildren &amp;&amp; prevChildren[name];</div><div class=\"line\">      <span class=\"keyword\">var</span> prevElement = prevChild &amp;&amp; prevChild._currentElement;</div><div class=\"line\">      <span class=\"keyword\">var</span> nextElement = nextChildren[name];</div><div class=\"line\">      <span class=\"keyword\">if</span> (</div><div class=\"line\">        prevChild != <span class=\"literal\">null</span> &amp;&amp;</div><div class=\"line\">        shouldUpdateReactComponent(prevElement, nextElement)</div><div class=\"line\">      ) &#123;</div><div class=\"line\">        ReactReconciler.receiveComponent(</div><div class=\"line\">          prevChild,</div><div class=\"line\">          nextElement,</div><div class=\"line\">          transaction,</div><div class=\"line\">          context,</div><div class=\"line\">        );</div><div class=\"line\">        nextChildren[name] = prevChild;</div><div class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">        <span class=\"comment\">// The child must be instantiated before it's mounted.</span></div><div class=\"line\">        <span class=\"keyword\">var</span> nextChildInstance = instantiateReactComponent(nextElement, <span class=\"literal\">true</span>);</div><div class=\"line\">        nextChildren[name] = nextChildInstance;</div><div class=\"line\">        <span class=\"comment\">// Creating mount image now ensures refs are resolved in right order</span></div><div class=\"line\">        <span class=\"comment\">// (see https://github.com/facebook/react/pull/7101 for explanation).</span></div><div class=\"line\">        <span class=\"keyword\">var</span> nextChildMountImage = ReactReconciler.mountComponent(</div><div class=\"line\">          nextChildInstance,</div><div class=\"line\">          transaction,</div><div class=\"line\">          hostParent,</div><div class=\"line\">          hostContainerInfo,</div><div class=\"line\">          context,</div><div class=\"line\">          selfDebugID,</div><div class=\"line\">        );</div><div class=\"line\">        mountImages.push(nextChildMountImage);</div><div class=\"line\">        <span class=\"keyword\">if</span> (prevChild) &#123;</div><div class=\"line\">          removedNodes[name] = ReactReconciler.getHostNode(prevChild);</div><div class=\"line\">          ReactReconciler.unmountComponent(</div><div class=\"line\">            prevChild,</div><div class=\"line\">            <span class=\"literal\">false</span> <span class=\"comment\">/* safely */</span>,</div><div class=\"line\">            <span class=\"literal\">false</span> <span class=\"comment\">/* skipLifecycle */</span>,</div><div class=\"line\">          );</div><div class=\"line\">        &#125;</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"comment\">// Unmount children that are no longer present.</span></div><div class=\"line\">    <span class=\"keyword\">for</span> (name <span class=\"keyword\">in</span> prevChildren) &#123;</div><div class=\"line\">      <span class=\"keyword\">if</span> (</div><div class=\"line\">        prevChildren.hasOwnProperty(name) &amp;&amp;</div><div class=\"line\">        !(nextChildren &amp;&amp; nextChildren.hasOwnProperty(name))</div><div class=\"line\">      ) &#123;</div><div class=\"line\">        prevChild = prevChildren[name];</div><div class=\"line\">        removedNodes[name] = ReactReconciler.getHostNode(prevChild);</div><div class=\"line\">        ReactReconciler.unmountComponent(</div><div class=\"line\">          prevChild,</div><div class=\"line\">          <span class=\"literal\">false</span> <span class=\"comment\">/* safely */</span>,</div><div class=\"line\">          <span class=\"literal\">false</span> <span class=\"comment\">/* skipLifecycle */</span>,</div><div class=\"line\">        );</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;,</div></pre></td></tr></table></figure></p>\n<p>到这里基本上结束了，这个函数会遍历所有 children，然后对其调用 ReactReconciler.receiveComponent（如果只是更新的话）或者 直接走 mount 新节点／unmount 旧节点的流程。</p>\n<h2 id=\"更新触发起点\"><a href=\"#更新触发起点\" class=\"headerlink\" title=\"更新触发起点\"></a>更新触发起点</h2><p>现在有一个重要的问题其实还没解决，那就是哪里是更新触发的起点，即究竟是通过哪一个函数触发了更新（也就是说调用了 performUpdateIfnecessary 这个函数）:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">runBatchedUpdates</span>(<span class=\"params\">transaction</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">var</span> len = transaction.dirtyComponentsLength;</div><div class=\"line\">  invariant(</div><div class=\"line\">    len === dirtyComponents.length,</div><div class=\"line\">    <span class=\"string\">\"Expected flush transaction's stored dirty-components length (%s) to \"</span> +</div><div class=\"line\">      <span class=\"string\">'match dirty-components array length (%s).'</span>,</div><div class=\"line\">    len,</div><div class=\"line\">    dirtyComponents.length,</div><div class=\"line\">  );</div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">// Since reconciling a component higher in the owner hierarchy usually (not</span></div><div class=\"line\">  <span class=\"comment\">// always -- see shouldComponentUpdate()) will reconcile children, reconcile</span></div><div class=\"line\">  <span class=\"comment\">// them before their children by sorting the array.</span></div><div class=\"line\">  dirtyComponents.sort(mountOrderComparator);</div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">// Any updates enqueued while reconciling must be performed after this entire</span></div><div class=\"line\">  <span class=\"comment\">// batch. Otherwise, if dirtyComponents is [A, B] where A has children B and</span></div><div class=\"line\">  <span class=\"comment\">// C, B could update twice in a single batch if C's render enqueues an update</span></div><div class=\"line\">  <span class=\"comment\">// to B (since B would have already updated, we should skip it, and the only</span></div><div class=\"line\">  <span class=\"comment\">// way we can know to do so is by checking the batch counter).</span></div><div class=\"line\">  updateBatchNumber++;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; len; i++) &#123;</div><div class=\"line\">    <span class=\"comment\">// If a component is unmounted before pending changes apply, it will still</span></div><div class=\"line\">    <span class=\"comment\">// be here, but we assume that it has cleared its _pendingCallbacks and</span></div><div class=\"line\">    <span class=\"comment\">// that performUpdateIfNecessary is a noop.</span></div><div class=\"line\">    <span class=\"keyword\">var</span> component = dirtyComponents[i];</div><div class=\"line\"></div><div class=\"line\">    ReactReconciler.performUpdateIfNecessary(</div><div class=\"line\">      component,</div><div class=\"line\">      transaction.reconcileTransaction,</div><div class=\"line\">      updateBatchNumber,</div><div class=\"line\">    );</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>然后再向上追溯:<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> flushBatchedUpdates = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"comment\">// ReactUpdatesFlushTransaction's wrappers will clear the dirtyComponents</span></div><div class=\"line\">  <span class=\"comment\">// array and perform any updates enqueued by mount-ready handlers (i.e.,</span></div><div class=\"line\">  <span class=\"comment\">// componentDidUpdate) but we need to check here too in order to catch</span></div><div class=\"line\">  <span class=\"comment\">// updates enqueued by setState callbacks.</span></div><div class=\"line\">  <span class=\"keyword\">while</span> (dirtyComponents.length) &#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> transaction = ReactUpdatesFlushTransaction.getPooled();</div><div class=\"line\">    transaction.perform(runBatchedUpdates, <span class=\"literal\">null</span>, transaction);</div><div class=\"line\">    ReactUpdatesFlushTransaction.release(transaction);</div><div class=\"line\">  &#125;</div></pre></td></tr></table></figure></p>\n<p>发现在 ReactDefaultBatchingStrategy 这个文件中:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> RESET_BATCHED_UPDATES = &#123;</div><div class=\"line\">  <span class=\"attr\">initialize</span>: emptyFunction,</div><div class=\"line\">  <span class=\"attr\">close</span>: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    ReactDefaultBatchingStrategy.isBatchingUpdates = <span class=\"literal\">false</span>;</div><div class=\"line\">  &#125;,</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> FLUSH_BATCHED_UPDATES = &#123;</div><div class=\"line\">  <span class=\"attr\">initialize</span>: emptyFunction,</div><div class=\"line\">  <span class=\"attr\">close</span>: ReactUpdates.flushBatchedUpdates.bind(ReactUpdates),</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> TRANSACTION_WRAPPERS = [FLUSH_BATCHED_UPDATES, RESET_BATCHED_UPDATES];</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">ReactDefaultBatchingStrategyTransaction</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">this</span>.reinitializeTransaction();</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">Object</span>.assign(ReactDefaultBatchingStrategyTransaction.prototype, Transaction, &#123;</div><div class=\"line\">  <span class=\"attr\">getTransactionWrappers</span>: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> TRANSACTION_WRAPPERS;</div><div class=\"line\">  &#125;,</div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> transaction = <span class=\"keyword\">new</span> ReactDefaultBatchingStrategyTransaction();</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> ReactDefaultBatchingStrategy = &#123;</div><div class=\"line\">  <span class=\"attr\">isBatchingUpdates</span>: <span class=\"literal\">false</span>,</div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">/**</span></div><div class=\"line\">   * Call the provided function in a context within which calls to `setState`</div><div class=\"line\">   * and friends are batched such that components aren't updated unnecessarily.</div><div class=\"line\">   */</div><div class=\"line\">  batchedUpdates: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">callback, a, b, c, d, e</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> alreadyBatchingUpdates = ReactDefaultBatchingStrategy.isBatchingUpdates;</div><div class=\"line\"></div><div class=\"line\">    ReactDefaultBatchingStrategy.isBatchingUpdates = <span class=\"literal\">true</span>;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// The code is written this way to avoid extra allocations</span></div><div class=\"line\">    <span class=\"keyword\">if</span> (alreadyBatchingUpdates) &#123;</div><div class=\"line\">      <span class=\"keyword\">return</span> callback(a, b, c, d, e);</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">      <span class=\"keyword\">return</span> transaction.perform(callback, <span class=\"literal\">null</span>, a, b, c, d, e);</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;,</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">module</span>.exports = ReactDefaultBatchingStrategy;</div></pre></td></tr></table></figure>\n<p>react 很经典的一个 transaction 处理，然后再去找 ReactDefaultBatchingStrategy 的使用，由于 DOM 和 Native 的应用场景不同，这个 Strategy 是动态插入的，我们可以看 DOM 的场景：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// ReactDOMStackInjection.js</span></div><div class=\"line\"><span class=\"keyword\">var</span> alreadyInjected = <span class=\"literal\">false</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">inject</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">if</span> (alreadyInjected) &#123;</div><div class=\"line\">    <span class=\"comment\">// <span class=\"doctag\">TODO:</span> This is currently true because these injections are shared between</span></div><div class=\"line\">    <span class=\"comment\">// the client and the server package. They should be built independently</span></div><div class=\"line\">    <span class=\"comment\">// and not share any injection state. Then this problem will be solved.</span></div><div class=\"line\">    <span class=\"keyword\">return</span>;</div><div class=\"line\">  &#125;</div><div class=\"line\">  alreadyInjected = <span class=\"literal\">true</span>;</div><div class=\"line\"></div><div class=\"line\">  ReactGenericBatching.injection.injectStackBatchedUpdates(</div><div class=\"line\">    ReactUpdates.batchedUpdates,</div><div class=\"line\">  );</div><div class=\"line\"></div><div class=\"line\">  ReactHostComponent.injection.injectGenericComponentClass(ReactDOMComponent);</div><div class=\"line\"></div><div class=\"line\">  ReactHostComponent.injection.injectTextComponentClass(ReactDOMTextComponent);</div><div class=\"line\"></div><div class=\"line\">  ReactEmptyComponent.injection.injectEmptyComponentFactory(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span></span></div><div class=\"line\">    instantiate,</div><div class=\"line\">  ) &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> ReactDOMEmptyComponent(instantiate);</div><div class=\"line\">  &#125;);</div><div class=\"line\"></div><div class=\"line\">  ReactUpdates.injection.injectReconcileTransaction(ReactReconcileTransaction);</div><div class=\"line\">  <span class=\"comment\">/*********this-line*****************/</span></div><div class=\"line\">  ReactUpdates.injection.injectBatchingStrategy(ReactDefaultBatchingStrategy);</div><div class=\"line\">  <span class=\"comment\">/*********this-line*****************/</span></div><div class=\"line\"></div><div class=\"line\">  ReactComponentEnvironment.injection.injectEnvironment(</div><div class=\"line\">    ReactComponentBrowserEnvironment,</div><div class=\"line\">  );</div><div class=\"line\"></div><div class=\"line\">  findDOMNode._injectStack(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">inst</span>) </span>&#123;</div><div class=\"line\">    inst = getHostComponentFromComposite(inst);</div><div class=\"line\">    <span class=\"keyword\">return</span> inst ? ReactDOMComponentTree.getNodeFromInstance(inst) : <span class=\"literal\">null</span>;</div><div class=\"line\">  &#125;);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</div><div class=\"line\">  <span class=\"attr\">inject</span>: inject,</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>然后就去看 ReactUpdates 的 injection:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> ReactUpdatesInjection = &#123;</div><div class=\"line\">  <span class=\"attr\">injectReconcileTransaction</span>: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">ReconcileTransaction</span>) </span>&#123;</div><div class=\"line\">    invariant(</div><div class=\"line\">      ReconcileTransaction,</div><div class=\"line\">      <span class=\"string\">'ReactUpdates: must provide a reconcile transaction class'</span>,</div><div class=\"line\">    );</div><div class=\"line\">    ReactUpdates.ReactReconcileTransaction = ReconcileTransaction;</div><div class=\"line\">  &#125;,</div><div class=\"line\"></div><div class=\"line\">  <span class=\"attr\">injectBatchingStrategy</span>: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">_batchingStrategy</span>) </span>&#123;</div><div class=\"line\">    invariant(</div><div class=\"line\">      _batchingStrategy,</div><div class=\"line\">      <span class=\"string\">'ReactUpdates: must provide a batching strategy'</span>,</div><div class=\"line\">    );</div><div class=\"line\">    invariant(</div><div class=\"line\">      <span class=\"keyword\">typeof</span> _batchingStrategy.batchedUpdates === <span class=\"string\">'function'</span>,</div><div class=\"line\">      <span class=\"string\">'ReactUpdates: must provide a batchedUpdates() function'</span>,</div><div class=\"line\">    );</div><div class=\"line\">    invariant(</div><div class=\"line\">      <span class=\"keyword\">typeof</span> _batchingStrategy.isBatchingUpdates === <span class=\"string\">'boolean'</span>,</div><div class=\"line\">      <span class=\"string\">'ReactUpdates: must provide an isBatchingUpdates boolean attribute'</span>,</div><div class=\"line\">    );</div><div class=\"line\">    batchingStrategy = _batchingStrategy;</div><div class=\"line\">  &#125;,</div><div class=\"line\"></div><div class=\"line\">  <span class=\"attr\">getBatchingStrategy</span>: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> batchingStrategy;</div><div class=\"line\">  &#125;,</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//...</span></div><div class=\"line\"><span class=\"keyword\">var</span> ReactUpdates = &#123;</div><div class=\"line\">  <span class=\"comment\">/**</span></div><div class=\"line\">   * React references `ReactReconcileTransaction` using this property in order</div><div class=\"line\">   * to allow dependency injection.</div><div class=\"line\">   *</div><div class=\"line\">   * @internal</div><div class=\"line\">   */</div><div class=\"line\">  ReactReconcileTransaction: <span class=\"literal\">null</span>,</div><div class=\"line\"></div><div class=\"line\">  <span class=\"attr\">batchedUpdates</span>: batchedUpdates,</div><div class=\"line\">  <span class=\"attr\">enqueueUpdate</span>: enqueueUpdate,</div><div class=\"line\">  <span class=\"attr\">flushBatchedUpdates</span>: flushBatchedUpdates,</div><div class=\"line\">  <span class=\"attr\">injection</span>: ReactUpdatesInjection,</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>这个时候，需要把调用栈反过来看一下：<br>ReactUpdates.injection inject 了 ReactDefaultBatchingUpdates， 而 ReactDefaultBatchingUpdates 是一个 transaction，在其中一个 tansaction_wrapper 中，调用了 ReactUpdates.flushBatchedUpdates，然后在 flushBatchedUpdates 中又调用了 runBatchedUpdates 这个函数，而这个函数直接调用了 ReactReconciler 的 performUpdateIfNecessary，这个函数又把 performUpdateIfNecessary 的具体任务 delegate 到具体的 instance。</p>\n<p>那么接下来应该如何继续探究下去呢？继续往上追溯，ReactUpdatesInjection 中提供了一个接口 getBatchingStrategy，就顺着它就行了。但是没发现有用的信息。</p>\n<p>这个时候，我们在从 setState 开始看起:<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">ReactComponent.prototype.setState = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">partialState, callback</span>) </span>&#123;</div><div class=\"line\">  invariant(</div><div class=\"line\">    <span class=\"keyword\">typeof</span> partialState === <span class=\"string\">'object'</span> ||</div><div class=\"line\">      <span class=\"keyword\">typeof</span> partialState === <span class=\"string\">'function'</span> ||</div><div class=\"line\">      partialState == <span class=\"literal\">null</span>,</div><div class=\"line\">    <span class=\"string\">'setState(...): takes an object of state variables to update or a '</span> +</div><div class=\"line\">      <span class=\"string\">'function which returns an object of state variables.'</span>,</div><div class=\"line\">  );</div><div class=\"line\">  <span class=\"keyword\">this</span>.updater.enqueueSetState(<span class=\"keyword\">this</span>, partialState, callback, <span class=\"string\">'setState'</span>);</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure></p>\n<p>这个是 ReactBaseClasses，老实说不是很清楚这个 class 有什么作用，基本上函数都是空的，不过如果这个 updater 用的不是默认值呢？我们可以从 enqueueSetState 这个方法入手，有这么几个类 ReactPartialRenderer 和 ReactUpdateQueue，但是 ReactPartialRenderer 是 server rendering，所以只看 ReactUpdateQueue 即可:<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/**</span></div><div class=\"line\">   * Sets a subset of the state. This only exists because _pendingState is</div><div class=\"line\">   * internal. This provides a merging strategy that is not available to deep</div><div class=\"line\">   * properties which is confusing. <span class=\"doctag\">TODO:</span> Expose pendingState or don't use it</div><div class=\"line\">   * during the merge.</div><div class=\"line\">   *</div><div class=\"line\">   * @param &#123;ReactClass&#125; publicInstance The instance that should rerender.</div><div class=\"line\">   * @param &#123;object&#125; partialState Next partial state to be merged with state.</div><div class=\"line\">   * @param &#123;?function&#125; callback Called after state is updated.</div><div class=\"line\">   * @param &#123;?string&#125; Name of the calling function in the public API.</div><div class=\"line\">   * @internal</div><div class=\"line\">   */</div><div class=\"line\">  enqueueSetState: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span></span></div><div class=\"line\">    publicInstance,</div><div class=\"line\">    partialState,</div><div class=\"line\">    callback,</div><div class=\"line\">    callerName,</div><div class=\"line\">  ) &#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (__DEV__) &#123;</div><div class=\"line\">      ReactInstrumentation.debugTool.onSetState();</div><div class=\"line\">      warning(</div><div class=\"line\">        partialState != <span class=\"literal\">null</span>,</div><div class=\"line\">        <span class=\"string\">'setState(...): You passed an undefined or null state object; '</span> +</div><div class=\"line\">          <span class=\"string\">'instead, use forceUpdate().'</span>,</div><div class=\"line\">      );</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">var</span> internalInstance = getInternalInstanceReadyForUpdate(publicInstance);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">if</span> (!internalInstance) &#123;</div><div class=\"line\">      <span class=\"keyword\">return</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">var</span> queue =</div><div class=\"line\">      internalInstance._pendingStateQueue ||</div><div class=\"line\">      (internalInstance._pendingStateQueue = []);</div><div class=\"line\">    queue.push(partialState);</div><div class=\"line\"></div><div class=\"line\">    callback = callback === <span class=\"literal\">undefined</span> ? <span class=\"literal\">null</span> : callback;</div><div class=\"line\">    <span class=\"keyword\">if</span> (callback !== <span class=\"literal\">null</span>) &#123;</div><div class=\"line\">      <span class=\"keyword\">if</span> (__DEV__) &#123;</div><div class=\"line\">        warnOnInvalidCallback(callback, callerName);</div><div class=\"line\">      &#125;</div><div class=\"line\">      <span class=\"keyword\">if</span> (internalInstance._pendingCallbacks) &#123;</div><div class=\"line\">        internalInstance._pendingCallbacks.push(callback);</div><div class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">        internalInstance._pendingCallbacks = [callback];</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    enqueueUpdate(internalInstance);</div><div class=\"line\">  &#125;,</div></pre></td></tr></table></figure></p>\n<p>这个函数表明 partialState 会被存在 internalInstance._pendingStateQueue 中，然后会调用 enquereUpdate，这个函数实际上来自 ReactUpdates.js 中:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/**</span></div><div class=\"line\"> * Mark a component as needing a rerender, adding an optional callback to a</div><div class=\"line\"> * list of functions which will be executed once the rerender occurs.</div><div class=\"line\"> */</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">enqueueUpdate</span>(<span class=\"params\">component</span>) </span>&#123;</div><div class=\"line\">  ensureInjected();</div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">// Various parts of our code (such as ReactCompositeComponent's</span></div><div class=\"line\">  <span class=\"comment\">// _renderValidatedComponent) assume that calls to render aren't nested;</span></div><div class=\"line\">  <span class=\"comment\">// verify that that's the case. (This is called by each top-level update</span></div><div class=\"line\">  <span class=\"comment\">// function, like setState, forceUpdate, etc.; creation and</span></div><div class=\"line\">  <span class=\"comment\">// destruction of top-level components is guarded in ReactMount.)</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">if</span> (!batchingStrategy.isBatchingUpdates) &#123;</div><div class=\"line\">    batchingStrategy.batchedUpdates(enqueueUpdate, component);</div><div class=\"line\">    <span class=\"keyword\">return</span>;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  dirtyComponents.push(component);</div><div class=\"line\">  <span class=\"keyword\">if</span> (component._updateBatchNumber == <span class=\"literal\">null</span>) &#123;</div><div class=\"line\">    component._updateBatchNumber = updateBatchNumber + <span class=\"number\">1</span>;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这个 batchedUpdates 其实就是上面提供的 ReactDefaultBatchingStrategy:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> ReactDefaultBatchingStrategy = &#123;</div><div class=\"line\">  <span class=\"attr\">isBatchingUpdates</span>: <span class=\"literal\">false</span>,</div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">/**</span></div><div class=\"line\">   * Call the provided function in a context within which calls to `setState`</div><div class=\"line\">   * and friends are batched such that components aren't updated unnecessarily.</div><div class=\"line\">   */</div><div class=\"line\">  batchedUpdates: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">callback, a, b, c, d, e</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> alreadyBatchingUpdates = ReactDefaultBatchingStrategy.isBatchingUpdates;</div><div class=\"line\"></div><div class=\"line\">    ReactDefaultBatchingStrategy.isBatchingUpdates = <span class=\"literal\">true</span>;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// The code is written this way to avoid extra allocations</span></div><div class=\"line\">    <span class=\"keyword\">if</span> (alreadyBatchingUpdates) &#123;</div><div class=\"line\">      <span class=\"keyword\">return</span> callback(a, b, c, d, e);</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">      <span class=\"keyword\">return</span> transaction.perform(callback, <span class=\"literal\">null</span>, a, b, c, d, e);</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;,</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>结合两段代码来看实际上是有两种情况，一种是正在 batching，还有一种是还没开始 batching，很容易理解，但是到目前为止似乎这个 BatchingStrategy 并没有做到 batching 这个功能，暂时先不管，继续往下看，在 transaction 的 perform 完成后，肯定是要调用 其创建时定义的 wrapper，我们也即是之前提到的:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> RESET_BATCHED_UPDATES = &#123;</div><div class=\"line\">  <span class=\"attr\">initialize</span>: emptyFunction,</div><div class=\"line\">  <span class=\"attr\">close</span>: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    ReactDefaultBatchingStrategy.isBatchingUpdates = <span class=\"literal\">false</span>;</div><div class=\"line\">  &#125;,</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> FLUSH_BATCHED_UPDATES = &#123;</div><div class=\"line\">  <span class=\"attr\">initialize</span>: emptyFunction,</div><div class=\"line\">  <span class=\"attr\">close</span>: ReactUpdates.flushBatchedUpdates.bind(ReactUpdates),</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>ReactUpdates.flushBatchedUpdates 被调用了，如果再深入下去，就可以回到我们开头的部分了。</p>\n<p>目前总体看来还有一个问题，就是 setState 似乎完全不是 enqueue 的机制，但是它函数名还这么写，我们看到的是立即更新，并没有停一下再更新。<br>真的是这样吗？<br>看到这样一篇<a href=\"https://www.bennadel.com/blog/2893-setstate-state-mutation-operation-may-be-synchronous-in-reactjs.htm\" target=\"_blank\" rel=\"external\">文章</a>，文中指只有在 onClick 的实践处理中 setState 是 equeue 机制的，在 event not managed by react 中又是同步的。</p>\n<p>后来我进行断点调试，一步一步地进行两种情况的执行顺序，然后我发现，如果是通过 props 定义的事件响应，那么当使用 setState 的时候，触发的 enqueueUpdate:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">/**</span></div><div class=\"line\"> * Mark a component as needing a rerender, adding an optional callback to a</div><div class=\"line\"> * list of functions which will be executed once the rerender occurs.</div><div class=\"line\"> */</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">enqueueUpdate</span>(<span class=\"params\">component</span>) </span>&#123;</div><div class=\"line\">  ensureInjected();</div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">// Various parts of our code (such as ReactCompositeComponent's</span></div><div class=\"line\">  <span class=\"comment\">// _renderValidatedComponent) assume that calls to render aren't nested;</span></div><div class=\"line\">  <span class=\"comment\">// verify that that's the case. (This is called by each top-level update</span></div><div class=\"line\">  <span class=\"comment\">// function, like setState, forceUpdate, etc.; creation and</span></div><div class=\"line\">  <span class=\"comment\">// destruction of top-level components is guarded in ReactMount.)</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">if</span> (!batchingStrategy.isBatchingUpdates) &#123;</div><div class=\"line\">    batchingStrategy.batchedUpdates(enqueueUpdate, component);</div><div class=\"line\">    <span class=\"keyword\">return</span>;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  dirtyComponents.push(component);</div><div class=\"line\">  <span class=\"keyword\">if</span> (component._updateBatchNumber == <span class=\"literal\">null</span>) &#123;</div><div class=\"line\">    component._updateBatchNumber = updateBatchNumber + <span class=\"number\">1</span>;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>中的 batchingStrategy.isBatchingUpdates 是 true 的，也就是说 setState 本身是处于一个 update 的 transaction 中的，所以 batchingStrategy.batchedUpdates 是不会调用的，因此如果不断的 setState 就会产生 state 本身不更新，并且将传入的 partialstate 逐步 batching，最终在触发 React 的 onClick 事件中引发的外层 update transaction 的 close 函数中进行最终的 update。</p>\n","excerpt":"","more":"<h1 id=\"ReactComponent-的更新流程\"><a href=\"#ReactComponent-的更新流程\" class=\"headerlink\" title=\"ReactComponent 的更新流程\"></a>ReactComponent 的更新流程</h1><h2 id=\"如何开始\"><a href=\"#如何开始\" class=\"headerlink\" title=\"如何开始\"></a>如何开始</h2><p>我是直接通过跑一个 react 的例子发现在 setState 操作出去的时候， performUpdateIfnecessary 开始了运行。</p>\n<p>我们就从 ReactCompositeComponent 的 performUpdateIfnecessary 看起：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/**</div><div class=\"line\">  * If any of `_pendingElement`, `_pendingStateQueue`, or `_pendingForceUpdate`</div><div class=\"line\">  * is set, update the component.</div><div class=\"line\">  *</div><div class=\"line\">  * @param &#123;ReactReconcileTransaction&#125; transaction</div><div class=\"line\">  * @internal</div><div class=\"line\">  */</span></div><div class=\"line\">performUpdateIfNecessary: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">transaction</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>._pendingElement != <span class=\"literal\">null</span>) &#123;</div><div class=\"line\">    ReactReconciler.receiveComponent(</div><div class=\"line\">      <span class=\"keyword\">this</span>,</div><div class=\"line\">      <span class=\"keyword\">this</span>._pendingElement,</div><div class=\"line\">      transaction,</div><div class=\"line\">      <span class=\"keyword\">this</span>._context,</div><div class=\"line\">    );</div><div class=\"line\">  &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>._pendingStateQueue !== <span class=\"literal\">null</span> || <span class=\"keyword\">this</span>._pendingForceUpdate) &#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>.updateComponent(</div><div class=\"line\">      transaction,</div><div class=\"line\">      <span class=\"keyword\">this</span>._currentElement,</div><div class=\"line\">      <span class=\"keyword\">this</span>._currentElement,</div><div class=\"line\">      <span class=\"keyword\">this</span>._context,</div><div class=\"line\">      <span class=\"keyword\">this</span>._context,</div><div class=\"line\">    );</div><div class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> callbacks = <span class=\"keyword\">this</span>._pendingCallbacks;</div><div class=\"line\">    <span class=\"keyword\">this</span>._pendingCallbacks = <span class=\"literal\">null</span>;</div><div class=\"line\">    <span class=\"keyword\">if</span> (callbacks) &#123;</div><div class=\"line\">      <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> j = <span class=\"number\">0</span>; j &lt; callbacks.length; j++) &#123;</div><div class=\"line\">        transaction</div><div class=\"line\">          .getReactMountReady()</div><div class=\"line\">          .enqueue(callbacks[j], <span class=\"keyword\">this</span>.getPublicInstance());</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">this</span>._updateBatchNumber = <span class=\"literal\">null</span>;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这个函数发现会有几种执行情况，如果 this._pendingElement 存在的话，会直接调用 ReactReconciler.receiveComponent 来更新，如果不存在但是 _pendingStateQueue 或者 强制更新 被 set 了，那么 updateComponent 便会被调用，最后如果上述条件都没有满足，那么只会去执行嵌入的  callback。</p>\n<p>我们先看使用 updateComponent 的情况<br>首先记住 updateComponent 参数的意义：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div></pre></td><td class=\"code\"><pre><div class=\"line\">updateComponent: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></div><div class=\"line\">  transaction,</div><div class=\"line\">  prevParentElement,</div><div class=\"line\">  nextParentElement,</div><div class=\"line\">  prevUnmaskedContext,</div><div class=\"line\">  nextUnmaskedContext,</div><div class=\"line\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"comment\">//...</span></div><div class=\"line\">  <span class=\"keyword\">var</span> prevProps = prevParentElement.props;</div><div class=\"line\">  <span class=\"keyword\">var</span> nextProps = nextParentElement.props;</div><div class=\"line\">  <span class=\"comment\">//...</span></div><div class=\"line\">  <span class=\"keyword\">var</span> nextState = <span class=\"keyword\">this</span>._processPendingState(nextProps, nextContext);</div><div class=\"line\">  <span class=\"comment\">//...</span></div><div class=\"line\">  <span class=\"keyword\">if</span> (shouldUpdate) &#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>._pendingForceUpdate = <span class=\"literal\">false</span>;</div><div class=\"line\">    <span class=\"comment\">// Will set `this.props`, `this.state` and `this.context`.</span></div><div class=\"line\">    <span class=\"keyword\">this</span>._performComponentUpdate(</div><div class=\"line\">      nextParentElement,</div><div class=\"line\">      nextProps,</div><div class=\"line\">      nextState,</div><div class=\"line\">      nextContext,</div><div class=\"line\">      transaction,</div><div class=\"line\">      nextUnmaskedContext,</div><div class=\"line\">    );</div><div class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">    <span class=\"comment\">// If it's determined that a component should not update, we still want</span></div><div class=\"line\">    <span class=\"comment\">// to set props and state but we shortcut the rest of the update.</span></div><div class=\"line\">    <span class=\"keyword\">this</span>._currentElement = nextParentElement;</div><div class=\"line\">    <span class=\"keyword\">this</span>._context = nextUnmaskedContext;</div><div class=\"line\">    inst.props = nextProps;</div><div class=\"line\">    inst.state = nextState;</div><div class=\"line\">    inst.context = nextContext;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">if</span> (callbacks) &#123;</div><div class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> j = <span class=\"number\">0</span>; j &lt; callbacks.length; j++) &#123;</div><div class=\"line\">      transaction</div><div class=\"line\">        .getReactMountReady()</div><div class=\"line\">        .enqueue(callbacks[j], <span class=\"keyword\">this</span>.getPublicInstance());</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>然后注意到传入的参数是当前的 element 和 context，因此这里只是做 state 的更新。<br>this._processPendingState 这个函数会用来计算 nextState：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div></pre></td><td class=\"code\"><pre><div class=\"line\">_processPendingState: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">props, context</span>) </span>&#123;</div><div class=\"line\">   <span class=\"keyword\">var</span> inst = <span class=\"keyword\">this</span>._instance;</div><div class=\"line\">   <span class=\"keyword\">var</span> queue = <span class=\"keyword\">this</span>._pendingStateQueue;</div><div class=\"line\">   <span class=\"keyword\">var</span> replace = <span class=\"keyword\">this</span>._pendingReplaceState;</div><div class=\"line\">   <span class=\"keyword\">this</span>._pendingReplaceState = <span class=\"literal\">false</span>;</div><div class=\"line\">   <span class=\"keyword\">this</span>._pendingStateQueue = <span class=\"literal\">null</span>;</div><div class=\"line\"></div><div class=\"line\">   <span class=\"keyword\">if</span> (!queue) &#123;</div><div class=\"line\">     <span class=\"keyword\">return</span> inst.state;</div><div class=\"line\">   &#125;</div><div class=\"line\"></div><div class=\"line\">   <span class=\"keyword\">if</span> (replace &amp;&amp; queue.length === <span class=\"number\">1</span>) &#123;</div><div class=\"line\">     <span class=\"keyword\">return</span> queue[<span class=\"number\">0</span>];</div><div class=\"line\">   &#125;</div><div class=\"line\"></div><div class=\"line\">   <span class=\"keyword\">var</span> nextState = replace ? queue[<span class=\"number\">0</span>] : inst.state;</div><div class=\"line\">   <span class=\"keyword\">var</span> dontMutate = <span class=\"literal\">true</span>;</div><div class=\"line\">   <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = replace ? <span class=\"number\">1</span> : <span class=\"number\">0</span>; i &lt; queue.length; i++) &#123;</div><div class=\"line\">     <span class=\"keyword\">var</span> partial = queue[i];</div><div class=\"line\">     <span class=\"keyword\">let</span> partialState = <span class=\"keyword\">typeof</span> partial === <span class=\"string\">'function'</span></div><div class=\"line\">       ? partial.call(inst, nextState, props, context)</div><div class=\"line\">       : partial;</div><div class=\"line\">     <span class=\"keyword\">if</span> (partialState) &#123;</div><div class=\"line\">       <span class=\"keyword\">if</span> (dontMutate) &#123;</div><div class=\"line\">         dontMutate = <span class=\"literal\">false</span>;</div><div class=\"line\">         nextState = <span class=\"built_in\">Object</span>.assign(&#123;&#125;, nextState, partialState);</div><div class=\"line\">       &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">         <span class=\"built_in\">Object</span>.assign(nextState, partialState);</div><div class=\"line\">       &#125;</div><div class=\"line\">     &#125;</div><div class=\"line\">   &#125;</div><div class=\"line\"></div><div class=\"line\">   <span class=\"keyword\">return</span> nextState;</div><div class=\"line\"> &#125;,</div></pre></td></tr></table></figure>\n<p>这个函数有趣的地方在于：</p>\n<ol>\n<li>会把你所有的 setState 填入的状态融合起来，也就是说很有可能只有最后一次的 State 有效果</li>\n<li>state 也可以传入一个 function</li>\n</ol>\n<p>有了新的 state 之后，便会进入 this._performComponentUpdate 这个函数的调用：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div></pre></td><td class=\"code\"><pre><div class=\"line\">_performComponentUpdate: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></div><div class=\"line\">  nextElement,</div><div class=\"line\">  nextProps,</div><div class=\"line\">  nextState,</div><div class=\"line\">  nextContext,</div><div class=\"line\">  transaction,</div><div class=\"line\">  unmaskedContext,</div><div class=\"line\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">var</span> inst = <span class=\"keyword\">this</span>._instance;</div><div class=\"line\">  <span class=\"comment\">//...</span></div><div class=\"line\">  <span class=\"keyword\">if</span> (inst.componentWillUpdate) &#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (__DEV__) &#123;</div><div class=\"line\">      measureLifeCyclePerf(</div><div class=\"line\">        <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> inst.componentWillUpdate(nextProps, nextState, nextContext),</div><div class=\"line\">        <span class=\"keyword\">this</span>._debugID,</div><div class=\"line\">        <span class=\"string\">'componentWillUpdate'</span>,</div><div class=\"line\">      );</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">      inst.componentWillUpdate(nextProps, nextState, nextContext);</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">  <span class=\"keyword\">this</span>._currentElement = nextElement;</div><div class=\"line\">  <span class=\"keyword\">this</span>._context = unmaskedContext;</div><div class=\"line\">  inst.props = nextProps;</div><div class=\"line\">  inst.state = nextState;</div><div class=\"line\">  inst.context = nextContext;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">if</span> (inst.unstable_handleError) &#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>._updateRenderedComponentWithErrorHandling(</div><div class=\"line\">      transaction,</div><div class=\"line\">      unmaskedContext,</div><div class=\"line\">    );</div><div class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>._updateRenderedComponent(transaction, unmaskedContext);</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">//... ComponentDidUpdate</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这个函数在 componentWillUpdate 和 componentDidUpdate 之间调用了：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">this</span>._updateRenderedComponent(transaction, unmaskedContext);</div></pre></td></tr></table></figure>\n<p>我们继续看 _updateRenderedComponent:<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/**</div><div class=\"line\">  * Call the component's `render` method and update the DOM accordingly.</div><div class=\"line\">  *</div><div class=\"line\">  * @param &#123;ReactReconcileTransaction&#125; transaction</div><div class=\"line\">  * @internal</div><div class=\"line\">  */</span></div><div class=\"line\">_updateRenderedComponent: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">transaction, context</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">var</span> nextRenderedElement = <span class=\"keyword\">this</span>._renderValidatedComponent();</div><div class=\"line\">  <span class=\"keyword\">this</span>._updateRenderedComponentWithNextElement(</div><div class=\"line\">    transaction,</div><div class=\"line\">    context,</div><div class=\"line\">    nextRenderedElement,</div><div class=\"line\">    <span class=\"literal\">false</span> <span class=\"comment\">/* safely */</span>,</div><div class=\"line\">  );</div><div class=\"line\">&#125;,</div></pre></td></tr></table></figure></p>\n<p> this._renderValidatedComponent 里面表明要看 _updateRenderedComponentWithoutOwnerOrContext：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/**</div><div class=\"line\">  * @protected</div><div class=\"line\">  */</span></div><div class=\"line\">_renderValidatedComponentWithoutOwnerOrContext: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">var</span> inst = <span class=\"keyword\">this</span>._instance;</div><div class=\"line\">  <span class=\"keyword\">var</span> renderedElement;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">if</span> (__DEV__) &#123;</div><div class=\"line\">    renderedElement = measureLifeCyclePerf(</div><div class=\"line\">      <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> inst.render(),</div><div class=\"line\">      <span class=\"keyword\">this</span>._debugID,</div><div class=\"line\">      <span class=\"string\">'render'</span>,</div><div class=\"line\">    );</div><div class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">    renderedElement = inst.render();</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">if</span> (__DEV__) &#123;</div><div class=\"line\">    <span class=\"comment\">// We allow auto-mocks to proceed as if they're returning null.</span></div><div class=\"line\">    <span class=\"keyword\">if</span> (renderedElement === <span class=\"literal\">undefined</span> &amp;&amp; inst.render._isMockFunction) &#123;</div><div class=\"line\">      <span class=\"comment\">// This is probably bad practice. Consider warning here and</span></div><div class=\"line\">      <span class=\"comment\">// deprecating this convenience.</span></div><div class=\"line\">      renderedElement = <span class=\"literal\">null</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">return</span> renderedElement;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>可以看出来这个会调用 render 方法，调用了 render 方法后就会返回 一个 新的 element。</p>\n<p>再回到 _updateRenderedComponent:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/**</div><div class=\"line\">  * Call the component's `render` method and update the DOM accordingly.</div><div class=\"line\">  *</div><div class=\"line\">  * @param &#123;ReactReconcileTransaction&#125; transaction</div><div class=\"line\">  * @internal</div><div class=\"line\">  */</span></div><div class=\"line\">_updateRenderedComponent: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">transaction, context</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">var</span> nextRenderedElement = <span class=\"keyword\">this</span>._renderValidatedComponent();</div><div class=\"line\">  <span class=\"keyword\">this</span>._updateRenderedComponentWithNextElement(</div><div class=\"line\">    transaction,</div><div class=\"line\">    context,</div><div class=\"line\">    nextRenderedElement,</div><div class=\"line\">    <span class=\"literal\">false</span> <span class=\"comment\">/* safely */</span>,</div><div class=\"line\">  );</div><div class=\"line\">&#125;,</div></pre></td></tr></table></figure>\n<p>拿到了 render 出来的 element 就会调用 _updateRenderedComponentWithNextElement:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/**</div><div class=\"line\">  * Call the component's `render` method and update the DOM accordingly.</div><div class=\"line\">  *</div><div class=\"line\">  * @param &#123;ReactReconcileTransaction&#125; transaction</div><div class=\"line\">  * @internal</div><div class=\"line\">  */</span></div><div class=\"line\">_updateRenderedComponentWithNextElement: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></div><div class=\"line\">  transaction,</div><div class=\"line\">  context,</div><div class=\"line\">  nextRenderedElement,</div><div class=\"line\">  safely,</div><div class=\"line\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">var</span> prevComponentInstance = <span class=\"keyword\">this</span>._renderedComponent;</div><div class=\"line\">  <span class=\"keyword\">var</span> prevRenderedElement = prevComponentInstance._currentElement;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">//...</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">if</span> (shouldUpdateReactComponent(prevRenderedElement, nextRenderedElement)) &#123;</div><div class=\"line\">    ReactReconciler.receiveComponent(</div><div class=\"line\">      prevComponentInstance,</div><div class=\"line\">      nextRenderedElement,</div><div class=\"line\">      transaction,</div><div class=\"line\">      <span class=\"keyword\">this</span>._processChildContext(context),</div><div class=\"line\">    );</div><div class=\"line\">  &#125;</div><div class=\"line\">  <span class=\"comment\">//...</span></div></pre></td></tr></table></figure>\n<p>到这里会发现 首先调用 shouldUpdateReactComponent，注意这个和生命周期里面的 shouldComponentUpdate 不同。<br>如果返回 true，那么直接调用 ReactReconciler 的 receiveComponent 来进行更新。</p>\n<p>那么我们就先看一下 shoudlUpdateReactComponent:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/**</div><div class=\"line\">* Given a `prevElement` and `nextElement`, determines if the existing</div><div class=\"line\">* instance should be updated as opposed to being destroyed or replaced by a new</div><div class=\"line\">* instance. Both arguments are elements. This ensures that this logic can</div><div class=\"line\">* operate on stateless trees without any backing instance.</div><div class=\"line\">*</div><div class=\"line\">* @param &#123;?object&#125; prevElement</div><div class=\"line\">* @param &#123;?object&#125; nextElement</div><div class=\"line\">* @return &#123;boolean&#125; True if the existing instance should be updated.</div><div class=\"line\">* @protected</div><div class=\"line\">*/</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">shouldUpdateReactComponent</span>(<span class=\"params\">prevElement, nextElement</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">var</span> prevEmpty = prevElement === <span class=\"literal\">null</span> || prevElement === <span class=\"literal\">false</span>;</div><div class=\"line\">  <span class=\"keyword\">var</span> nextEmpty = nextElement === <span class=\"literal\">null</span> || nextElement === <span class=\"literal\">false</span>;</div><div class=\"line\">  <span class=\"keyword\">if</span> (prevEmpty || nextEmpty) &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> prevEmpty === nextEmpty;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">var</span> prevType = <span class=\"keyword\">typeof</span> prevElement;</div><div class=\"line\">  <span class=\"keyword\">var</span> nextType = <span class=\"keyword\">typeof</span> nextElement;</div><div class=\"line\">  <span class=\"keyword\">if</span> (prevType === <span class=\"string\">'string'</span> || prevType === <span class=\"string\">'number'</span>) &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> nextType === <span class=\"string\">'string'</span> || nextType === <span class=\"string\">'number'</span>;</div><div class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> (</div><div class=\"line\">      nextType === <span class=\"string\">'object'</span> &amp;&amp;</div><div class=\"line\">      prevElement.type === nextElement.type &amp;&amp;</div><div class=\"line\">      prevElement.key === nextElement.key</div><div class=\"line\">    );</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>注意这段代码的注释部分，该函数返回 true 意味着更新当前的 instance，而不是直接 destroy 掉，若是返回 false，那么就是说当前的 instance 会被销毁加替代。<br>为 true 的条件很简单：</p>\n<ol>\n<li>如果是 string 或者 number 直接返回 true</li>\n<li>如果是 object 必须保证 type 和 key 一致</li>\n</ol>\n<p>让我们在回到上层代码，考虑 shoudlUpdateReactComponent 结果为 true 的时候，ReactConciler.ReceiveComponent 的调用：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//_updateRenderedComponentWithNextElement: function</span></div><div class=\"line\">ReactReconciler.receiveComponent(</div><div class=\"line\">        prevComponentInstance,</div><div class=\"line\">        nextRenderedElement,</div><div class=\"line\">        transaction,</div><div class=\"line\">        <span class=\"keyword\">this</span>._processChildContext(context),</div><div class=\"line\">      );</div></pre></td></tr></table></figure>\n<p>这里有段 context 的处理，但是考虑到目前 context 的使用并不是很频繁，我们直接跳过。<br>我们再看一下 ReactReconciler.receiveComponent 的实现：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// ReactReconciler.receiveComponent</span></div><div class=\"line\"><span class=\"comment\">/**</div><div class=\"line\">  * Update a component using a new element.</div><div class=\"line\">  *</div><div class=\"line\">  * @param &#123;ReactComponent&#125; internalInstance</div><div class=\"line\">  * @param &#123;ReactElement&#125; nextElement</div><div class=\"line\">  * @param &#123;ReactReconcileTransaction&#125; transaction</div><div class=\"line\">  * @param &#123;object&#125; context</div><div class=\"line\">  * @internal</div><div class=\"line\">  */</span></div><div class=\"line\">receiveComponent: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></div><div class=\"line\">  internalInstance,</div><div class=\"line\">  nextElement,</div><div class=\"line\">  transaction,</div><div class=\"line\">  context,</div><div class=\"line\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">var</span> prevElement = internalInstance._currentElement;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">if</span> (nextElement === prevElement &amp;&amp; context === internalInstance._context) &#123;</div><div class=\"line\">    <span class=\"comment\">// Since elements are immutable after the owner is rendered,</span></div><div class=\"line\">    <span class=\"comment\">// we can do a cheap identity compare here to determine if this is a</span></div><div class=\"line\">    <span class=\"comment\">// superfluous reconcile. It's possible for state to be mutable but such</span></div><div class=\"line\">    <span class=\"comment\">// change should trigger an update of the owner which would recreate</span></div><div class=\"line\">    <span class=\"comment\">// the element. We explicitly check for the existence of an owner since</span></div><div class=\"line\">    <span class=\"comment\">// it's possible for an element created outside a composite to be</span></div><div class=\"line\">    <span class=\"comment\">// deeply mutated and reused.</span></div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// <span class=\"doctag\">TODO:</span> Bailing out early is just a perf optimization right?</span></div><div class=\"line\">    <span class=\"comment\">// <span class=\"doctag\">TODO:</span> Removing the return statement should affect correctness?</span></div><div class=\"line\">    <span class=\"keyword\">return</span>;</div><div class=\"line\">  &#125;</div><div class=\"line\">  <span class=\"comment\">//...</span></div><div class=\"line\">  internalInstance.receiveComponent(nextElement, transaction, context);</div><div class=\"line\">  <span class=\"comment\">//...</span></div><div class=\"line\">&#125;,</div></pre></td></tr></table></figure>\n<p>这段代码这里省略了一些 ref 的处理，不过以后也可以详细谈。<br>这里会做一次检查，会做一次 reference 的比较，如果相同，那么自然就没有必要去更新。<br>然后在使用传入的 internalInstance.receiveComponent 去做真正的更新。</p>\n<p>那么我们直接看 ReactComponent 的 receiveComponent：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">receiveComponent: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">nextElement, transaction, nextContext</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">var</span> prevElement = <span class=\"keyword\">this</span>._currentElement;</div><div class=\"line\">  <span class=\"keyword\">var</span> prevContext = <span class=\"keyword\">this</span>._context;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">this</span>._pendingElement = <span class=\"literal\">null</span>;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">this</span>.updateComponent(</div><div class=\"line\">    transaction,</div><div class=\"line\">    prevElement,</div><div class=\"line\">    nextElement,</div><div class=\"line\">    prevContext,</div><div class=\"line\">    nextContext,</div><div class=\"line\">  );</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>然后我们发现居然又回到了 updateComponent 这个函数，因此现在有两个问题：</p>\n<ol>\n<li>上次调用和这次调用那里不同？</li>\n<li>如果不同，是一种递归的话，在哪里停止？<br>第一个问题是容易回答的，肯定不同，不同之处在于 this 发生了变化，其实这个 instance 是这样来的：</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/**</div><div class=\"line\">  * Call the component's `render` method and update the DOM accordingly.</div><div class=\"line\">  *</div><div class=\"line\">  * @param &#123;ReactReconcileTransaction&#125; transaction</div><div class=\"line\">  * @internal</div><div class=\"line\">  */</span></div><div class=\"line\">_updateRenderedComponentWithNextElement: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></div><div class=\"line\">  transaction,</div><div class=\"line\">  context,</div><div class=\"line\">  nextRenderedElement,</div><div class=\"line\">  safely,</div><div class=\"line\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">var</span> prevComponentInstance = <span class=\"keyword\">this</span>._renderedComponent;</div><div class=\"line\">  <span class=\"comment\">//...</span></div></pre></td></tr></table></figure>\n<p>而 this._renderedComponent 的唯一 assignment 是在 _updateRenderedComponentWithNextElement 的另一条条件分支里面，也就是说当需要替换 component 的时候，会将产生这个 assignment：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div></pre></td><td class=\"code\"><pre><div class=\"line\">_updateRenderedComponentWithNextElement: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></div><div class=\"line\">  transaction,</div><div class=\"line\">  context,</div><div class=\"line\">  nextRenderedElement,</div><div class=\"line\">  safely,</div><div class=\"line\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">var</span> prevComponentInstance = <span class=\"keyword\">this</span>._renderedComponent;</div><div class=\"line\">  <span class=\"keyword\">var</span> prevRenderedElement = prevComponentInstance._currentElement;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">//...</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">if</span> (shouldUpdateReactComponent(prevRenderedElement, nextRenderedElement)) &#123;</div><div class=\"line\">  ReactReconciler.receiveComponent(</div><div class=\"line\">    prevComponentInstance,</div><div class=\"line\">    nextRenderedElement,</div><div class=\"line\">    transaction,</div><div class=\"line\">    <span class=\"keyword\">this</span>._processChildContext(context),</div><div class=\"line\">  );</div><div class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">  <span class=\"keyword\">var</span> oldHostNode = ReactReconciler.getHostNode(prevComponentInstance);</div><div class=\"line\">  <span class=\"keyword\">var</span> nodeType = ReactNodeTypes.getType(nextRenderedElement);</div><div class=\"line\">  <span class=\"keyword\">this</span>._renderedNodeType = nodeType;</div><div class=\"line\">  <span class=\"keyword\">var</span> child = <span class=\"keyword\">this</span>._instantiateReactComponent(</div><div class=\"line\">    nextRenderedElement,</div><div class=\"line\">    nodeType !== ReactNodeTypes.EMPTY <span class=\"comment\">/* shouldHaveDebugID */</span>,</div><div class=\"line\">  );</div><div class=\"line\">  <span class=\"keyword\">this</span>._renderedComponent = child;</div><div class=\"line\">  <span class=\"comment\">//...</span></div></pre></td></tr></table></figure>\n<p>这里试想如果是第一次进入这个函数，this._renderedComponent 肯定是 undefined，而 nextRenderedElement 肯定不是空的，也就说一定会进入第二个分支，然后将新的 element 实例化成新的 this._renderedComponent。<br>因此所有的秘密都停留在了 this._instantiateReactComponent 里面了。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/**</div><div class=\"line\"> * Given a ReactNode, create an instance that will actually be mounted.</div><div class=\"line\"> *</div><div class=\"line\"> * @param &#123;ReactNode&#125; node</div><div class=\"line\"> * @param &#123;boolean&#125; shouldHaveDebugID</div><div class=\"line\"> * @return &#123;object&#125; A new instance of the element's constructor.</div><div class=\"line\"> * @protected</div><div class=\"line\"> */</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">instantiateReactComponent</span>(<span class=\"params\">node, shouldHaveDebugID</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">var</span> instance;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">if</span> (node === <span class=\"literal\">null</span> || node === <span class=\"literal\">false</span>) &#123;</div><div class=\"line\">    instance = ReactEmptyComponent.create(instantiateReactComponent);</div><div class=\"line\">  &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> node === <span class=\"string\">'object'</span>) &#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> element = node;</div><div class=\"line\">    <span class=\"keyword\">var</span> type = element.type;</div><div class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> type !== <span class=\"string\">'function'</span> &amp;&amp; <span class=\"keyword\">typeof</span> type !== <span class=\"string\">'string'</span>) &#123;</div><div class=\"line\">      <span class=\"keyword\">var</span> info = <span class=\"string\">''</span>;</div><div class=\"line\">      <span class=\"keyword\">if</span> (__DEV__) &#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (</div><div class=\"line\">          type === <span class=\"literal\">undefined</span> ||</div><div class=\"line\">          (<span class=\"keyword\">typeof</span> type === <span class=\"string\">'object'</span> &amp;&amp;</div><div class=\"line\">            type !== <span class=\"literal\">null</span> &amp;&amp;</div><div class=\"line\">            <span class=\"built_in\">Object</span>.keys(type).length === <span class=\"number\">0</span>)</div><div class=\"line\">        ) &#123;</div><div class=\"line\">          info +=</div><div class=\"line\">            <span class=\"string\">' You likely forgot to export your component from the file '</span> +</div><div class=\"line\">            <span class=\"string\">\"it's defined in.\"</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\">      &#125;</div><div class=\"line\">      info += getDeclarationErrorAddendum(element._owner);</div><div class=\"line\">      invariant(</div><div class=\"line\">        <span class=\"literal\">false</span>,</div><div class=\"line\">        <span class=\"string\">'Element type is invalid: expected a string (for built-in components) '</span> +</div><div class=\"line\">          <span class=\"string\">'or a class/function (for composite components) but got: %s.%s'</span>,</div><div class=\"line\">        type == <span class=\"literal\">null</span> ? type : <span class=\"keyword\">typeof</span> type,</div><div class=\"line\">        info,</div><div class=\"line\">      );</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// Special case string values</span></div><div class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> element.type === <span class=\"string\">'string'</span>) &#123;</div><div class=\"line\">      instance = ReactHostComponent.createInternalComponent(element);</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (isInternalComponentType(element.type)) &#123;</div><div class=\"line\">      <span class=\"comment\">// This is temporarily available for custom components that are not string</span></div><div class=\"line\">      <span class=\"comment\">// representations. I.e. ART. Once those are updated to use the string</span></div><div class=\"line\">      <span class=\"comment\">// representation, we can drop this code path.</span></div><div class=\"line\">      instance = <span class=\"keyword\">new</span> element.type(element);</div><div class=\"line\"></div><div class=\"line\">      <span class=\"comment\">// We renamed this. Allow the old name for compat. :(</span></div><div class=\"line\">      <span class=\"keyword\">if</span> (!instance.getHostNode) &#123;</div><div class=\"line\">        instance.getHostNode = instance.getNativeNode;</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">      instance = <span class=\"keyword\">new</span> ReactCompositeComponentWrapper(element);</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> node === <span class=\"string\">'string'</span> || <span class=\"keyword\">typeof</span> node === <span class=\"string\">'number'</span>) &#123;</div><div class=\"line\">    instance = ReactHostComponent.createInstanceForText(node);</div><div class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">    invariant(<span class=\"literal\">false</span>, <span class=\"string\">'Encountered invalid React node of type %s'</span>, <span class=\"keyword\">typeof</span> node);</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">if</span> (__DEV__) &#123;</div><div class=\"line\">    warning(</div><div class=\"line\">      <span class=\"keyword\">typeof</span> instance.mountComponent === <span class=\"string\">'function'</span> &amp;&amp;</div><div class=\"line\">        <span class=\"keyword\">typeof</span> instance.receiveComponent === <span class=\"string\">'function'</span> &amp;&amp;</div><div class=\"line\">        <span class=\"keyword\">typeof</span> instance.getHostNode === <span class=\"string\">'function'</span> &amp;&amp;</div><div class=\"line\">        <span class=\"keyword\">typeof</span> instance.unmountComponent === <span class=\"string\">'function'</span>,</div><div class=\"line\">      <span class=\"string\">'Only React Components can be mounted.'</span>,</div><div class=\"line\">    );</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">// These two fields are used by the DOM and ART diffing algorithms</span></div><div class=\"line\">  <span class=\"comment\">// respectively. Instead of using expandos on components, we should be</span></div><div class=\"line\">  <span class=\"comment\">// storing the state needed by the diffing algorithms elsewhere.</span></div><div class=\"line\">  instance._mountIndex = <span class=\"number\">0</span>;</div><div class=\"line\">  instance._mountImage = <span class=\"literal\">null</span>;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">if</span> (__DEV__) &#123;</div><div class=\"line\">    instance._debugID = shouldHaveDebugID ? nextDebugID++ : <span class=\"number\">0</span>;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">// Internal instances should fully constructed at this point, so they should</span></div><div class=\"line\">  <span class=\"comment\">// not get any new fields added to them at this point.</span></div><div class=\"line\">  <span class=\"keyword\">if</span> (__DEV__) &#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">Object</span>.preventExtensions) &#123;</div><div class=\"line\">      <span class=\"built_in\">Object</span>.preventExtensions(instance);</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">return</span> instance;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这段代码其实简单的看来就是处理三种不同的 ReactElement：</p>\n<ol>\n<li>string, number =&gt; 直接使用 ReactHostComponent.createInstanceForText 来进行实例化</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//...</span></div><div class=\"line\"> <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> node === <span class=\"string\">'string'</span> || <span class=\"keyword\">typeof</span> node === <span class=\"string\">'number'</span>) &#123;</div><div class=\"line\">    instance = ReactHostComponent.createInstanceForText(node);</div><div class=\"line\"><span class=\"comment\">//...</span></div></pre></td></tr></table></figure>\n<ol>\n<li>是 object 并且其 type 字段又是 string，那么就会使用 ReactHostComponent.createInternalComponent 来进行实例化</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//...</span></div><div class=\"line\"> <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> element.type === <span class=\"string\">'string'</span>) &#123;</div><div class=\"line\">      instance = ReactHostComponent.createInternalComponent(element);</div><div class=\"line\">    &#125;</div><div class=\"line\"><span class=\"comment\">//...</span></div></pre></td></tr></table></figure>\n<ol>\n<li>是 CompositeElement，会使用 ReactCompositeComponentWrapper 来进行实例化，其中会做一次检查，检查是否是是自定义的 type（只要定义了 mountComponent 和 receiveComponent 就行了）</li>\n</ol>\n<p>因此在回到我们之前的问题：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div></pre></td><td class=\"code\"><pre><div class=\"line\">_updateRenderedComponentWithNextElement: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></div><div class=\"line\">  transaction,</div><div class=\"line\">  context,</div><div class=\"line\">  nextRenderedElement,</div><div class=\"line\">  safely,</div><div class=\"line\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">var</span> prevComponentInstance = <span class=\"keyword\">this</span>._renderedComponent;</div><div class=\"line\">  <span class=\"keyword\">var</span> prevRenderedElement = prevComponentInstance._currentElement;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">//...</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">if</span> (shouldUpdateReactComponent(prevRenderedElement, nextRenderedElement)) &#123;</div><div class=\"line\">  ReactReconciler.receiveComponent(</div><div class=\"line\">    prevComponentInstance,</div><div class=\"line\">    nextRenderedElement,</div><div class=\"line\">    transaction,</div><div class=\"line\">    <span class=\"keyword\">this</span>._processChildContext(context),</div><div class=\"line\">  );</div><div class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">  <span class=\"keyword\">var</span> oldHostNode = ReactReconciler.getHostNode(prevComponentInstance);</div><div class=\"line\">  <span class=\"keyword\">var</span> nodeType = ReactNodeTypes.getType(nextRenderedElement);</div><div class=\"line\">  <span class=\"keyword\">this</span>._renderedNodeType = nodeType;</div><div class=\"line\">  <span class=\"keyword\">var</span> child = <span class=\"keyword\">this</span>._instantiateReactComponent(</div><div class=\"line\">    nextRenderedElement,</div><div class=\"line\">    nodeType !== ReactNodeTypes.EMPTY <span class=\"comment\">/* shouldHaveDebugID */</span>,</div><div class=\"line\">  );</div><div class=\"line\">  <span class=\"keyword\">this</span>._renderedComponent = child;</div><div class=\"line\">  <span class=\"comment\">//...</span></div></pre></td></tr></table></figure>\n<p>这个 child 实际上就是被实例化出来的一个新的 Component（注意为什么是 child，是因为 nextRenderedElement 是用当前 Component 的 render 函数形成的），所以 第一个问题解决了：</p>\n<blockquote>\n<ol>\n<li>上次调用和这次调用那里不同？</li>\n<li>如果不同，是一种递归的话，在哪里停止？</li>\n</ol>\n</blockquote>\n<p>那么第二个问题是怎么解决的呢？<br>直观上看这个递归的结束很简单，就是最后没有了 child，所以这里就不深究了。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//...</span></div><div class=\"line\"><span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (isInternalComponentType(element.type)) &#123;</div><div class=\"line\">      <span class=\"comment\">// This is temporarily available for custom components that are not string</span></div><div class=\"line\">      <span class=\"comment\">// representations. I.e. ART. Once those are updated to use the string</span></div><div class=\"line\">      <span class=\"comment\">// representation, we can drop this code path.</span></div><div class=\"line\">      instance = <span class=\"keyword\">new</span> element.type(element);</div><div class=\"line\"></div><div class=\"line\">      <span class=\"comment\">// We renamed this. Allow the old name for compat. :(</span></div><div class=\"line\">      <span class=\"keyword\">if</span> (!instance.getHostNode) &#123;</div><div class=\"line\">        instance.getHostNode = instance.getNativeNode;</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">      instance = <span class=\"keyword\">new</span> ReactCompositeComponentWrapper(element);</div><div class=\"line\">    &#125;</div><div class=\"line\"><span class=\"comment\">//...</span></div></pre></td></tr></table></figure>\n<p>再回到之前的 _updateRenderedComponentWithNextElement，把接下来的处理看掉：</p>\n  <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div></pre></td><td class=\"code\"><pre><div class=\"line\">  <span class=\"comment\">// _updateRenderedComponentWithNextElement: function()</span></div><div class=\"line\">  <span class=\"keyword\">if</span> (shouldUpdateReactComponent(prevRenderedElement, nextRenderedElement)) &#123;</div><div class=\"line\">    ReactReconciler.receiveComponent(</div><div class=\"line\">      prevComponentInstance,</div><div class=\"line\">      nextRenderedElement,</div><div class=\"line\">      transaction,</div><div class=\"line\">      <span class=\"keyword\">this</span>._processChildContext(context),</div><div class=\"line\">    );</div><div class=\"line\">  &#125; </div><div class=\"line\">  <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> oldHostNode = ReactReconciler.getHostNode(prevComponentInstance);</div><div class=\"line\">    <span class=\"keyword\">var</span> nodeType = ReactNodeTypes.getType(nextRenderedElement);</div><div class=\"line\">    <span class=\"keyword\">this</span>._renderedNodeType = nodeType;</div><div class=\"line\">    <span class=\"keyword\">var</span> child = <span class=\"keyword\">this</span>._instantiateReactComponent(</div><div class=\"line\">      nextRenderedElement,</div><div class=\"line\">      nodeType !== ReactNodeTypes.EMPTY <span class=\"comment\">/* shouldHaveDebugID */</span>,</div><div class=\"line\">    );</div><div class=\"line\">    <span class=\"keyword\">this</span>._renderedComponent = child;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">var</span> nextMarkup = ReactReconciler.mountComponent(</div><div class=\"line\">      child,</div><div class=\"line\">      transaction,</div><div class=\"line\">      <span class=\"keyword\">this</span>._hostParent,</div><div class=\"line\">      <span class=\"keyword\">this</span>._hostContainerInfo,</div><div class=\"line\">      <span class=\"keyword\">this</span>._processChildContext(context),</div><div class=\"line\">      debugID,</div><div class=\"line\">    );</div><div class=\"line\"></div><div class=\"line\">    ReactReconciler.unmountComponent(</div><div class=\"line\">      prevComponentInstance,</div><div class=\"line\">      safely,</div><div class=\"line\">      <span class=\"literal\">false</span> <span class=\"comment\">/* skipLifecycle */</span>,</div><div class=\"line\">    );</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">if</span> (__DEV__) &#123;</div><div class=\"line\">      <span class=\"keyword\">if</span> (debugID !== <span class=\"number\">0</span>) &#123;</div><div class=\"line\">        <span class=\"keyword\">var</span> childDebugIDs = child._debugID !== <span class=\"number\">0</span> ? [child._debugID] : [];</div><div class=\"line\">        ReactInstrumentation.debugTool.onSetChildren(debugID, childDebugIDs);</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">this</span>._replaceNodeWithMarkup(</div><div class=\"line\">      oldHostNode,</div><div class=\"line\">      nextMarkup,</div><div class=\"line\">      prevComponentInstance,</div><div class=\"line\">    );</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;,</div></pre></td></tr></table></figure>\n<p>这块总的来说就是在 shouldUpdateReactComponent 返回 false 的时候：</p>\n<ol>\n<li>保存老的 hostNode</li>\n<li>instantiate 新的 ReactComponent</li>\n<li>mount 这个新的 instance，拿到 markup</li>\n<li>unmount 旧的 instance</li>\n<li>重新渲染 hostNode 下的 dom</li>\n</ol>\n<h2 id=\"ReactDOMComponent\"><a href=\"#ReactDOMComponent\" class=\"headerlink\" title=\"ReactDOMComponent\"></a>ReactDOMComponent</h2><p>其实 ReactCompositeComponent 不会做具体的更新的。<br>在 performUpdateIfNecessary 中的第一个条件表明，如果存在 pendingElement 那么会直接调用 ReactReconciler.receiveComponent。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/**</div><div class=\"line\">  * If any of `_pendingElement`, `_pendingStateQueue`, or `_pendingForceUpdate`</div><div class=\"line\">  * is set, update the component.</div><div class=\"line\">  *</div><div class=\"line\">  * @param &#123;ReactReconcileTransaction&#125; transaction</div><div class=\"line\">  * @internal</div><div class=\"line\">  */</span></div><div class=\"line\">performUpdateIfNecessary: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">transaction</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>._pendingElement != <span class=\"literal\">null</span>) &#123;</div><div class=\"line\">    ReactReconciler.receiveComponent(</div><div class=\"line\">      <span class=\"keyword\">this</span>,</div><div class=\"line\">      <span class=\"keyword\">this</span>._pendingElement,</div><div class=\"line\">      transaction,</div><div class=\"line\">      <span class=\"keyword\">this</span>._context,</div><div class=\"line\">    );</div><div class=\"line\">  &#125;</div></pre></td></tr></table></figure>\n<p>而 ReactReconciler.receiveComponent 中的具体做法是：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// ReactReconciler.receiveComponent</span></div><div class=\"line\"><span class=\"comment\">/**</div><div class=\"line\">  * Update a component using a new element.</div><div class=\"line\">  *</div><div class=\"line\">  * @param &#123;ReactComponent&#125; internalInstance</div><div class=\"line\">  * @param &#123;ReactElement&#125; nextElement</div><div class=\"line\">  * @param &#123;ReactReconcileTransaction&#125; transaction</div><div class=\"line\">  * @param &#123;object&#125; context</div><div class=\"line\">  * @internal</div><div class=\"line\">  */</span></div><div class=\"line\">receiveComponent: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></div><div class=\"line\">  internalInstance,</div><div class=\"line\">  nextElement,</div><div class=\"line\">  transaction,</div><div class=\"line\">  context,</div><div class=\"line\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">var</span> prevElement = internalInstance._currentElement;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">if</span> (nextElement === prevElement &amp;&amp; context === internalInstance._context) &#123;</div><div class=\"line\">    <span class=\"comment\">// Since elements are immutable after the owner is rendered,</span></div><div class=\"line\">    <span class=\"comment\">// we can do a cheap identity compare here to determine if this is a</span></div><div class=\"line\">    <span class=\"comment\">// superfluous reconcile. It's possible for state to be mutable but such</span></div><div class=\"line\">    <span class=\"comment\">// change should trigger an update of the owner which would recreate</span></div><div class=\"line\">    <span class=\"comment\">// the element. We explicitly check for the existence of an owner since</span></div><div class=\"line\">    <span class=\"comment\">// it's possible for an element created outside a composite to be</span></div><div class=\"line\">    <span class=\"comment\">// deeply mutated and reused.</span></div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// <span class=\"doctag\">TODO:</span> Bailing out early is just a perf optimization right?</span></div><div class=\"line\">    <span class=\"comment\">// <span class=\"doctag\">TODO:</span> Removing the return statement should affect correctness?</span></div><div class=\"line\">    <span class=\"keyword\">return</span>;</div><div class=\"line\">  &#125;</div><div class=\"line\">  <span class=\"comment\">//...</span></div><div class=\"line\">  internalInstance.receiveComponent(nextElement, transaction, context);</div><div class=\"line\">  <span class=\"comment\">//...</span></div><div class=\"line\">&#125;,</div></pre></td></tr></table></figure>\n<p>又把 receiveComponent delegate 给了这个 Component 的 instance，我们再看 ReactCompositeComponent.receiveComponent：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">receiveComponent: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">nextElement, transaction, nextContext</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">var</span> prevElement = <span class=\"keyword\">this</span>._currentElement;</div><div class=\"line\">  <span class=\"keyword\">var</span> prevContext = <span class=\"keyword\">this</span>._context;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">this</span>._pendingElement = <span class=\"literal\">null</span>;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">this</span>.updateComponent(</div><div class=\"line\">    transaction,</div><div class=\"line\">    prevElement,</div><div class=\"line\">    nextElement,</div><div class=\"line\">    prevContext,</div><div class=\"line\">    nextContext,</div><div class=\"line\">  );</div><div class=\"line\">&#125;,</div></pre></td></tr></table></figure>\n<p>再看 updateComponent：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/**</div><div class=\"line\">   * Perform an update to a mounted component. The componentWillReceiveProps and</div><div class=\"line\">   * shouldComponentUpdate methods are called, then (assuming the update isn't</div><div class=\"line\">   * skipped) the remaining update lifecycle methods are called and the DOM</div><div class=\"line\">   * representation is updated.</div><div class=\"line\">   *</div><div class=\"line\">   * By default, this implements React's rendering and reconciliation algorithm.</div><div class=\"line\">   * Sophisticated clients may wish to override this.</div><div class=\"line\">   *</div><div class=\"line\">   * @param &#123;ReactReconcileTransaction&#125; transaction</div><div class=\"line\">   * @param &#123;ReactElement&#125; prevParentElement</div><div class=\"line\">   * @param &#123;ReactElement&#125; nextParentElement</div><div class=\"line\">   * @internal</div><div class=\"line\">   * @overridable</div><div class=\"line\">   */</span></div><div class=\"line\">  updateComponent: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></div><div class=\"line\">    transaction,</div><div class=\"line\">    prevParentElement,</div><div class=\"line\">    nextParentElement,</div><div class=\"line\">    prevUnmaskedContext,</div><div class=\"line\">    nextUnmaskedContext,</div><div class=\"line\">  </span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (shouldUpdate) &#123;</div><div class=\"line\">      <span class=\"keyword\">this</span>._pendingForceUpdate = <span class=\"literal\">false</span>;</div><div class=\"line\">      <span class=\"comment\">// Will set `this.props`, `this.state` and `this.context`.</span></div><div class=\"line\">      <span class=\"keyword\">this</span>._performComponentUpdate(</div><div class=\"line\">        nextParentElement,</div><div class=\"line\">        nextProps,</div><div class=\"line\">        nextState,</div><div class=\"line\">        nextContext,</div><div class=\"line\">        transaction,</div><div class=\"line\">        nextUnmaskedContext,</div><div class=\"line\">      );</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">    <span class=\"comment\">//...</span></div></pre></td></tr></table></figure>\n<p>再看 _performComponentUpdate:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/**</div><div class=\"line\">   * Merges new props and state, notifies delegate methods of update and</div><div class=\"line\">   * performs update.</div><div class=\"line\">   *</div><div class=\"line\">   * @param &#123;ReactElement&#125; nextElement Next element</div><div class=\"line\">   * @param &#123;object&#125; nextProps Next public object to set as properties.</div><div class=\"line\">   * @param &#123;?object&#125; nextState Next object to set as state.</div><div class=\"line\">   * @param &#123;?object&#125; nextContext Next public object to set as context.</div><div class=\"line\">   * @param &#123;ReactReconcileTransaction&#125; transaction</div><div class=\"line\">   * @param &#123;?object&#125; unmaskedContext</div><div class=\"line\">   * @private</div><div class=\"line\">   */</span></div><div class=\"line\">  _performComponentUpdate: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></div><div class=\"line\">    nextElement,</div><div class=\"line\">    nextProps,</div><div class=\"line\">    nextState,</div><div class=\"line\">    nextContext,</div><div class=\"line\">    transaction,</div><div class=\"line\">    unmaskedContext,</div><div class=\"line\">  </span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> inst = <span class=\"keyword\">this</span>._instance;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">var</span> hasComponentDidUpdate = !!inst.componentDidUpdate;</div><div class=\"line\">    <span class=\"keyword\">var</span> prevProps;</div><div class=\"line\">    <span class=\"keyword\">var</span> prevState;</div><div class=\"line\">    <span class=\"keyword\">if</span> (hasComponentDidUpdate) &#123;</div><div class=\"line\">      prevProps = inst.props;</div><div class=\"line\">      prevState = inst.state;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"comment\">//...</span></div><div class=\"line\">    <span class=\"keyword\">this</span>._currentElement = nextElement;</div><div class=\"line\">    <span class=\"keyword\">this</span>._context = unmaskedContext;</div><div class=\"line\">    inst.props = nextProps;</div><div class=\"line\">    inst.state = nextState;</div><div class=\"line\">    inst.context = nextContext;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">if</span> (inst.unstable_handleError) &#123;</div><div class=\"line\">      <span class=\"keyword\">this</span>._updateRenderedComponentWithErrorHandling(</div><div class=\"line\">        transaction,</div><div class=\"line\">        unmaskedContext,</div><div class=\"line\">      );</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">      <span class=\"keyword\">this</span>._updateRenderedComponent(transaction, unmaskedContext);</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"comment\">//...</span></div></pre></td></tr></table></figure>\n<p>因此我们又要看 _updateRenderedComponent:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/**</div><div class=\"line\"> * Call the component's `render` method and update the DOM accordingly.</div><div class=\"line\"> *</div><div class=\"line\"> * @param &#123;ReactReconcileTransaction&#125; transaction</div><div class=\"line\"> * @internal</div><div class=\"line\"> */</span></div><div class=\"line\">_updateRenderedComponent: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">transaction, context</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">var</span> nextRenderedElement = <span class=\"keyword\">this</span>._renderValidatedComponent();</div><div class=\"line\">  <span class=\"keyword\">this</span>._updateRenderedComponentWithNextElement(</div><div class=\"line\">    transaction,</div><div class=\"line\">    context,</div><div class=\"line\">    nextRenderedElement,</div><div class=\"line\">    <span class=\"literal\">false</span> <span class=\"comment\">/* safely */</span>,</div><div class=\"line\">  );</div><div class=\"line\">&#125;,</div></pre></td></tr></table></figure>\n<p>进入 _updateRenderedComponentWithNextElement:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/**</div><div class=\"line\">   * Call the component's `render` method and update the DOM accordingly.</div><div class=\"line\">   *</div><div class=\"line\">   * @param &#123;ReactReconcileTransaction&#125; transaction</div><div class=\"line\">   * @internal</div><div class=\"line\">   */</span></div><div class=\"line\">  _updateRenderedComponentWithNextElement: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></div><div class=\"line\">    transaction,</div><div class=\"line\">    context,</div><div class=\"line\">    nextRenderedElement,</div><div class=\"line\">    safely,</div><div class=\"line\">  </span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> prevComponentInstance = <span class=\"keyword\">this</span>._renderedComponent;</div><div class=\"line\">    <span class=\"keyword\">var</span> prevRenderedElement = prevComponentInstance._currentElement;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">var</span> debugID = <span class=\"number\">0</span>;</div><div class=\"line\">    <span class=\"keyword\">if</span> (__DEV__) &#123;</div><div class=\"line\">      debugID = <span class=\"keyword\">this</span>._debugID;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">if</span> (shouldUpdateReactComponent(prevRenderedElement, nextRenderedElement)) &#123;</div><div class=\"line\">      ReactReconciler.receiveComponent(</div><div class=\"line\">        prevComponentInstance,</div><div class=\"line\">        nextRenderedElement,</div><div class=\"line\">        transaction,</div><div class=\"line\">        <span class=\"keyword\">this</span>._processChildContext(context),</div><div class=\"line\">      );</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">      <span class=\"keyword\">var</span> oldHostNode = ReactReconciler.getHostNode(prevComponentInstance);</div><div class=\"line\">      <span class=\"keyword\">var</span> nodeType = ReactNodeTypes.getType(nextRenderedElement);</div><div class=\"line\">      <span class=\"keyword\">this</span>._renderedNodeType = nodeType;</div><div class=\"line\">      <span class=\"keyword\">var</span> child = <span class=\"keyword\">this</span>._instantiateReactComponent(</div><div class=\"line\">        nextRenderedElement,</div><div class=\"line\">        nodeType !== ReactNodeTypes.EMPTY <span class=\"comment\">/* shouldHaveDebugID */</span>,</div><div class=\"line\">      );</div><div class=\"line\">      <span class=\"keyword\">this</span>._renderedComponent = child;</div><div class=\"line\"></div><div class=\"line\">      <span class=\"keyword\">var</span> nextMarkup = ReactReconciler.mountComponent(</div><div class=\"line\">        child,</div><div class=\"line\">        transaction,</div><div class=\"line\">        <span class=\"keyword\">this</span>._hostParent,</div><div class=\"line\">        <span class=\"keyword\">this</span>._hostContainerInfo,</div><div class=\"line\">        <span class=\"keyword\">this</span>._processChildContext(context),</div><div class=\"line\">        debugID,</div><div class=\"line\">      );</div><div class=\"line\"></div><div class=\"line\">      ReactReconciler.unmountComponent(</div><div class=\"line\">        prevComponentInstance,</div><div class=\"line\">        safely,</div><div class=\"line\">        <span class=\"literal\">false</span> <span class=\"comment\">/* skipLifecycle */</span>,</div><div class=\"line\">      );</div><div class=\"line\"></div><div class=\"line\">      <span class=\"keyword\">if</span> (__DEV__) &#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (debugID !== <span class=\"number\">0</span>) &#123;</div><div class=\"line\">          <span class=\"keyword\">var</span> childDebugIDs = child._debugID !== <span class=\"number\">0</span> ? [child._debugID] : [];</div><div class=\"line\">          ReactInstrumentation.debugTool.onSetChildren(debugID, childDebugIDs);</div><div class=\"line\">        &#125;</div><div class=\"line\">      &#125;</div><div class=\"line\"></div><div class=\"line\">      <span class=\"keyword\">this</span>._replaceNodeWithMarkup(</div><div class=\"line\">        oldHostNode,</div><div class=\"line\">        nextMarkup,</div><div class=\"line\">        prevComponentInstance,</div><div class=\"line\">      );</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;,</div></pre></td></tr></table></figure>\n<p>这里注意，根据我们之前的说明：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/**</div><div class=\"line\">   * Call the component's `render` method and update the DOM accordingly.</div><div class=\"line\">   *</div><div class=\"line\">   * @param &#123;ReactReconcileTransaction&#125; transaction</div><div class=\"line\">   * @internal</div><div class=\"line\">   */</span></div><div class=\"line\">  _updateRenderedComponentWithNextElement: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></div><div class=\"line\">    transaction,</div><div class=\"line\">    context,</div><div class=\"line\">    nextRenderedElement,</div><div class=\"line\">    safely,</div><div class=\"line\">  </span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> prevComponentInstance = <span class=\"keyword\">this</span>._renderedComponent;</div><div class=\"line\">    <span class=\"keyword\">var</span> prevRenderedElement = prevComponentInstance._currentElement;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">var</span> debugID = <span class=\"number\">0</span>;</div><div class=\"line\">    <span class=\"keyword\">if</span> (__DEV__) &#123;</div><div class=\"line\">      debugID = <span class=\"keyword\">this</span>._debugID;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">if</span> (shouldUpdateReactComponent(prevRenderedElement, nextRenderedElement)) &#123;</div><div class=\"line\">      ReactReconciler.receiveComponent(</div><div class=\"line\">        prevComponentInstance,</div><div class=\"line\">        nextRenderedElement,</div><div class=\"line\">        transaction,</div><div class=\"line\">        <span class=\"keyword\">this</span>._processChildContext(context),</div><div class=\"line\">      );</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</div></pre></td></tr></table></figure>\n<p>这里的 prevComponentInstance 实际上是 this（这个也是一个 ComponentInstance）的 render 函数返回的 ReactElement 的 Component Instance，然后 nextRenderedElement 是当前的被更新了的 ReactElement，如果我们假设这个 prevComponentInstance 是一个 ReactDOMComponent 的话，那么一切就会进入 ReactDOMComponent 的 receiveComponent，并且接受的参数就是 nextRenderedElement，我们看一下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/**</div><div class=\"line\">   * Receives a next element and updates the component.</div><div class=\"line\">   *</div><div class=\"line\">   * @internal</div><div class=\"line\">   * @param &#123;ReactElement&#125; nextElement</div><div class=\"line\">   * @param &#123;ReactReconcileTransaction|ReactServerRenderingTransaction&#125; transaction</div><div class=\"line\">   * @param &#123;object&#125; context</div><div class=\"line\">   */</span></div><div class=\"line\">  receiveComponent: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">nextElement, transaction, context</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> prevElement = <span class=\"keyword\">this</span>._currentElement;</div><div class=\"line\">    <span class=\"keyword\">this</span>._currentElement = nextElement;</div><div class=\"line\">    <span class=\"keyword\">this</span>.updateComponent(transaction, prevElement, nextElement, context);</div><div class=\"line\">  &#125;,</div></pre></td></tr></table></figure>\n<p>在看 updateComponent：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/**</div><div class=\"line\"> * Updates a DOM component after it has already been allocated and</div><div class=\"line\"> * attached to the DOM. Reconciles the root DOM node, then recurses.</div><div class=\"line\"> *</div><div class=\"line\"> * @param &#123;ReactReconcileTransaction&#125; transaction</div><div class=\"line\"> * @param &#123;ReactElement&#125; prevElement</div><div class=\"line\"> * @param &#123;ReactElement&#125; nextElement</div><div class=\"line\"> * @internal</div><div class=\"line\"> * @overridable</div><div class=\"line\"> */</span></div><div class=\"line\">updateComponent: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">transaction, prevElement, nextElement, context</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">var</span> lastProps = prevElement.props;</div><div class=\"line\">  <span class=\"keyword\">var</span> nextProps = <span class=\"keyword\">this</span>._currentElement.props;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">switch</span> (<span class=\"keyword\">this</span>._tag) &#123;</div><div class=\"line\">    <span class=\"keyword\">case</span> <span class=\"string\">'input'</span>:</div><div class=\"line\">      lastProps = ReactDOMInput.getHostProps(<span class=\"keyword\">this</span>, lastProps);</div><div class=\"line\">      nextProps = ReactDOMInput.getHostProps(<span class=\"keyword\">this</span>, nextProps);</div><div class=\"line\">      <span class=\"keyword\">break</span>;</div><div class=\"line\">    <span class=\"keyword\">case</span> <span class=\"string\">'option'</span>:</div><div class=\"line\">      lastProps = ReactDOMOption.getHostProps(<span class=\"keyword\">this</span>, lastProps);</div><div class=\"line\">      nextProps = ReactDOMOption.getHostProps(<span class=\"keyword\">this</span>, nextProps);</div><div class=\"line\">      <span class=\"keyword\">break</span>;</div><div class=\"line\">    <span class=\"keyword\">case</span> <span class=\"string\">'select'</span>:</div><div class=\"line\">      lastProps = ReactDOMSelect.getHostProps(<span class=\"keyword\">this</span>, lastProps);</div><div class=\"line\">      nextProps = ReactDOMSelect.getHostProps(<span class=\"keyword\">this</span>, nextProps);</div><div class=\"line\">      <span class=\"keyword\">break</span>;</div><div class=\"line\">    <span class=\"keyword\">case</span> <span class=\"string\">'textarea'</span>:</div><div class=\"line\">      lastProps = ReactDOMTextarea.getHostProps(<span class=\"keyword\">this</span>, lastProps);</div><div class=\"line\">      nextProps = ReactDOMTextarea.getHostProps(<span class=\"keyword\">this</span>, nextProps);</div><div class=\"line\">      <span class=\"keyword\">break</span>;</div><div class=\"line\">    <span class=\"keyword\">default</span>:</div><div class=\"line\">      <span class=\"keyword\">if</span> (</div><div class=\"line\">        <span class=\"keyword\">typeof</span> lastProps.onClick !== <span class=\"string\">'function'</span> &amp;&amp;</div><div class=\"line\">        <span class=\"keyword\">typeof</span> nextProps.onClick === <span class=\"string\">'function'</span></div><div class=\"line\">      ) &#123;</div><div class=\"line\">        transaction</div><div class=\"line\">          .getReactMountReady()</div><div class=\"line\">          .enqueue(trapClickOnNonInteractiveElement, <span class=\"keyword\">this</span>);</div><div class=\"line\">      &#125;</div><div class=\"line\">      <span class=\"keyword\">break</span>;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  assertValidProps(<span class=\"keyword\">this</span>, nextProps);</div><div class=\"line\">  <span class=\"keyword\">var</span> isCustomComponentTag = isCustomComponent(<span class=\"keyword\">this</span>._tag, nextProps);</div><div class=\"line\">  <span class=\"keyword\">this</span>._updateDOMProperties(</div><div class=\"line\">    lastProps,</div><div class=\"line\">    nextProps,</div><div class=\"line\">    transaction,</div><div class=\"line\">    isCustomComponentTag,</div><div class=\"line\">  );</div><div class=\"line\">  <span class=\"keyword\">this</span>._updateDOMChildren(lastProps, nextProps, transaction, context);</div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">switch</span> (<span class=\"keyword\">this</span>._tag) &#123;</div><div class=\"line\">    <span class=\"keyword\">case</span> <span class=\"string\">'input'</span>:</div><div class=\"line\">      <span class=\"comment\">// Update the wrapper around inputs *after* updating props. This has to</span></div><div class=\"line\">      <span class=\"comment\">// happen after `_updateDOMProperties`. Otherwise HTML5 input validations</span></div><div class=\"line\">      <span class=\"comment\">// raise warnings and prevent the new value from being assigned.</span></div><div class=\"line\">      ReactDOMInput.updateWrapper(<span class=\"keyword\">this</span>);</div><div class=\"line\">      <span class=\"keyword\">break</span>;</div><div class=\"line\">    <span class=\"keyword\">case</span> <span class=\"string\">'textarea'</span>:</div><div class=\"line\">      ReactDOMTextarea.updateWrapper(<span class=\"keyword\">this</span>);</div><div class=\"line\">      <span class=\"keyword\">break</span>;</div><div class=\"line\">    <span class=\"keyword\">case</span> <span class=\"string\">'select'</span>:</div><div class=\"line\">      <span class=\"comment\">// &lt;select&gt; value update needs to occur after &lt;option&gt; children</span></div><div class=\"line\">      <span class=\"comment\">// reconciliation</span></div><div class=\"line\">      transaction.getReactMountReady().enqueue(postUpdateSelectWrapper, <span class=\"keyword\">this</span>);</div><div class=\"line\">      <span class=\"keyword\">break</span>;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;,</div></pre></td></tr></table></figure>\n<p>这段代码真的比较简单，唯一值得看的是 this._updateDOMChildren 这个函数:<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/**</div><div class=\"line\">   * Reconciles the children with the various properties that affect the</div><div class=\"line\">   * children content.</div><div class=\"line\">   *</div><div class=\"line\">   * @param &#123;object&#125; lastProps</div><div class=\"line\">   * @param &#123;object&#125; nextProps</div><div class=\"line\">   * @param &#123;ReactReconcileTransaction&#125; transaction</div><div class=\"line\">   * @param &#123;object&#125; context</div><div class=\"line\">   */</span></div><div class=\"line\">  _updateDOMChildren: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">lastProps, nextProps, transaction, context</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> lastContent = CONTENT_TYPES[<span class=\"keyword\">typeof</span> lastProps.children]</div><div class=\"line\">      ? lastProps.children</div><div class=\"line\">      : <span class=\"literal\">null</span>;</div><div class=\"line\">    <span class=\"keyword\">var</span> nextContent = CONTENT_TYPES[<span class=\"keyword\">typeof</span> nextProps.children]</div><div class=\"line\">      ? nextProps.children</div><div class=\"line\">      : <span class=\"literal\">null</span>;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">var</span> lastHtml =</div><div class=\"line\">      lastProps.dangerouslySetInnerHTML &amp;&amp;</div><div class=\"line\">      lastProps.dangerouslySetInnerHTML.__html;</div><div class=\"line\">    <span class=\"keyword\">var</span> nextHtml =</div><div class=\"line\">      nextProps.dangerouslySetInnerHTML &amp;&amp;</div><div class=\"line\">      nextProps.dangerouslySetInnerHTML.__html;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// Note the use of `!=` which checks for null or undefined.</span></div><div class=\"line\">    <span class=\"keyword\">var</span> lastChildren = lastContent != <span class=\"literal\">null</span> ? <span class=\"literal\">null</span> : lastProps.children;</div><div class=\"line\">    <span class=\"keyword\">var</span> nextChildren = nextContent != <span class=\"literal\">null</span> ? <span class=\"literal\">null</span> : nextProps.children;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// If we're switching from children to content/html or vice versa, remove</span></div><div class=\"line\">    <span class=\"comment\">// the old content</span></div><div class=\"line\">    <span class=\"keyword\">var</span> lastHasContentOrHtml = lastContent != <span class=\"literal\">null</span> || lastHtml != <span class=\"literal\">null</span>;</div><div class=\"line\">    <span class=\"keyword\">var</span> nextHasContentOrHtml = nextContent != <span class=\"literal\">null</span> || nextHtml != <span class=\"literal\">null</span>;</div><div class=\"line\">    <span class=\"keyword\">if</span> (lastChildren != <span class=\"literal\">null</span> &amp;&amp; nextChildren == <span class=\"literal\">null</span>) &#123;</div><div class=\"line\">      <span class=\"keyword\">this</span>.updateChildren(<span class=\"literal\">null</span>, transaction, context);</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (lastHasContentOrHtml &amp;&amp; !nextHasContentOrHtml) &#123;</div><div class=\"line\">      <span class=\"keyword\">this</span>.updateTextContent(<span class=\"string\">''</span>);</div><div class=\"line\">      <span class=\"keyword\">if</span> (__DEV__) &#123;</div><div class=\"line\">        ReactInstrumentation.debugTool.onSetChildren(<span class=\"keyword\">this</span>._debugID, []);</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">if</span> (nextContent != <span class=\"literal\">null</span>) &#123;</div><div class=\"line\">      <span class=\"keyword\">if</span> (lastContent !== nextContent) &#123;</div><div class=\"line\">        <span class=\"keyword\">this</span>.updateTextContent(<span class=\"string\">''</span> + nextContent);</div><div class=\"line\">        <span class=\"keyword\">if</span> (__DEV__) &#123;</div><div class=\"line\">          setAndValidateContentChildDev.call(<span class=\"keyword\">this</span>, nextContent);</div><div class=\"line\">        &#125;</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (nextHtml != <span class=\"literal\">null</span>) &#123;</div><div class=\"line\">      <span class=\"keyword\">if</span> (lastHtml !== nextHtml) &#123;</div><div class=\"line\">        <span class=\"keyword\">this</span>.updateMarkup(<span class=\"string\">''</span> + nextHtml);</div><div class=\"line\">      &#125;</div><div class=\"line\">      <span class=\"keyword\">if</span> (__DEV__) &#123;</div><div class=\"line\">        ReactInstrumentation.debugTool.onSetChildren(<span class=\"keyword\">this</span>._debugID, []);</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (nextChildren != <span class=\"literal\">null</span>) &#123;</div><div class=\"line\">      <span class=\"keyword\">if</span> (__DEV__) &#123;</div><div class=\"line\">        setAndValidateContentChildDev.call(<span class=\"keyword\">this</span>, <span class=\"literal\">null</span>);</div><div class=\"line\">      &#125;</div><div class=\"line\"></div><div class=\"line\">      <span class=\"keyword\">this</span>.updateChildren(nextChildren, transaction, context);</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;,</div></pre></td></tr></table></figure></p>\n<p>这段代码告诉我得看 updateChildren 这个函数，而这个函数是来自于其它类，最终在 ReactMultiChild 中找到：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/**</div><div class=\"line\">   * @param &#123;?object&#125; nextNestedChildrenElements Nested child element maps.</div><div class=\"line\">   * @param &#123;ReactReconcileTransaction&#125; transaction</div><div class=\"line\">   * @final</div><div class=\"line\">   * @protected</div><div class=\"line\">   */</span></div><div class=\"line\">  _updateChildren: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">nextNestedChildrenElements, transaction, context</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> prevChildren = <span class=\"keyword\">this</span>._renderedChildren;</div><div class=\"line\">    <span class=\"keyword\">var</span> removedNodes = &#123;&#125;;</div><div class=\"line\">    <span class=\"keyword\">var</span> mountImages = [];</div><div class=\"line\">    <span class=\"keyword\">var</span> nextChildren = <span class=\"keyword\">this</span>._reconcilerUpdateChildren(</div><div class=\"line\">      prevChildren,</div><div class=\"line\">      nextNestedChildrenElements,</div><div class=\"line\">      mountImages,</div><div class=\"line\">      removedNodes,</div><div class=\"line\">      transaction,</div><div class=\"line\">      context,</div><div class=\"line\">    );</div><div class=\"line\">    <span class=\"keyword\">if</span> (!nextChildren &amp;&amp; !prevChildren) &#123;</div><div class=\"line\">      <span class=\"keyword\">return</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">var</span> updates = <span class=\"literal\">null</span>;</div><div class=\"line\">    <span class=\"keyword\">var</span> name;</div><div class=\"line\">    <span class=\"comment\">// `nextIndex` will increment for each child in `nextChildren`, but</span></div><div class=\"line\">    <span class=\"comment\">// `lastIndex` will be the last index visited in `prevChildren`.</span></div><div class=\"line\">    <span class=\"keyword\">var</span> nextIndex = <span class=\"number\">0</span>;</div><div class=\"line\">    <span class=\"keyword\">var</span> lastIndex = <span class=\"number\">0</span>;</div><div class=\"line\">    <span class=\"comment\">// `nextMountIndex` will increment for each newly mounted child.</span></div><div class=\"line\">    <span class=\"keyword\">var</span> nextMountIndex = <span class=\"number\">0</span>;</div><div class=\"line\">    <span class=\"keyword\">var</span> lastPlacedNode = <span class=\"literal\">null</span>;</div><div class=\"line\">    <span class=\"keyword\">for</span> (name <span class=\"keyword\">in</span> nextChildren) &#123;</div><div class=\"line\">      <span class=\"keyword\">if</span> (!nextChildren.hasOwnProperty(name)) &#123;</div><div class=\"line\">        <span class=\"keyword\">continue</span>;</div><div class=\"line\">      &#125;</div><div class=\"line\">      <span class=\"keyword\">var</span> prevChild = prevChildren &amp;&amp; prevChildren[name];</div><div class=\"line\">      <span class=\"keyword\">var</span> nextChild = nextChildren[name];</div><div class=\"line\">      <span class=\"keyword\">if</span> (prevChild === nextChild) &#123;</div><div class=\"line\">        updates = enqueue(</div><div class=\"line\">          updates,</div><div class=\"line\">          <span class=\"keyword\">this</span>.moveChild(prevChild, lastPlacedNode, nextIndex, lastIndex),</div><div class=\"line\">        );</div><div class=\"line\">        lastIndex = <span class=\"built_in\">Math</span>.max(prevChild._mountIndex, lastIndex);</div><div class=\"line\">        prevChild._mountIndex = nextIndex;</div><div class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (prevChild) &#123;</div><div class=\"line\">          <span class=\"comment\">// Update `lastIndex` before `_mountIndex` gets unset by unmounting.</span></div><div class=\"line\">          lastIndex = <span class=\"built_in\">Math</span>.max(prevChild._mountIndex, lastIndex);</div><div class=\"line\">          <span class=\"comment\">// The `removedNodes` loop below will actually remove the child.</span></div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"comment\">// The child must be instantiated before it's mounted.</span></div><div class=\"line\">        updates = enqueue(</div><div class=\"line\">          updates,</div><div class=\"line\">          <span class=\"keyword\">this</span>._mountChildAtIndex(</div><div class=\"line\">            nextChild,</div><div class=\"line\">            mountImages[nextMountIndex],</div><div class=\"line\">            lastPlacedNode,</div><div class=\"line\">            nextIndex,</div><div class=\"line\">            transaction,</div><div class=\"line\">            context,</div><div class=\"line\">          ),</div><div class=\"line\">        );</div><div class=\"line\">        nextMountIndex++;</div><div class=\"line\">      &#125;</div><div class=\"line\">      nextIndex++;</div><div class=\"line\">      lastPlacedNode = ReactReconciler.getHostNode(nextChild);</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"comment\">// Remove children that are no longer present.</span></div><div class=\"line\">    <span class=\"keyword\">for</span> (name <span class=\"keyword\">in</span> removedNodes) &#123;</div><div class=\"line\">      <span class=\"keyword\">if</span> (removedNodes.hasOwnProperty(name)) &#123;</div><div class=\"line\">        updates = enqueue(</div><div class=\"line\">          updates,</div><div class=\"line\">          <span class=\"keyword\">this</span>._unmountChild(prevChildren[name], removedNodes[name]),</div><div class=\"line\">        );</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">if</span> (updates) &#123;</div><div class=\"line\">      processQueue(<span class=\"keyword\">this</span>, updates);</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">this</span>._renderedChildren = nextChildren;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">if</span> (__DEV__) &#123;</div><div class=\"line\">      setChildrenForInstrumentation.call(<span class=\"keyword\">this</span>, nextChildren);</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;,</div></pre></td></tr></table></figure></p>\n<p>还得看 this._reconcilerUpdateChildren 这个函数：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div></pre></td><td class=\"code\"><pre><div class=\"line\">_reconcilerUpdateChildren: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></div><div class=\"line\">    prevChildren,</div><div class=\"line\">    nextNestedChildrenElements,</div><div class=\"line\">    mountImages,</div><div class=\"line\">    removedNodes,</div><div class=\"line\">    transaction,</div><div class=\"line\">    context,</div><div class=\"line\">  </span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> nextChildren;</div><div class=\"line\">    <span class=\"keyword\">var</span> selfDebugID = <span class=\"number\">0</span>;</div><div class=\"line\">    <span class=\"keyword\">if</span> (__DEV__) &#123;</div><div class=\"line\">      selfDebugID = getDebugID(<span class=\"keyword\">this</span>);</div><div class=\"line\">      <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>._currentElement) &#123;</div><div class=\"line\">        <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">          ReactCurrentOwner.current = <span class=\"keyword\">this</span>._currentElement._owner;</div><div class=\"line\">          nextChildren = flattenStackChildren(</div><div class=\"line\">            nextNestedChildrenElements,</div><div class=\"line\">            selfDebugID,</div><div class=\"line\">          );</div><div class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</div><div class=\"line\">          ReactCurrentOwner.current = <span class=\"literal\">null</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\">        ReactChildReconciler.updateChildren(</div><div class=\"line\">          prevChildren,</div><div class=\"line\">          nextChildren,</div><div class=\"line\">          mountImages,</div><div class=\"line\">          removedNodes,</div><div class=\"line\">          transaction,</div><div class=\"line\">          <span class=\"keyword\">this</span>,</div><div class=\"line\">          <span class=\"keyword\">this</span>._hostContainerInfo,</div><div class=\"line\">          context,</div><div class=\"line\">          selfDebugID,</div><div class=\"line\">        );</div><div class=\"line\">        <span class=\"keyword\">return</span> nextChildren;</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    nextChildren = flattenStackChildren(</div><div class=\"line\">      nextNestedChildrenElements,</div><div class=\"line\">      selfDebugID,</div><div class=\"line\">    );</div><div class=\"line\">    ReactChildReconciler.updateChildren(</div><div class=\"line\">      prevChildren,</div><div class=\"line\">      nextChildren,</div><div class=\"line\">      mountImages,</div><div class=\"line\">      removedNodes,</div><div class=\"line\">      transaction,</div><div class=\"line\">      <span class=\"keyword\">this</span>,</div><div class=\"line\">      <span class=\"keyword\">this</span>._hostContainerInfo,</div><div class=\"line\">      context,</div><div class=\"line\">      selfDebugID,</div><div class=\"line\">    );</div><div class=\"line\">    <span class=\"keyword\">return</span> nextChildren;</div><div class=\"line\">  &#125;,</div></pre></td></tr></table></figure>\n<p>又得看 ReactChildReconciler.updateChildren 这个函数：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/**</div><div class=\"line\">   * Updates the rendered children and returns a new set of children.</div><div class=\"line\">   *</div><div class=\"line\">   * @param &#123;?object&#125; prevChildren Previously initialized set of children.</div><div class=\"line\">   * @param &#123;?object&#125; nextChildren Flat child element maps.</div><div class=\"line\">   * @param &#123;ReactReconcileTransaction&#125; transaction</div><div class=\"line\">   * @param &#123;object&#125; context</div><div class=\"line\">   * @return &#123;?object&#125; A new set of child instances.</div><div class=\"line\">   * @internal</div><div class=\"line\">   */</span></div><div class=\"line\">  updateChildren: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></div><div class=\"line\">    prevChildren,</div><div class=\"line\">    nextChildren,</div><div class=\"line\">    mountImages,</div><div class=\"line\">    removedNodes,</div><div class=\"line\">    transaction,</div><div class=\"line\">    hostParent,</div><div class=\"line\">    hostContainerInfo,</div><div class=\"line\">    context,</div><div class=\"line\">    selfDebugID, <span class=\"regexp\">//</span> <span class=\"number\">0</span> in production and for roots</div><div class=\"line\">  </span>) </span>&#123;</div><div class=\"line\">    <span class=\"comment\">// We currently don't have a way to track moves here but if we use iterators</span></div><div class=\"line\">    <span class=\"comment\">// instead of for..in we can zip the iterators and check if an item has</span></div><div class=\"line\">    <span class=\"comment\">// moved.</span></div><div class=\"line\">    <span class=\"comment\">// <span class=\"doctag\">TODO:</span> If nothing has changed, return the prevChildren object so that we</span></div><div class=\"line\">    <span class=\"comment\">// can quickly bailout if nothing has changed.</span></div><div class=\"line\">    <span class=\"keyword\">if</span> (!nextChildren &amp;&amp; !prevChildren) &#123;</div><div class=\"line\">      <span class=\"keyword\">return</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">var</span> name;</div><div class=\"line\">    <span class=\"keyword\">var</span> prevChild;</div><div class=\"line\">    <span class=\"keyword\">for</span> (name <span class=\"keyword\">in</span> nextChildren) &#123;</div><div class=\"line\">      <span class=\"keyword\">if</span> (!nextChildren.hasOwnProperty(name)) &#123;</div><div class=\"line\">        <span class=\"keyword\">continue</span>;</div><div class=\"line\">      &#125;</div><div class=\"line\">      prevChild = prevChildren &amp;&amp; prevChildren[name];</div><div class=\"line\">      <span class=\"keyword\">var</span> prevElement = prevChild &amp;&amp; prevChild._currentElement;</div><div class=\"line\">      <span class=\"keyword\">var</span> nextElement = nextChildren[name];</div><div class=\"line\">      <span class=\"keyword\">if</span> (</div><div class=\"line\">        prevChild != <span class=\"literal\">null</span> &amp;&amp;</div><div class=\"line\">        shouldUpdateReactComponent(prevElement, nextElement)</div><div class=\"line\">      ) &#123;</div><div class=\"line\">        ReactReconciler.receiveComponent(</div><div class=\"line\">          prevChild,</div><div class=\"line\">          nextElement,</div><div class=\"line\">          transaction,</div><div class=\"line\">          context,</div><div class=\"line\">        );</div><div class=\"line\">        nextChildren[name] = prevChild;</div><div class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">        <span class=\"comment\">// The child must be instantiated before it's mounted.</span></div><div class=\"line\">        <span class=\"keyword\">var</span> nextChildInstance = instantiateReactComponent(nextElement, <span class=\"literal\">true</span>);</div><div class=\"line\">        nextChildren[name] = nextChildInstance;</div><div class=\"line\">        <span class=\"comment\">// Creating mount image now ensures refs are resolved in right order</span></div><div class=\"line\">        <span class=\"comment\">// (see https://github.com/facebook/react/pull/7101 for explanation).</span></div><div class=\"line\">        <span class=\"keyword\">var</span> nextChildMountImage = ReactReconciler.mountComponent(</div><div class=\"line\">          nextChildInstance,</div><div class=\"line\">          transaction,</div><div class=\"line\">          hostParent,</div><div class=\"line\">          hostContainerInfo,</div><div class=\"line\">          context,</div><div class=\"line\">          selfDebugID,</div><div class=\"line\">        );</div><div class=\"line\">        mountImages.push(nextChildMountImage);</div><div class=\"line\">        <span class=\"keyword\">if</span> (prevChild) &#123;</div><div class=\"line\">          removedNodes[name] = ReactReconciler.getHostNode(prevChild);</div><div class=\"line\">          ReactReconciler.unmountComponent(</div><div class=\"line\">            prevChild,</div><div class=\"line\">            <span class=\"literal\">false</span> <span class=\"comment\">/* safely */</span>,</div><div class=\"line\">            <span class=\"literal\">false</span> <span class=\"comment\">/* skipLifecycle */</span>,</div><div class=\"line\">          );</div><div class=\"line\">        &#125;</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"comment\">// Unmount children that are no longer present.</span></div><div class=\"line\">    <span class=\"keyword\">for</span> (name <span class=\"keyword\">in</span> prevChildren) &#123;</div><div class=\"line\">      <span class=\"keyword\">if</span> (</div><div class=\"line\">        prevChildren.hasOwnProperty(name) &amp;&amp;</div><div class=\"line\">        !(nextChildren &amp;&amp; nextChildren.hasOwnProperty(name))</div><div class=\"line\">      ) &#123;</div><div class=\"line\">        prevChild = prevChildren[name];</div><div class=\"line\">        removedNodes[name] = ReactReconciler.getHostNode(prevChild);</div><div class=\"line\">        ReactReconciler.unmountComponent(</div><div class=\"line\">          prevChild,</div><div class=\"line\">          <span class=\"literal\">false</span> <span class=\"comment\">/* safely */</span>,</div><div class=\"line\">          <span class=\"literal\">false</span> <span class=\"comment\">/* skipLifecycle */</span>,</div><div class=\"line\">        );</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;,</div></pre></td></tr></table></figure></p>\n<p>到这里基本上结束了，这个函数会遍历所有 children，然后对其调用 ReactReconciler.receiveComponent（如果只是更新的话）或者 直接走 mount 新节点／unmount 旧节点的流程。</p>\n<h2 id=\"更新触发起点\"><a href=\"#更新触发起点\" class=\"headerlink\" title=\"更新触发起点\"></a>更新触发起点</h2><p>现在有一个重要的问题其实还没解决，那就是哪里是更新触发的起点，即究竟是通过哪一个函数触发了更新（也就是说调用了 performUpdateIfnecessary 这个函数）:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">runBatchedUpdates</span>(<span class=\"params\">transaction</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">var</span> len = transaction.dirtyComponentsLength;</div><div class=\"line\">  invariant(</div><div class=\"line\">    len === dirtyComponents.length,</div><div class=\"line\">    <span class=\"string\">\"Expected flush transaction's stored dirty-components length (%s) to \"</span> +</div><div class=\"line\">      <span class=\"string\">'match dirty-components array length (%s).'</span>,</div><div class=\"line\">    len,</div><div class=\"line\">    dirtyComponents.length,</div><div class=\"line\">  );</div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">// Since reconciling a component higher in the owner hierarchy usually (not</span></div><div class=\"line\">  <span class=\"comment\">// always -- see shouldComponentUpdate()) will reconcile children, reconcile</span></div><div class=\"line\">  <span class=\"comment\">// them before their children by sorting the array.</span></div><div class=\"line\">  dirtyComponents.sort(mountOrderComparator);</div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">// Any updates enqueued while reconciling must be performed after this entire</span></div><div class=\"line\">  <span class=\"comment\">// batch. Otherwise, if dirtyComponents is [A, B] where A has children B and</span></div><div class=\"line\">  <span class=\"comment\">// C, B could update twice in a single batch if C's render enqueues an update</span></div><div class=\"line\">  <span class=\"comment\">// to B (since B would have already updated, we should skip it, and the only</span></div><div class=\"line\">  <span class=\"comment\">// way we can know to do so is by checking the batch counter).</span></div><div class=\"line\">  updateBatchNumber++;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; len; i++) &#123;</div><div class=\"line\">    <span class=\"comment\">// If a component is unmounted before pending changes apply, it will still</span></div><div class=\"line\">    <span class=\"comment\">// be here, but we assume that it has cleared its _pendingCallbacks and</span></div><div class=\"line\">    <span class=\"comment\">// that performUpdateIfNecessary is a noop.</span></div><div class=\"line\">    <span class=\"keyword\">var</span> component = dirtyComponents[i];</div><div class=\"line\"></div><div class=\"line\">    ReactReconciler.performUpdateIfNecessary(</div><div class=\"line\">      component,</div><div class=\"line\">      transaction.reconcileTransaction,</div><div class=\"line\">      updateBatchNumber,</div><div class=\"line\">    );</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>然后再向上追溯:<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> flushBatchedUpdates = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"comment\">// ReactUpdatesFlushTransaction's wrappers will clear the dirtyComponents</span></div><div class=\"line\">  <span class=\"comment\">// array and perform any updates enqueued by mount-ready handlers (i.e.,</span></div><div class=\"line\">  <span class=\"comment\">// componentDidUpdate) but we need to check here too in order to catch</span></div><div class=\"line\">  <span class=\"comment\">// updates enqueued by setState callbacks.</span></div><div class=\"line\">  <span class=\"keyword\">while</span> (dirtyComponents.length) &#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> transaction = ReactUpdatesFlushTransaction.getPooled();</div><div class=\"line\">    transaction.perform(runBatchedUpdates, <span class=\"literal\">null</span>, transaction);</div><div class=\"line\">    ReactUpdatesFlushTransaction.release(transaction);</div><div class=\"line\">  &#125;</div></pre></td></tr></table></figure></p>\n<p>发现在 ReactDefaultBatchingStrategy 这个文件中:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> RESET_BATCHED_UPDATES = &#123;</div><div class=\"line\">  <span class=\"attr\">initialize</span>: emptyFunction,</div><div class=\"line\">  <span class=\"attr\">close</span>: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    ReactDefaultBatchingStrategy.isBatchingUpdates = <span class=\"literal\">false</span>;</div><div class=\"line\">  &#125;,</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> FLUSH_BATCHED_UPDATES = &#123;</div><div class=\"line\">  <span class=\"attr\">initialize</span>: emptyFunction,</div><div class=\"line\">  <span class=\"attr\">close</span>: ReactUpdates.flushBatchedUpdates.bind(ReactUpdates),</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> TRANSACTION_WRAPPERS = [FLUSH_BATCHED_UPDATES, RESET_BATCHED_UPDATES];</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">ReactDefaultBatchingStrategyTransaction</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">this</span>.reinitializeTransaction();</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">Object</span>.assign(ReactDefaultBatchingStrategyTransaction.prototype, Transaction, &#123;</div><div class=\"line\">  <span class=\"attr\">getTransactionWrappers</span>: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> TRANSACTION_WRAPPERS;</div><div class=\"line\">  &#125;,</div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> transaction = <span class=\"keyword\">new</span> ReactDefaultBatchingStrategyTransaction();</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> ReactDefaultBatchingStrategy = &#123;</div><div class=\"line\">  <span class=\"attr\">isBatchingUpdates</span>: <span class=\"literal\">false</span>,</div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">/**</div><div class=\"line\">   * Call the provided function in a context within which calls to `setState`</div><div class=\"line\">   * and friends are batched such that components aren't updated unnecessarily.</div><div class=\"line\">   */</span></div><div class=\"line\">  batchedUpdates: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">callback, a, b, c, d, e</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> alreadyBatchingUpdates = ReactDefaultBatchingStrategy.isBatchingUpdates;</div><div class=\"line\"></div><div class=\"line\">    ReactDefaultBatchingStrategy.isBatchingUpdates = <span class=\"literal\">true</span>;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// The code is written this way to avoid extra allocations</span></div><div class=\"line\">    <span class=\"keyword\">if</span> (alreadyBatchingUpdates) &#123;</div><div class=\"line\">      <span class=\"keyword\">return</span> callback(a, b, c, d, e);</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">      <span class=\"keyword\">return</span> transaction.perform(callback, <span class=\"literal\">null</span>, a, b, c, d, e);</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;,</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">module</span>.exports = ReactDefaultBatchingStrategy;</div></pre></td></tr></table></figure>\n<p>react 很经典的一个 transaction 处理，然后再去找 ReactDefaultBatchingStrategy 的使用，由于 DOM 和 Native 的应用场景不同，这个 Strategy 是动态插入的，我们可以看 DOM 的场景：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// ReactDOMStackInjection.js</span></div><div class=\"line\"><span class=\"keyword\">var</span> alreadyInjected = <span class=\"literal\">false</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">inject</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">if</span> (alreadyInjected) &#123;</div><div class=\"line\">    <span class=\"comment\">// <span class=\"doctag\">TODO:</span> This is currently true because these injections are shared between</span></div><div class=\"line\">    <span class=\"comment\">// the client and the server package. They should be built independently</span></div><div class=\"line\">    <span class=\"comment\">// and not share any injection state. Then this problem will be solved.</span></div><div class=\"line\">    <span class=\"keyword\">return</span>;</div><div class=\"line\">  &#125;</div><div class=\"line\">  alreadyInjected = <span class=\"literal\">true</span>;</div><div class=\"line\"></div><div class=\"line\">  ReactGenericBatching.injection.injectStackBatchedUpdates(</div><div class=\"line\">    ReactUpdates.batchedUpdates,</div><div class=\"line\">  );</div><div class=\"line\"></div><div class=\"line\">  ReactHostComponent.injection.injectGenericComponentClass(ReactDOMComponent);</div><div class=\"line\"></div><div class=\"line\">  ReactHostComponent.injection.injectTextComponentClass(ReactDOMTextComponent);</div><div class=\"line\"></div><div class=\"line\">  ReactEmptyComponent.injection.injectEmptyComponentFactory(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></div><div class=\"line\">    instantiate,</div><div class=\"line\">  </span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> ReactDOMEmptyComponent(instantiate);</div><div class=\"line\">  &#125;);</div><div class=\"line\"></div><div class=\"line\">  ReactUpdates.injection.injectReconcileTransaction(ReactReconcileTransaction);</div><div class=\"line\">  <span class=\"comment\">/*********this-line*****************/</span></div><div class=\"line\">  ReactUpdates.injection.injectBatchingStrategy(ReactDefaultBatchingStrategy);</div><div class=\"line\">  <span class=\"comment\">/*********this-line*****************/</span></div><div class=\"line\"></div><div class=\"line\">  ReactComponentEnvironment.injection.injectEnvironment(</div><div class=\"line\">    ReactComponentBrowserEnvironment,</div><div class=\"line\">  );</div><div class=\"line\"></div><div class=\"line\">  findDOMNode._injectStack(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">inst</span>) </span>&#123;</div><div class=\"line\">    inst = getHostComponentFromComposite(inst);</div><div class=\"line\">    <span class=\"keyword\">return</span> inst ? ReactDOMComponentTree.getNodeFromInstance(inst) : <span class=\"literal\">null</span>;</div><div class=\"line\">  &#125;);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</div><div class=\"line\">  <span class=\"attr\">inject</span>: inject,</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>然后就去看 ReactUpdates 的 injection:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> ReactUpdatesInjection = &#123;</div><div class=\"line\">  <span class=\"attr\">injectReconcileTransaction</span>: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">ReconcileTransaction</span>) </span>&#123;</div><div class=\"line\">    invariant(</div><div class=\"line\">      ReconcileTransaction,</div><div class=\"line\">      <span class=\"string\">'ReactUpdates: must provide a reconcile transaction class'</span>,</div><div class=\"line\">    );</div><div class=\"line\">    ReactUpdates.ReactReconcileTransaction = ReconcileTransaction;</div><div class=\"line\">  &#125;,</div><div class=\"line\"></div><div class=\"line\">  <span class=\"attr\">injectBatchingStrategy</span>: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">_batchingStrategy</span>) </span>&#123;</div><div class=\"line\">    invariant(</div><div class=\"line\">      _batchingStrategy,</div><div class=\"line\">      <span class=\"string\">'ReactUpdates: must provide a batching strategy'</span>,</div><div class=\"line\">    );</div><div class=\"line\">    invariant(</div><div class=\"line\">      <span class=\"keyword\">typeof</span> _batchingStrategy.batchedUpdates === <span class=\"string\">'function'</span>,</div><div class=\"line\">      <span class=\"string\">'ReactUpdates: must provide a batchedUpdates() function'</span>,</div><div class=\"line\">    );</div><div class=\"line\">    invariant(</div><div class=\"line\">      <span class=\"keyword\">typeof</span> _batchingStrategy.isBatchingUpdates === <span class=\"string\">'boolean'</span>,</div><div class=\"line\">      <span class=\"string\">'ReactUpdates: must provide an isBatchingUpdates boolean attribute'</span>,</div><div class=\"line\">    );</div><div class=\"line\">    batchingStrategy = _batchingStrategy;</div><div class=\"line\">  &#125;,</div><div class=\"line\"></div><div class=\"line\">  <span class=\"attr\">getBatchingStrategy</span>: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> batchingStrategy;</div><div class=\"line\">  &#125;,</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//...</span></div><div class=\"line\"><span class=\"keyword\">var</span> ReactUpdates = &#123;</div><div class=\"line\">  <span class=\"comment\">/**</div><div class=\"line\">   * React references `ReactReconcileTransaction` using this property in order</div><div class=\"line\">   * to allow dependency injection.</div><div class=\"line\">   *</div><div class=\"line\">   * @internal</div><div class=\"line\">   */</span></div><div class=\"line\">  ReactReconcileTransaction: <span class=\"literal\">null</span>,</div><div class=\"line\"></div><div class=\"line\">  <span class=\"attr\">batchedUpdates</span>: batchedUpdates,</div><div class=\"line\">  <span class=\"attr\">enqueueUpdate</span>: enqueueUpdate,</div><div class=\"line\">  <span class=\"attr\">flushBatchedUpdates</span>: flushBatchedUpdates,</div><div class=\"line\">  <span class=\"attr\">injection</span>: ReactUpdatesInjection,</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>这个时候，需要把调用栈反过来看一下：<br>ReactUpdates.injection inject 了 ReactDefaultBatchingUpdates， 而 ReactDefaultBatchingUpdates 是一个 transaction，在其中一个 tansaction_wrapper 中，调用了 ReactUpdates.flushBatchedUpdates，然后在 flushBatchedUpdates 中又调用了 runBatchedUpdates 这个函数，而这个函数直接调用了 ReactReconciler 的 performUpdateIfNecessary，这个函数又把 performUpdateIfNecessary 的具体任务 delegate 到具体的 instance。</p>\n<p>那么接下来应该如何继续探究下去呢？继续往上追溯，ReactUpdatesInjection 中提供了一个接口 getBatchingStrategy，就顺着它就行了。但是没发现有用的信息。</p>\n<p>这个时候，我们在从 setState 开始看起:<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">ReactComponent.prototype.setState = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">partialState, callback</span>) </span>&#123;</div><div class=\"line\">  invariant(</div><div class=\"line\">    <span class=\"keyword\">typeof</span> partialState === <span class=\"string\">'object'</span> ||</div><div class=\"line\">      <span class=\"keyword\">typeof</span> partialState === <span class=\"string\">'function'</span> ||</div><div class=\"line\">      partialState == <span class=\"literal\">null</span>,</div><div class=\"line\">    <span class=\"string\">'setState(...): takes an object of state variables to update or a '</span> +</div><div class=\"line\">      <span class=\"string\">'function which returns an object of state variables.'</span>,</div><div class=\"line\">  );</div><div class=\"line\">  <span class=\"keyword\">this</span>.updater.enqueueSetState(<span class=\"keyword\">this</span>, partialState, callback, <span class=\"string\">'setState'</span>);</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure></p>\n<p>这个是 ReactBaseClasses，老实说不是很清楚这个 class 有什么作用，基本上函数都是空的，不过如果这个 updater 用的不是默认值呢？我们可以从 enqueueSetState 这个方法入手，有这么几个类 ReactPartialRenderer 和 ReactUpdateQueue，但是 ReactPartialRenderer 是 server rendering，所以只看 ReactUpdateQueue 即可:<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/**</div><div class=\"line\">   * Sets a subset of the state. This only exists because _pendingState is</div><div class=\"line\">   * internal. This provides a merging strategy that is not available to deep</div><div class=\"line\">   * properties which is confusing. <span class=\"doctag\">TODO:</span> Expose pendingState or don't use it</div><div class=\"line\">   * during the merge.</div><div class=\"line\">   *</div><div class=\"line\">   * @param &#123;ReactClass&#125; publicInstance The instance that should rerender.</div><div class=\"line\">   * @param &#123;object&#125; partialState Next partial state to be merged with state.</div><div class=\"line\">   * @param &#123;?function&#125; callback Called after state is updated.</div><div class=\"line\">   * @param &#123;?string&#125; Name of the calling function in the public API.</div><div class=\"line\">   * @internal</div><div class=\"line\">   */</span></div><div class=\"line\">  enqueueSetState: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></div><div class=\"line\">    publicInstance,</div><div class=\"line\">    partialState,</div><div class=\"line\">    callback,</div><div class=\"line\">    callerName,</div><div class=\"line\">  </span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (__DEV__) &#123;</div><div class=\"line\">      ReactInstrumentation.debugTool.onSetState();</div><div class=\"line\">      warning(</div><div class=\"line\">        partialState != <span class=\"literal\">null</span>,</div><div class=\"line\">        <span class=\"string\">'setState(...): You passed an undefined or null state object; '</span> +</div><div class=\"line\">          <span class=\"string\">'instead, use forceUpdate().'</span>,</div><div class=\"line\">      );</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">var</span> internalInstance = getInternalInstanceReadyForUpdate(publicInstance);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">if</span> (!internalInstance) &#123;</div><div class=\"line\">      <span class=\"keyword\">return</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">var</span> queue =</div><div class=\"line\">      internalInstance._pendingStateQueue ||</div><div class=\"line\">      (internalInstance._pendingStateQueue = []);</div><div class=\"line\">    queue.push(partialState);</div><div class=\"line\"></div><div class=\"line\">    callback = callback === <span class=\"literal\">undefined</span> ? <span class=\"literal\">null</span> : callback;</div><div class=\"line\">    <span class=\"keyword\">if</span> (callback !== <span class=\"literal\">null</span>) &#123;</div><div class=\"line\">      <span class=\"keyword\">if</span> (__DEV__) &#123;</div><div class=\"line\">        warnOnInvalidCallback(callback, callerName);</div><div class=\"line\">      &#125;</div><div class=\"line\">      <span class=\"keyword\">if</span> (internalInstance._pendingCallbacks) &#123;</div><div class=\"line\">        internalInstance._pendingCallbacks.push(callback);</div><div class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">        internalInstance._pendingCallbacks = [callback];</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    enqueueUpdate(internalInstance);</div><div class=\"line\">  &#125;,</div></pre></td></tr></table></figure></p>\n<p>这个函数表明 partialState 会被存在 internalInstance._pendingStateQueue 中，然后会调用 enquereUpdate，这个函数实际上来自 ReactUpdates.js 中:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/**</div><div class=\"line\"> * Mark a component as needing a rerender, adding an optional callback to a</div><div class=\"line\"> * list of functions which will be executed once the rerender occurs.</div><div class=\"line\"> */</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">enqueueUpdate</span>(<span class=\"params\">component</span>) </span>&#123;</div><div class=\"line\">  ensureInjected();</div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">// Various parts of our code (such as ReactCompositeComponent's</span></div><div class=\"line\">  <span class=\"comment\">// _renderValidatedComponent) assume that calls to render aren't nested;</span></div><div class=\"line\">  <span class=\"comment\">// verify that that's the case. (This is called by each top-level update</span></div><div class=\"line\">  <span class=\"comment\">// function, like setState, forceUpdate, etc.; creation and</span></div><div class=\"line\">  <span class=\"comment\">// destruction of top-level components is guarded in ReactMount.)</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">if</span> (!batchingStrategy.isBatchingUpdates) &#123;</div><div class=\"line\">    batchingStrategy.batchedUpdates(enqueueUpdate, component);</div><div class=\"line\">    <span class=\"keyword\">return</span>;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  dirtyComponents.push(component);</div><div class=\"line\">  <span class=\"keyword\">if</span> (component._updateBatchNumber == <span class=\"literal\">null</span>) &#123;</div><div class=\"line\">    component._updateBatchNumber = updateBatchNumber + <span class=\"number\">1</span>;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这个 batchedUpdates 其实就是上面提供的 ReactDefaultBatchingStrategy:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> ReactDefaultBatchingStrategy = &#123;</div><div class=\"line\">  <span class=\"attr\">isBatchingUpdates</span>: <span class=\"literal\">false</span>,</div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">/**</div><div class=\"line\">   * Call the provided function in a context within which calls to `setState`</div><div class=\"line\">   * and friends are batched such that components aren't updated unnecessarily.</div><div class=\"line\">   */</span></div><div class=\"line\">  batchedUpdates: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">callback, a, b, c, d, e</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> alreadyBatchingUpdates = ReactDefaultBatchingStrategy.isBatchingUpdates;</div><div class=\"line\"></div><div class=\"line\">    ReactDefaultBatchingStrategy.isBatchingUpdates = <span class=\"literal\">true</span>;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// The code is written this way to avoid extra allocations</span></div><div class=\"line\">    <span class=\"keyword\">if</span> (alreadyBatchingUpdates) &#123;</div><div class=\"line\">      <span class=\"keyword\">return</span> callback(a, b, c, d, e);</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">      <span class=\"keyword\">return</span> transaction.perform(callback, <span class=\"literal\">null</span>, a, b, c, d, e);</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;,</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>结合两段代码来看实际上是有两种情况，一种是正在 batching，还有一种是还没开始 batching，很容易理解，但是到目前为止似乎这个 BatchingStrategy 并没有做到 batching 这个功能，暂时先不管，继续往下看，在 transaction 的 perform 完成后，肯定是要调用 其创建时定义的 wrapper，我们也即是之前提到的:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> RESET_BATCHED_UPDATES = &#123;</div><div class=\"line\">  <span class=\"attr\">initialize</span>: emptyFunction,</div><div class=\"line\">  <span class=\"attr\">close</span>: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    ReactDefaultBatchingStrategy.isBatchingUpdates = <span class=\"literal\">false</span>;</div><div class=\"line\">  &#125;,</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> FLUSH_BATCHED_UPDATES = &#123;</div><div class=\"line\">  <span class=\"attr\">initialize</span>: emptyFunction,</div><div class=\"line\">  <span class=\"attr\">close</span>: ReactUpdates.flushBatchedUpdates.bind(ReactUpdates),</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>ReactUpdates.flushBatchedUpdates 被调用了，如果再深入下去，就可以回到我们开头的部分了。</p>\n<p>目前总体看来还有一个问题，就是 setState 似乎完全不是 enqueue 的机制，但是它函数名还这么写，我们看到的是立即更新，并没有停一下再更新。<br>真的是这样吗？<br>看到这样一篇<a href=\"https://www.bennadel.com/blog/2893-setstate-state-mutation-operation-may-be-synchronous-in-reactjs.htm\">文章</a>，文中指只有在 onClick 的实践处理中 setState 是 equeue 机制的，在 event not managed by react 中又是同步的。</p>\n<p>后来我进行断点调试，一步一步地进行两种情况的执行顺序，然后我发现，如果是通过 props 定义的事件响应，那么当使用 setState 的时候，触发的 enqueueUpdate:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">/**</div><div class=\"line\"> * Mark a component as needing a rerender, adding an optional callback to a</div><div class=\"line\"> * list of functions which will be executed once the rerender occurs.</div><div class=\"line\"> */</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">enqueueUpdate</span>(<span class=\"params\">component</span>) </span>&#123;</div><div class=\"line\">  ensureInjected();</div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">// Various parts of our code (such as ReactCompositeComponent's</span></div><div class=\"line\">  <span class=\"comment\">// _renderValidatedComponent) assume that calls to render aren't nested;</span></div><div class=\"line\">  <span class=\"comment\">// verify that that's the case. (This is called by each top-level update</span></div><div class=\"line\">  <span class=\"comment\">// function, like setState, forceUpdate, etc.; creation and</span></div><div class=\"line\">  <span class=\"comment\">// destruction of top-level components is guarded in ReactMount.)</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">if</span> (!batchingStrategy.isBatchingUpdates) &#123;</div><div class=\"line\">    batchingStrategy.batchedUpdates(enqueueUpdate, component);</div><div class=\"line\">    <span class=\"keyword\">return</span>;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  dirtyComponents.push(component);</div><div class=\"line\">  <span class=\"keyword\">if</span> (component._updateBatchNumber == <span class=\"literal\">null</span>) &#123;</div><div class=\"line\">    component._updateBatchNumber = updateBatchNumber + <span class=\"number\">1</span>;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>中的 batchingStrategy.isBatchingUpdates 是 true 的，也就是说 setState 本身是处于一个 update 的 transaction 中的，所以 batchingStrategy.batchedUpdates 是不会调用的，因此如果不断的 setState 就会产生 state 本身不更新，并且将传入的 partialstate 逐步 batching，最终在触发 React 的 onClick 事件中引发的外层 update transaction 的 close 函数中进行最终的 update。</p>\n"}],"PostAsset":[],"PostCategory":[],"PostTag":[{"post_id":"cjbdyo30l0000nf8jlzfunu8x","tag_id":"cjbdyo30r0002nf8j1osen0r9","_id":"cjbdyo30y0007nf8j2tbhufop"},{"post_id":"cjbdyo30p0001nf8jgkq3ixce","tag_id":"cjbdyo30y0006nf8jsm5c8f6m","_id":"cjbdyo31c000cnf8jh9i23nn9"},{"post_id":"cjbdyo30u0004nf8j5zcii1q6","tag_id":"cjbdyo313000anf8jmcps1bdz","_id":"cjbdyo31h000gnf8jx4cjd292"},{"post_id":"cjbdyo314000bnf8jozkvtxfk","tag_id":"cjbdyo31g000enf8jwn2p94xm","_id":"cjbdyo31l000knf8jpae8xmyc"},{"post_id":"cjbdyo31g000fnf8j64032py9","tag_id":"cjbdyo31k000jnf8jdkgj4qis","_id":"cjbdyo31o000pnf8jvl7i3ti7"},{"post_id":"cjbdyo31i000hnf8j0t03rcl9","tag_id":"cjbdyo31n000nnf8j41plivyb","_id":"cjbdyo31u000tnf8j7d55z3vt"},{"post_id":"cjbdyo31l000lnf8jzei3d06v","tag_id":"cjbdyo31q000rnf8jnf59tscj","_id":"cjbdyo31x000xnf8jnvp3p92w"},{"post_id":"cjbdyo31m000mnf8jfncyupkg","tag_id":"cjbdyo31w000vnf8j37z2cgy0","_id":"cjbdyo3220011nf8jlx9imjwn"},{"post_id":"cjbdyo31n000onf8ji2v20mau","tag_id":"cjbdyo3210010nf8jcm9l68kt","_id":"cjbdyo3240013nf8jfaarrirs"},{"post_id":"cjbdyo31o000qnf8je5yo93sq","tag_id":"cjbdyo3230012nf8j188ujdxy","_id":"cjbdyo3250015nf8jgy8o0wcs"},{"post_id":"cjbdyo31q000snf8jud30y9au","tag_id":"cjbdyo3240014nf8j0p47oss6","_id":"cjbdyo3260017nf8jq2xde3o5"},{"post_id":"cjbdyo31v000unf8jmeb6px4d","tag_id":"cjbdyo3250016nf8jdrlywe9l","_id":"cjbdyo32b0019nf8jc6k1nw2t"},{"post_id":"cjbdyo31w000wnf8ja5zgy2w2","tag_id":"cjbdyo3280018nf8jdag2emaa","_id":"cjbdyo32c001bnf8j1xf41y49"},{"post_id":"cjbdyo31y000ynf8jxwwcf2il","tag_id":"cjbdyo32b001anf8jpk6p81gz","_id":"cjbdyo32c001dnf8jfortwcrw"},{"post_id":"cjbdyo321000znf8j2e7gceri","tag_id":"cjbdyo32c001cnf8j3outdst5","_id":"cjbdyo32d001enf8jmhp8mg9m"}],"Tag":[{"name":"Design-Pattern ES6","_id":"cjbdyo30r0002nf8j1osen0r9"},{"name":"http webserver","_id":"cjbdyo30y0006nf8jsm5c8f6m"},{"name":"Log","_id":"cjbdyo313000anf8jmcps1bdz"},{"name":"css","_id":"cjbdyo31g000enf8jwn2p94xm"},{"name":"Javascript 异步编程","_id":"cjbdyo31k000jnf8jdkgj4qis"},{"name":"Encoding","_id":"cjbdyo31n000nnf8j41plivyb"},{"name":"git","_id":"cjbdyo31q000rnf8jnf59tscj"},{"name":"Web","_id":"cjbdyo31w000vnf8j37z2cgy0"},{"name":"JavaScript ECMA","_id":"cjbdyo3210010nf8jcm9l68kt"},{"name":"react","_id":"cjbdyo3230012nf8j188ujdxy"},{"name":"code techniques","_id":"cjbdyo3240014nf8j0p47oss6"},{"name":"javascript","_id":"cjbdyo3250016nf8jdrlywe9l"},{"name":"面试","_id":"cjbdyo3280018nf8jdag2emaa"},{"name":"随笔","_id":"cjbdyo32b001anf8jpk6p81gz"},{"name":"react 源码 Component setState","_id":"cjbdyo32c001cnf8j3outdst5"}]}}